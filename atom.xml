<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Addendum</title>
  
  
  <link href="http://www.zanple.top/atom.xml" rel="self"/>
  
  <link href="http://www.zanple.top/"/>
  <updated>2021-03-09T16:42:03.936Z</updated>
  <id>http://www.zanple.top/</id>
  
  <author>
    <name>Zanple</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python-调色盘生成与日志提取</title>
    <link href="http://www.zanple.top/2021/03/10/python-palettenlog/"/>
    <id>http://www.zanple.top/2021/03/10/python-palettenlog/</id>
    <published>2021-03-09T16:03:33.000Z</published>
    <updated>2021-03-09T16:42:03.936Z</updated>
    
    <content type="html"><![CDATA[<p>简单记录一下最近写的两个Python的脚本。一个是基于<a href="https://github.com/fengsp/color-thief-py">ColorThief</a> 颜色分析及Python实现，对需要处理的图片生成带有调色盘的图片；另一个是对GMiner的日志文件进行提取并计算需要得到的信息。<a id="more"></a></p><h1 id="1-调色盘生成"><a href="#1-调色盘生成" class="headerlink" title="1. 调色盘生成"></a>1. 调色盘生成</h1><div align=center><img src="image01.jpg" alt="调色盘生成" style="zoom:50%;" /></div><p>调色盘生成的目的是对输入的图片（左图）进行颜色处理，生成带有调色盘的新图片（右图）。</p><p><strong>基本思路为：利用ColorThief对图片的颜色进行提取并排序，再使用PIL生成指定大小的空白图片，将原图与提取的颜色粘贴到空白图片上，最后进行图片的储存。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageOps, ImageDraw</span><br><span class="line"><span class="keyword">from</span> colorthief <span class="keyword">import</span> ColorThief</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IMGProcessor</span>:</span></span><br><span class="line"></span><br><span class="line">    PALETTE_NUM = <span class="number">7</span> <span class="comment">#调色盘数量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#亮度排序    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">brightsort</span><span class="params">(self, color)</span>:</span></span><br><span class="line">        img_bright = <span class="number">0.2126</span> * color[<span class="number">0</span>] + <span class="number">0.7125</span> * color[<span class="number">1</span>] + <span class="number">0.0722</span> * color[<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> img_bright</span><br><span class="line"></span><br><span class="line">    <span class="comment">#根据图片大小设置边缘宽度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">borderwidth</span><span class="params">(self, img_ow)</span>:</span></span><br><span class="line">        img_border = int(img_ow * <span class="number">0.014</span>)</span><br><span class="line">        <span class="keyword">return</span> img_border</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process</span><span class="params">(self, ori_path)</span>:</span></span><br><span class="line">        <span class="comment">#路径处理</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> os.path.isabs(ori_path)): <span class="comment">#输入地址为相对地址</span></span><br><span class="line">            abs_path = os.path.abspath(ori_path) <span class="comment">#将相对地址改为绝对地址</span></span><br><span class="line">        <span class="keyword">else</span>: <span class="comment">#输入的地址为绝对地址</span></span><br><span class="line">            abs_path = ori_path</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file_list = os.listdir(abs_path) <span class="comment">#获取文件列表</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">'路径错误!'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'路径读取成功...'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> img_index <span class="keyword">in</span> file_list:</span><br><span class="line">            print(<span class="string">'正在处理图片'</span> + img_index + <span class="string">'中...'</span>)</span><br><span class="line">            img_path = os.path.join(abs_path, img_index) <span class="comment">#创建图片路径</span></span><br><span class="line">            img = Image.open(img_path)</span><br><span class="line">            img_name, img_format = os.path.splitext(img_index) <span class="comment">#获取图片名和格式</span></span><br><span class="line"></span><br><span class="line">            img_ow = img.size[<span class="number">0</span>] <span class="comment">#获取图片源宽度</span></span><br><span class="line">            img_oh = img.size[<span class="number">1</span>] <span class="comment">#获取图片源高度</span></span><br><span class="line"></span><br><span class="line">            border_width = self.borderwidth(img_ow) <span class="comment">#计算边缘宽度</span></span><br><span class="line"></span><br><span class="line">            box_size = (img_ow - (self.PALETTE_NUM - <span class="number">1</span>) * border_width) / self.PALETTE_NUM <span class="comment">#计算方块大小</span></span><br><span class="line"></span><br><span class="line">            img_nw = int (img_ow + border_width * <span class="number">2</span>) <span class="comment">#计算处理后的图片宽度</span></span><br><span class="line">            img_nh = int (img_oh + box_size + border_width * <span class="number">3</span>) <span class="comment">#计算处理后的图片高度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#绘制处理后的图片</span></span><br><span class="line">            img_new = Image.new(<span class="string">'RGB'</span>, (img_nw, img_nh), <span class="string">"white"</span>)</span><br><span class="line">            img_new.paste(img, (border_width, border_width))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#提取颜色，储存为数组palette</span></span><br><span class="line">            color_thief = ColorThief(img_path)</span><br><span class="line">            palette = color_thief.get_palette(color_count = self.PALETTE_NUM, quality=<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            palette.sort(key = self.brightsort) <span class="comment">#根据亮度排序</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">#绘制色彩方块</span></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> color <span class="keyword">in</span> palette:</span><br><span class="line">                palette_box = Image.new(<span class="string">'RGB'</span>, (int(box_size), int(box_size)), color)</span><br><span class="line">                img_new.paste(palette_box, (int(border_width + (i*box_size + i*border_width)), int(border_width + img_oh + border_width)))</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#保存图片</span></span><br><span class="line">            img_new.save(os.path.join(abs_path, img_name + <span class="string">'_palette'</span> + img_format))</span><br><span class="line">            print(<span class="string">"图片"</span> + img_index + <span class="string">'处理完成'</span>)</span><br></pre></td></tr></table></figure><h1 id="2-日志提取"><a href="#2-日志提取" class="headerlink" title="2. 日志提取"></a>2. 日志提取</h1><p>日志提取的目的是对GMiner生成的日志文件进行特定内容的提取，计算出运行的总时长、耗电量以及电费。</p><p>首先更改日志的生成规则，使其按照日期时间生成日志的文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%_log.txt</span><br></pre></td></tr></table></figure><div align=center><p><img src="image02.png" alt="日志提取内容"></p></div><p>如上图所示，在日志文件中，需要提取的内容为Uptime后面的时间与Electricity后面的耗电量。通过搜索Uptime所在的行并进行文本分割，再将每个文本的最后一个有效值进行计算（同时过滤小于10kb的无效日志）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">filepathfolder = <span class="string">"F:/GMinerLog"</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file_list = os.listdir(filepathfolder)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Wrong Path!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Path found, Caculating...'</span>)</span><br><span class="line"></span><br><span class="line">totalday = <span class="number">0</span></span><br><span class="line">totalhour = <span class="number">0</span></span><br><span class="line">totalmin = <span class="number">0</span></span><br><span class="line">totalele = <span class="number">0.000</span></span><br><span class="line">limitsize = <span class="number">10000</span></span><br><span class="line">elefee = <span class="number">0.7</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> log_index <span class="keyword">in</span> file_list:</span><br><span class="line">    filename = os.path.join(filepathfolder, log_index)</span><br><span class="line">    <span class="keyword">if</span> os.stat(filename).st_size &gt; limitsize:</span><br><span class="line">        lines = open(filename, <span class="string">"r"</span>,encoding=<span class="string">"UTF-8"</span>,errors=<span class="string">"ignore"</span>).readlines()</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">'Uptime'</span> <span class="keyword">in</span> line:</span><br><span class="line">                result = line</span><br><span class="line">        temptime = result.split(<span class="string">'Uptime: '</span>)[<span class="number">1</span>]</span><br><span class="line">        keytime = temptime.split(<span class="string">' Shares'</span>)[<span class="number">0</span>]</span><br><span class="line">        day = keytime.split(<span class="string">'d'</span>)[<span class="number">0</span>]</span><br><span class="line">        time = keytime.split(<span class="string">'d '</span>)[<span class="number">1</span>]</span><br><span class="line">        hour = time.split(<span class="string">':'</span>)[<span class="number">0</span>]</span><br><span class="line">        minutes = time.split(<span class="string">':'</span>)[<span class="number">1</span>]</span><br><span class="line">        totalday += int(day)</span><br><span class="line">        totalhour += int(hour)</span><br><span class="line">        totalmin += int(minutes)</span><br><span class="line">        tempele = result.split(<span class="string">'Electricity: '</span>)[<span class="number">1</span>]</span><br><span class="line">        keyele = tempele.split(<span class="string">'kWh'</span>)[<span class="number">0</span>]</span><br><span class="line">        totalele += float(keyele)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> totalmin &gt; <span class="number">60</span>:</span><br><span class="line">    totalhour += <span class="number">1</span></span><br><span class="line">    totalmin -= <span class="number">60</span></span><br><span class="line">totalhour += totalday * <span class="number">24</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"Total Time: %dhour %dmin."</span> %(totalhour, totalmin))</span><br><span class="line">print(<span class="string">"Total Electricity: %.3fkWh."</span> %(totalele))</span><br><span class="line">print(<span class="string">"Total Electricity Fee: %.3fRMB."</span> %(totalele*elefee))</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单记录一下最近写的两个Python的脚本。一个是基于&lt;a href=&quot;https://github.com/fengsp/color-thief-py&quot;&gt;ColorThief&lt;/a&gt; 颜色分析及Python实现，对需要处理的图片生成带有调色盘的图片；另一个是对GMiner的日志文件进行提取并计算需要得到的信息。</summary>
    
    
    
    <category term="Python" scheme="http://www.zanple.top/categories/Python/"/>
    
    
    <category term="Python" scheme="http://www.zanple.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>在Unity中实现PBR着色器</title>
    <link href="http://www.zanple.top/2021/03/07/unity-pbr-shader/"/>
    <id>http://www.zanple.top/2021/03/07/unity-pbr-shader/</id>
    <published>2021-03-07T09:06:18.000Z</published>
    <updated>2021-03-07T10:06:43.305Z</updated>
    
    <content type="html"><![CDATA[<p>在对《Unity Shader入门精要》和PBR知识的学习后，对Unity 3D标准着色器Standard的部分源码进行了学习，尝试在Unity中写一个效果与Standard第一个SubShader类似的PBR着色器。<a id="more"></a></p><hr><h1 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1. 基础概念"></a>1. 基础概念</h1><p>基于物理的渲染中有两个重要的概念：<strong>微表面</strong>与<strong>辐照度</strong>。</p><h2 id="1-1-微表面模型"><a href="#1-1-微表面模型" class="headerlink" title="1.1 微表面模型"></a>1.1 微表面模型</h2><div align=center><p><img src="image01.png" alt="微表面模型"></p></div><p>普通的光照模型假设要进行光照计算的区域是一个光滑的平面，表面的方向可以用一个单一的法向量来定义。而基于微表面的光照模型则认为要进行光照计算的区域是由无数个微小表面组成的粗糙区域。由于这些微表面已经微小到无法逐像素地进行区分，因此我们假设由一个粗糙度参数，然后用统计学的方法来概略的估算微表面的粗糙程度。<strong>基于这样一个平面的粗糙度来计算出某个向量的方向与微表面平均取向方向一致的概率。</strong></p><p>基于微表面光照模型的物理渲染遵循能量守恒定律，即一个不自发光的表面，其出射光线的能量永远不能超过入射光线的能量。为了遵守能量守恒定律，我们需要对漫反射光和镜面反射光之间做出明确的区分。当一束光线碰撞到一个表面的时候，它就会分离成一个折射部分和一个反射部分。反射部分就是会直接反射开来而不会进入平面的那部分光线，这就是我们所说的镜面光照。而折射部分就是余下的会进入表面并被吸收的那部分光线，这也就是我们所说的漫反射光照。</p><h2 id="1-2-辐照度"><a href="#1-2-辐照度" class="headerlink" title="1.2 辐照度"></a>1.2 辐照度</h2><p>辐照度学建立在几何光学的基础上，即辐射是以直线传播的，不考虑电磁波干扰、衍射等性质。关于辐照度有几个重要的概念：</p><ul><li><strong>辐射通量(Radiant flux)</strong>：辐射通量<em>Φ</em>表示的是一个光源所输出的能量。</li><li><strong>辐射率(Radiance)</strong>：辐射率表示的是一个区域平面上光线的总量。</li><li><strong>辐照度(Irradiance)</strong>：辐照度表示所有投射到点<em>P</em>上的光线的总和。</li><li><strong>辐射强度(Radiant Intensity)</strong>：辐射强度表示的是在单位球面上，一个光源向每单位立体角所投送的辐射通量。</li></ul><h2 id="1-3-BRDF"><a href="#1-3-BRDF" class="headerlink" title="1.3 BRDF"></a>1.3 BRDF</h2><p>双向反射分布函数接受入射（光）方向<em>ωi</em>，出射（观察）方向<em>ωo</em>，平面法线<em>n</em>以及一个用来表示微平面粗糙程度的参数<em>a</em>作为函数的输入参数。BRDF可以近似的求出每束光线对一个给定了材质属性的平面上最终反射出来的光线所作出的贡献程度。</p><p>目前有很好几种BRDF都能近似的得出物体表面对于光的反应，但是几乎所有实时渲染管线使用的都是一种被称为Cook-Torrance BRDF模型。Cook-Torrance BRDF兼有漫反射和镜面反射两个部分：<br>$$<br>f_r = k_d f_{lambert} +  k_s f_{cook-torrance}<br>$$<br>这里的<em>kd</em>是早先提到过的入射光线中被折射部分的能量所占的比率，而<em>ks</em>是被反射部分的比率。BRDF的左侧表示的是漫反射部分，右侧则表示镜面反射部分。</p><h1 id="2-直接光照"><a href="#2-直接光照" class="headerlink" title="2. 直接光照"></a>2. 直接光照</h1><h2 id="2-1-直接光漫反射"><a href="#2-1-直接光漫反射" class="headerlink" title="2.1 直接光漫反射"></a>2.1 直接光漫反射</h2><p>$$<br>f_{d i f f}(l, v)=\frac{\text { base Color }}{\pi}\left(1+\left(F_{D 90}-1\right)(1-n \cdot l)^{5}\right)\left(1+\left(F_{D 90}-1\right)(1-n \cdot v)^{5}\right) \<br>$$</p><p>其中，<br>$$<br>F_{D 90}=0.5+2 \text { roughness }(\boldsymbol{h} \cdot l)^{2}<br>$$<br>首先是直接光的漫反射部分，直接光的漫反射使用和Unity一样的Disney漫反射项（与Disney的原始公式有所区别，这里的ComputeDisneyDiffuseTerm中传入的是感性粗糙度），再与光源项和遮蔽项相乘便可得到直接光的漫反射结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float3 LightTerm = _LightColor0.rgb * UNITY_PI * NdotL;</span><br><span class="line">half ShadowTerm = SHADOW_ATTENUATION(i);</span><br><span class="line"></span><br><span class="line">half3 AlbedoColor = BaseColor * (<span class="number">1.0f</span> - Metallic);</span><br><span class="line">half  DisneyDiffuse = ComputeDisneyDiffuseTerm</span><br><span class="line">(NdotV, NdotL, LdotH, PerceptualRoughness);</span><br><span class="line">half3 DiffuseTerm = AlbedoColor * DisneyDiffuse * UNITY_INV_PI;</span><br><span class="line"></span><br><span class="line">half3 directDiffuse = DiffuseTerm * LightTerm * ShadowTerm;</span><br></pre></td></tr></table></figure><h2 id="2-2-直接光镜面反射"><a href="#2-2-直接光镜面反射" class="headerlink" title="2.2 直接光镜面反射"></a>2.2 直接光镜面反射</h2><p>$$<br>f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}<br>$$</p><p>镜面反射则要复杂些，最主要的则是上面三项：<br>$$<br>NDF_{GGX TR}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2 (\alpha^2 - 1) + 1)^2}<br>$$<br>D项：法线分布函数，估算在受到表面粗糙度的影响下，取向方向与中间向量一致的微平面的数量。使用的是基于GGX的公式。<br>$$<br>F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0) ( 1 - (h \cdot v))^5<br>$$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">half D = ComputeGGXTerm(NdotH, Roughness);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算法线分布函数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> half <span class="title">ComputeGGXTerm</span><span class="params">(half nh,half roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">half a2 = roughness * roughness;</span><br><span class="line">half d = (a2 - <span class="number">1.0f</span>) * nh * nh + <span class="number">1.0f</span>;</span><br><span class="line"><span class="keyword">return</span> a2 * UNITY_INV_PI / (d * d + <span class="number">1e-5</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>F项：菲涅尔反射，描述了会有多少光来参与镜面反射。即在不同的表面角下表面所反射的光线所占的比率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">half3 F = ComputeFresnelTerm(SpecularColor,VdotH);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算菲涅尔</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> half3 <span class="title">ComputeFresnelTerm</span><span class="params">(half3 F0,half cosA)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> F0 + (<span class="number">1</span> - F0) * <span class="built_in">pow</span>(<span class="number">1</span> - cosA, <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><p><img src="image02.png" alt="微平面间相互遮蔽"></p></div>$$G_{SchlickGGX}(n, v, k) = \frac{n \cdot v}{(n \cdot v)(1 - k) + k }$$G项：几何函数，描述了微平面自成阴影的属性。当一个平面相对比较粗糙的时候，平面表面上的微平面有可能挡住其他的微平面从而减少表面所反射的光线。在实现上，将G项与镜面反射的分母合并为V项计算。这里的ComputeSmithJointGGXVisibilityTerm使用了一个近似简化版本：$$\left\{\begin{array}{l}V=\left(\boldsymbol{n} \cdot \omega_{\mathrm{i}}\right)[(\boldsymbol{n} \cdot \boldsymbol{v})(1-\text { roughness })+\text { roughness }] \\L=(\boldsymbol{n} \cdot \boldsymbol{v})\left[\left(\boldsymbol{n} \cdot \omega_{\mathrm{i}}\right)(1-\text { roughness })+\text { roughness }\right] \\G=\frac{1}{2(V+L+\varepsilon)}\end{array}\right.$$<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">half V = ComputeSmithJointGGXVisibilityTerm(NdotL, NdotV, Roughness);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算Smith-Joint阴影遮掩函数，返回的是除以镜面反射项分母的可见性项V</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> half <span class="title">ComputeSmithJointGGXVisibilityTerm</span><span class="params">(half nl,half nv,half roughness)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">half a2 = roughness;</span><br><span class="line">half lambdaV = nl * (nv * (<span class="number">1</span> - a2) + a2);</span><br><span class="line">half lambdaL = nv * (nl * (<span class="number">1</span> - a2) + a2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5f</span>/(lambdaV + lambdaL + <span class="number">1e-5</span>f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到镜面反射项后，与漫反射类似，再与光源项和遮蔽项相乘便可得到直接光的镜面反射结果。</p><h1 id="3-间接光照"><a href="#3-间接光照" class="headerlink" title="3. 间接光照"></a>3. 间接光照</h1><h2 id="3-1-间接光漫反射"><a href="#3-1-间接光漫反射" class="headerlink" title="3.1 间接光漫反射"></a>3.1 间接光漫反射</h2><div align=center><img src="image03.png" alt="环境立方体贴图" style="zoom:80%;" /></div><p>间接光漫反射部分使用一个环境立方体贴图及其生成的辐照度图，使用任何一个向量对立方体贴图进行采样，就可以获取该方向上的场景辐照度。将该强度与漫反射率、遮蔽项相乘，再加上烘培好的光照贴图部分即可得到间接光的漫反射部分。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//天光，三阶球谐函数</span></span><br><span class="line">half3 skyLightComplex = ShadeSH9(float4(worldNormal, <span class="number">1</span>));</span><br><span class="line">half3 skyLight = skyLightComplex * AlbedoColor;</span><br><span class="line">skyLight = skyLight * occlusion;</span><br><span class="line"><span class="comment">//采样烘焙的光照贴图</span></span><br><span class="line">half3 bakedColor = half3(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(LIGHTMAP_ON)</span></span><br><span class="line">half4 bakedColorTex = UNITY_SAMPLE_TEX2D(unity_Lightmap, data.lightmapUV.xy);</span><br><span class="line"><span class="comment">//光照贴图存储的是HDR颜色，所以要将其解码为RGB颜色</span></span><br><span class="line">bakedColor = DecodeLightmap(bakedColorTex);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">//间接光漫反射结果</span></span><br><span class="line">half3 indirectDiffuse = skyLight + bakedColor;</span><br></pre></td></tr></table></figure><h2 id="3-2-间接光镜面反射"><a href="#3-2-间接光镜面反射" class="headerlink" title="3.2 间接光镜面反射"></a>3.2 间接光镜面反射</h2><div align=center><img src="image04.png" alt="预过滤的环境贴图在其 5 个 mipmap 级别中存储 5 个不同粗糙度值的预卷积结果" style="zoom:80%;" /></div><p>间接光镜面反射则是根据物体材质的表面粗糙度、遮蔽系数等参数计算物体材质对周围环境内容的反射，即计算物体之间的间接光照效果作为间接光的镜面反射值。通过IBL技术根据当前材质表面的粗糙程度来选择不同的mipmap等级的纹理贴图，以达到随着材质表面粗糙度的增加而反射图案变得越来越模糊的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采样反射探针</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> half3 <span class="title">SamplerReflectProbe</span><span class="params">(UNITY_ARGS_TEXCUBE(tex),half3 refDir,half roughness,half4 hdr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//根据粗糙度选择不同的mipmap等级</span></span><br><span class="line">half MipRoughness = roughness * (<span class="number">1.7</span> - <span class="number">0.7</span> * roughness);</span><br><span class="line">half mip           = MipRoughness * UNITY_SPECCUBE_LOD_STEPS;</span><br><span class="line">half4 rgbm         = UNITY_SAMPLE_TEXCUBE_LOD(tex,refDir,mip);</span><br><span class="line"><span class="comment">//采样的纹素是一个HDR值，需要将其解码得到RGB值</span></span><br><span class="line"><span class="keyword">return</span> DecodeHDR(rgbm,hdr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//间接光镜面反射</span></span><br><span class="line">half3 colorIBL = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//采样反射探针，得到环境光反射贴图</span></span><br><span class="line">half3 colorIBL1 =SamplerReflectProbe</span><br><span class="line">(UNITY_PASS_TEXCUBE(unity_SpecCube0),refDir,PerceptualRoughness,unity_SpecCube0_HDR);;</span><br><span class="line"><span class="comment">//对多个反射探针进行插值</span></span><br><span class="line">UNITY_BRANCH</span><br><span class="line"><span class="keyword">if</span>(unity_SpecCube0_BoxMin.w &lt; <span class="number">0.99999</span>)</span><br><span class="line">&#123;</span><br><span class="line">half3 colorIBL2 =SamplerReflectProbe</span><br><span class="line">(UNITY_PASS_TEXCUBE_SAMPLER(unity_SpecCube1,unity_SpecCube0),refDir,PerceptualRoughness,unity_SpecCube1_HDR);</span><br><span class="line">colorIBL = lerp(colorIBL2,colorIBL1,unity_SpecCube0_BoxMin.w);<span class="comment">//插值平滑过渡</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">colorIBL = colorIBL1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算掠射角时反射率</span></span><br><span class="line">half F90 = saturate((<span class="number">1</span> - Roughness) + (<span class="number">1</span> - (<span class="number">1.0f</span> - Metallic)));</span><br><span class="line"><span class="comment">//间接光镜面反射结果</span></span><br><span class="line">half3 indirectSpecular = colorIBL * ComputeFresnelLerp(SpecularColor, F90, NdotV) * occlusion;</span><br></pre></td></tr></table></figure><h1 id="4-一些细节"><a href="#4-一些细节" class="headerlink" title="4. 一些细节"></a>4. 一些细节</h1><h2 id="4-1-多光源计算"><a href="#4-1-多光源计算" class="headerlink" title="4.1 多光源计算"></a>4.1 多光源计算</h2><p>多光源的计算只要新增一个Pass，在第二个Pass中计算额外的光源即可。由于我们已经在第一个Pass中计算了平行光和间接光照，因此在第二个Pass中我们只要计算会衰减的点光源和聚光灯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他光源</span></span><br><span class="line">half3 lightDir;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USING_DIRECTIONAL_LIGHT  </span></span><br><span class="line">lightDir = normalize(_WorldSpaceLightPos0.xyz);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>  </span></span><br><span class="line">lightDir = normalize(_WorldSpaceLightPos0.xyz - worldPos.xyz);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">UNITY_LIGHT_ATTENUATION(atten, i, worldPos); <span class="comment">//光源衰减</span></span><br><span class="line">……</span><br><span class="line">half3 FinalColorAdd = (directDiffuse + directSpecular) * atten;</span><br></pre></td></tr></table></figure><h2 id="4-2-自发光与雾效"><a href="#4-2-自发光与雾效" class="headerlink" title="4.2 自发光与雾效"></a>4.2 自发光与雾效</h2><p>自发光部分暂不考虑物体自发光对其他物体的影响，因此只需要声明一个自发光变量emission然后在光照结果中加上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">half3 FinalColor = </span><br><span class="line">directDiffuse + directSpecular + indirectDiffuse + indirectSpecular + emission;</span><br></pre></td></tr></table></figure><p>雾效则需指定根据雾的类型展开对应的shader cariant，然后声明片元着色器中用到的雾化坐标并填充，在计算完其他光照结果后再进行雾效的计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> multi_compile_fog    <span class="comment">//该指令依据雾的类型展开对应的shader cariant</span></span></span><br><span class="line">……</span><br><span class="line">UNITY_FOG_COORDS(<span class="number">6</span>)           <span class="comment">//声明本片元用到的雾化坐标</span></span><br><span class="line">UNITY_TRANSFER_FOG(o,o.pos); <span class="comment">//填充雾效所需要的参数</span></span><br><span class="line">……</span><br><span class="line">UNITY_APPLY_FOG(i.fogCoord, FinalColor.rgb);</span><br></pre></td></tr></table></figure><h2 id="4-3-视差贴图"><a href="#4-3-视差贴图" class="headerlink" title="4.3 视差贴图"></a>4.3 视差贴图</h2><p>视差贴图根据储存在纹理中的数据对平面的特定区域的顶点的高度进行位移，视差贴图技术使用视线与物体相交检测的思想。因为视差贴图对uv坐标进行了偏移，因此要将这块内容放在处理其他贴图之前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TtoO0存储切线空间的矩阵</span></span><br><span class="line">o.TtoO0 = float3x3(v.tangent.xyz, objectBinormal, v.normal);</span><br><span class="line">float3 worldPos = float3(i.TtoW0.w,i.TtoW1.w,i.TtoW2.w);<span class="comment">//世界坐标</span></span><br><span class="line">half3 viewDir = normalize(UnityWorldSpaceViewDir(worldPos));<span class="comment">//世界空间下的观察方向</span></span><br><span class="line">half3 objViewDir = normalize(mul(unity_WorldToObject, viewDir)); <span class="comment">//模型空间下的观察方向</span></span><br><span class="line">half3 tanViewDir =normalize( mul(i.TtoO0, objViewDir)); <span class="comment">//切线空间下的观察方向</span></span><br><span class="line">half <span class="built_in">height</span> = tex2D(_ParallaxMap, i.uv).r;                         </span><br><span class="line">i.uv += ParallaxOffset(<span class="built_in">height</span>,_ParallaxStrength,tanViewDir);</span><br></pre></td></tr></table></figure><h2 id="4-4-反射探针的插值"><a href="#4-4-反射探针的插值" class="headerlink" title="4.4 反射探针的插值"></a>4.4 反射探针的插值</h2><p>我们通过IBL对反射探针的纹理进行采样，而当物体在两个反射探针之间移动时则需要对两个反射探针进行插值以达到平滑过渡的效果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对多个反射探针进行插值</span></span><br><span class="line">UNITY_BRANCH</span><br><span class="line"><span class="keyword">if</span>(unity_SpecCube0_BoxMin.w &lt; <span class="number">0.99999</span>)</span><br><span class="line">&#123;</span><br><span class="line">half3 colorIBL2 = SamplerReflectProbe</span><br><span class="line">(UNITY_PASS_TEXCUBE_SAMPLER(unity_SpecCube1,unity_SpecCube0),refDir,PerceptualRoughness,unity_SpecCube1_HDR);</span><br><span class="line">colorIBL = lerp(colorIBL2,colorIBL1,unity_SpecCube0_BoxMin.w);<span class="comment">//插值平滑过渡</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">colorIBL = colorIBL1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-对比验证"><a href="#5-对比验证" class="headerlink" title="5. 对比验证"></a>5. 对比验证</h1><h2 id="5-1-基本对比"><a href="#5-1-基本对比" class="headerlink" title="5.1 基本对比"></a>5.1 基本对比</h2><p><img src="image05.png" alt="基本对比"></p><h2 id="5-2-多光源"><a href="#5-2-多光源" class="headerlink" title="5.2 多光源"></a>5.2 多光源</h2><div align=center><img src="image06.png" alt="多光源" style="zoom:50%;" /></div><h2 id="5-3-雾效"><a href="#5-3-雾效" class="headerlink" title="5.3 雾效"></a>5.3 雾效</h2><p><img src="image07.png" alt="雾效"></p><h2 id="5-4-探针插值"><a href="#5-4-探针插值" class="headerlink" title="5.4 探针插值"></a>5.4 探针插值</h2><p><img src="image08.png" alt="探针插值"></p><h2 id="5-5-视差贴图"><a href="#5-5-视差贴图" class="headerlink" title="5.5 视差贴图"></a>5.5 视差贴图</h2><p><img src="image09.png" alt="视差贴图"></p><h2 id="5-6-综合对比"><a href="#5-6-综合对比" class="headerlink" title="5.6 综合对比"></a>5.6 综合对比</h2><p><img src="image11.png" alt=""></p><p><img src="image10.png" alt=""></p><h1 id="6-Demo制作"><a href="#6-Demo制作" class="headerlink" title="6. Demo制作"></a>6. Demo制作</h1><p>在完成Shader的制作后，在Unity里搭建一个场景来体现实现的PBRShader的一些特性并进行验证。<br>在Unity中利用使用了PBR流程的模型与贴图搭建了一个汽车驾驶的小游戏，同时使用多种光源、反射探针、天空盒、自发光、雾效与烘培好的光照贴图。对场景中的各物件使用自定PBR着色器来验证着色器的正确效果。</p><p><img src="%E6%88%AA%E5%9B%BE.jpg" alt="截图"></p><hr><p>参考：</p><ol><li>《Unity Shader入门精要》</li><li>《Unity3D内江着色器源码剖析》</li><li>The PBR Guide part 1[<a href="https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh]">https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh]</a></li><li>The PBR Guide part 2[<a href="https://academy.substance3d.com/courses/the-pbr-guide-part2-zh]">https://academy.substance3d.com/courses/the-pbr-guide-part2-zh]</a></li><li>LearnOpenGL-PBR-理论[<a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/]">https://learnopengl-cn.github.io/07%20PBR/01%20Theory/]</a></li><li>LearnOpenGL-PBR-光照[<a href="https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/]">https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/]</a></li><li>LearnOpenGL-PBR-IBL-漫反射辐照[<a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/]">https://learnopengl-cn.github.io/07%20PBR/03%20IBL/01%20Diffuse%20irradiance/]</a></li><li>LearnOpenGL-PBR-IBL-镜面IBL[<a href="https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/]">https://learnopengl-cn.github.io/07%20PBR/03%20IBL/02%20Specular%20IBL/]</a></li><li>原核生物都能看懂的PBR-江流[<a href="https://zhuanlan.zhihu.com/p/349854976]">https://zhuanlan.zhihu.com/p/349854976]</a></li><li>草履虫都能看懂的PBR讲解（迫真）-云影[<a href="https://zhuanlan.zhihu.com/p/137013668]">https://zhuanlan.zhihu.com/p/137013668]</a></li><li>猴子都能看懂的PBR-flashyiyi[<a href="https://zhuanlan.zhihu.com/p/33464301]">https://zhuanlan.zhihu.com/p/33464301]</a></li><li>【基于物理的渲染（PBR）白皮书】（一） 开篇：PBR核心知识体系总结与概览-毛星云[<a href="https://zhuanlan.zhihu.com/p/53086060]">https://zhuanlan.zhihu.com/p/53086060]</a></li><li>如何在Unity中造一个PBR Shader轮子-宋开心[<a href="https://zhuanlan.zhihu.com/p/68025039]">https://zhuanlan.zhihu.com/p/68025039]</a></li><li>【学习笔记】Unity PBR的实现-稻草人[<a href="https://zhuanlan.zhihu.com/p/60972473]">https://zhuanlan.zhihu.com/p/60972473]</a></li><li>unity build-in管线中的PBR材质Shader分析研究-郭大钦[<a href="https://blog.csdn.net/qq_23936433/article/details/108507640?utm_source=app]">https://blog.csdn.net/qq_23936433/article/details/108507640?utm_source=app]</a></li><li><a href="https://nicosq.gitee.io/nicosqblog/">https://nicosq.gitee.io/nicosqblog/</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;在对《Unity Shader入门精要》和PBR知识的学习后，对Unity 3D标准着色器Standard的部分源码进行了学习，尝试在Unity中写一个效果与Standard第一个SubShader类似的PBR着色器。</summary>
    
    
    
    <category term="Shader" scheme="http://www.zanple.top/categories/Shader/"/>
    
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
    <category term="Shader" scheme="http://www.zanple.top/tags/Shader/"/>
    
    <category term="Game" scheme="http://www.zanple.top/tags/Game/"/>
    
    <category term="PBR" scheme="http://www.zanple.top/tags/PBR/"/>
    
  </entry>
  
  <entry>
    <title>DirectX11入门笔记-06-纹理贴图</title>
    <link href="http://www.zanple.top/2021/01/18/directx11-06-texture/"/>
    <id>http://www.zanple.top/2021/01/18/directx11-06-texture/</id>
    <published>2021-01-18T13:25:16.000Z</published>
    <updated>2021-03-06T09:54:25.579Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中实现了摄像机与游戏类，但现在游戏中的物体还没有贴图材质。纹理贴图就是这样一种将图像数据映射到网格三角形上的技术，可以使我们为场景增添更多细节，令它更具真实感。一个纹理可以当作<strong>渲染目标</strong>（即Direct3D中的渲染到纹理技术），又能把它作为<strong>着色器资源</strong>（即在着色器中对该纹理进行采样），但是不能同时“身兼数职”。 </p><p>为场景中的物体添加贴图，我们需要引入<em>DDSTextureLoader</em>与<em>WICTextureLoader</em>这两个库，前者用来加载.dds格式的贴图，后者则为通用贴图加载。<a id="more"></a></p><hr><h1 id="1-纹理坐标"><a href="#1-纹理坐标" class="headerlink" title="1. 纹理坐标"></a>1. 纹理坐标</h1><div align=center><img src="1.jpg" alt="纹理坐标系" style="zoom:25%;" /></div><p>Direct3D所采用的纹理坐标系与屏幕或图片的坐标系类似，是由指向图像水平正方向的<strong><em>u</em></strong>轴与指向图像垂直正方向的<strong><em>v</em></strong>轴所组成的。取值范围为<code>0≤u</code>，<code>v≤1</code>的坐标(<em>u</em>,<em>v</em>)标定的是一种称为<strong>纹素</strong>（texel）的纹理元素。分别映射到<code>[0, Width]</code>和<code>[0, Height]</code>。</p><div align=center><img src="2.jpg" alt="左侧的三角形位于3D空间，我们将把右侧纹理上的2D三角形映射到左侧的3D三角形上" style="zoom:67%;" /></div><p>对于每个3D三角形来说，我们希望在将要映射与其上的纹理中定义出与之对应的三角形。设<strong><em>p0</em></strong>、<strong><em>p1</em></strong>以及<strong><em>p2</em></strong>为3D三角形的3个顶点，它们分别对应于纹理坐标<strong><em>q0</em></strong>、<strong><em>q1</em></strong>与<strong><em>q2</em></strong>。则针对3D三角形上的任意一点(<em>x</em>,<em>y</em>,<em>z</em>)处的纹理坐标(<em>u</em>,<em>v</em>)都可以通过与之插值所用的相同参数<em>s</em>、<em>t</em>来对纹理纹理坐标进行线性插值求得。</p><p>这就是说，如果：<br>$$<br>(x, y, z) = \mathbf{p_0} + s(\mathbf{p_1} - \mathbf{p_0}) + t(\mathbf{p_2} - \mathbf{p_0})<br>$$<br>当<em>s</em>≥0，<em>t</em>≥0，<em>s</em>+<em>t</em>≤1时，那么：<br>$$<br>(u, v) = \mathbf{q_0} + s(\mathbf{q_1} - \mathbf{q_0}) + t(\mathbf{q_2} - \mathbf{q_0})<br>$$<br>依次方法便可求出三角形上每个点处对应的纹理坐标。</p><p>为了实现此计算需要对顶点结构体进行修改：</p><blockquote><p>将HLSL头文件的结构体中的Color改为Tex</p><p>顶点着色器中同理，将Color改为Tex</p><p>将pIn.Color.a改为texColor.a</p></blockquote><p>在GameApp的游戏对象类中添加纹理设置函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTexture</span><span class="params">(ID3D11ShaderResourceView* texture)</span></span>;</span><br><span class="line"><span class="keyword">void</span> GameApp::GameObject::SetTexture(ID3D11ShaderResourceView* texture)</span><br><span class="line">&#123;</span><br><span class="line">m_pTexture = texture;</span><br><span class="line">&#125;</span><br><span class="line">ComPtr&lt;ID3D11ShaderResourceView&gt; m_pTexture;</span><br></pre></td></tr></table></figure><h1 id="2-纹理数据源"><a href="#2-纹理数据源" class="headerlink" title="2. 纹理数据源"></a>2. 纹理数据源</h1><p>对于实时图形应用程序来说，DDS图像文件格式是一种尚佳的选择。</p><blockquote><p>为了缓解场景中纹理数量增加带来内存需求压力，Direct3D支持下列几种压缩格式（也称为块压缩）：</p><ol><li><strong>BC1</strong>(DXGI_FORMAT_BC1_UNORM)：如果我们需要将图片压缩为支持3个颜色通道和仅有1位（开/关）alpha分量的格式，则使用此格式。</li><li><strong>BC2</strong>(DXGI_FORMAT_BC2_UNORM)：如果我们需要将图片压缩为支持3个颜色通道和仅有4位alpha分量的格式，则应用此格式。</li><li><strong>BC3</strong>(DXGI_FORMAT_BC3_UNORM)：如果我们需要将图片压缩为支持3个颜色通道和仅有8位alpha分量的格式，则应用此格式。</li><li><strong>BC4</strong>(DXGI_FORMAT_BC4_UNORM)：如果我们需要将图片压缩为仅含有1个颜色通道的格式（如灰度图像），则应用此格式。</li><li><strong>BC5</strong>(DXGI_FORMAT_BC5_UNORM)：如果我们需要将图片压缩为只支持2个颜色通道的格式，则应用此格式。</li><li><strong>BC6</strong>(DXGI_FORMAT_BC6_UF16)：如果我们需要将图片压缩为HDR图像数据，则应用此格式。</li><li><strong>BC7</strong>(DXGI_FORMAT_BC7_UNORM)：此格式用于对RGBA数据进行高质量的压缩。特别是，<strong>此格式可极大地减少因压缩法线图而造成的误差。</strong></li></ol></blockquote><p>这些格式的优点是可以使图像以压缩的形式存于显存之中，而在需要时，GPU便能动态地对它们进行解压。</p><h1 id="3-采样器"><a href="#3-采样器" class="headerlink" title="3. 采样器"></a>3. 采样器</h1><p>在运用纹理的过程中，除了纹理数据本身以外，还有另外两个相关的重要概念，即纹理过滤以及寻址模式。采集纹理资源时所用的过滤器和寻址模式都是通过采样器对象来定义的。</p><p>添加采样器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float4 texColor = g_Tex.Sample(g_SamLinear, pIn.Tex);</span><br><span class="line">ComPtr&lt;ID3D11SamplerState&gt; m_pSampler;    <span class="comment">// 采样器状态</span></span><br></pre></td></tr></table></figure><h2 id="3-1-过滤器"><a href="#3-1-过滤器" class="headerlink" title="3.1 过滤器"></a>3.1 过滤器</h2><p>当触发纹理放大操作时，我们便需要对纹素之间的颜色数据进行插值估算，从而获得指定纹素处的颜色信息。图形硬件往往会支持<strong>常量插值</strong>与<strong>线性插值</strong>两种插值方法。在实践中，线性插值的使用更为普遍。</p><div align=center><p><img src="3.jpg" alt="常量插值与线性插值"></p></div><p>图a中，若给出了纹素点，我们便可以通过构建分段常量函数来求出纹素点之间某处的近似值。由于得到的近似值为最近纹素点的取值，所以这种方法有时被称为最近邻点采样。图b中，若给出了纹素点，我们便可以通过构建分段线性函数来求出纹素点之间某处的近似值。</p><div align=center><img src="4.jpg" alt="双线性插值" style="zoom:33%;" /></div><p>此外还有双线性插值，其处理流程如上图所示：给出四个纹素之间的一个纹理坐标，先在水平方向<strong><em>u</em></strong>上进行两次1D线性插值（求出<strong><em>cT</em></strong>与<strong><em>cB</em></strong>），然后在垂直方向<strong><em>v</em></strong>上在进行一次1D内插（求出<strong><em>c</em></strong>）。</p><p>通过常量插值来求得纹素之间纹理坐标处的纹理数据也称为<strong>点过滤</strong>，对应的通过线性插值的方法称为<strong>线性过滤</strong>。</p><h2 id="3-2-寻址模式"><a href="#3-2-寻址模式" class="headerlink" title="3.2 寻址模式"></a>3.2 寻址模式</h2><p>Direct3D允许我们采用下列4中不同的寻址模式（Address Mode）来扩充此函数的定义域。分别是<strong>重复寻址模式</strong>（wrap）、<strong>边框颜色寻址模式</strong>（border color）、<strong>钳位寻址模式</strong>（clamp）与<strong>镜像寻址模式</strong>（mirror）。</p><h3 id="3-2-1-重复寻址模式"><a href="#3-2-1-重复寻址模式" class="headerlink" title="3.2.1 重复寻址模式"></a>3.2.1 重复寻址模式</h3><div align=center><img src="5.jpg" alt="重复寻址模式" style="zoom:50%;" /></div><p>重复寻址模式通过在坐标的每个整数点处重复绘制图像来扩充纹理函数。</p><h3 id="3-2-2-边框颜色寻址模式"><a href="#3-2-2-边框颜色寻址模式" class="headerlink" title="3.2.2 边框颜色寻址模式"></a>3.2.2 边框颜色寻址模式</h3><div align=center><img src="6.jpg" alt="边框颜色寻址模式" style="zoom:50%;" /></div><p>边框颜色寻址模式通过将每个不在范围[0,1]^2内的坐标(<em>u</em>,<em>v</em>)都映射为指定的颜色而扩充纹理函数。</p><h3 id="3-2-3-钳位寻址模式"><a href="#3-2-3-钳位寻址模式" class="headerlink" title="3.2.3 钳位寻址模式"></a>3.2.3 钳位寻址模式</h3><div align=center><img src="7.jpg" alt="钳位寻址模式" style="zoom:50%;" /></div><p>钳位寻址模式通过将范围[0,1]^2外的每个坐标(<em>u</em>,<em>v</em>)都映射为颜色<strong><em>T</em></strong>(<em>u0</em>,<em>v0</em>)来扩充纹理函数。其中(<em>u0</em>,<em>v0</em>)为范围[0,1]^2内距离(<em>u</em>,<em>v</em>)最近的点。</p><h3 id="3-2-4-镜像寻址模式"><a href="#3-2-4-镜像寻址模式" class="headerlink" title="3.2.4 镜像寻址模式"></a>3.2.4 镜像寻址模式</h3><div align=center><img src="8.jpg" alt="镜像寻址模式" style="zoom:50%;" /></div><p>镜像寻址模式通过在坐标的每个整数点处绘制图像的镜像来扩充纹理函数。</p><h2 id="3-3-采样器对象"><a href="#3-3-采样器对象" class="headerlink" title="3.3 采样器对象"></a>3.3 采样器对象</h2><p>采样器会被着色器使用，为了将采样器绑定到着色器上供其使用，我们就需要为采样器对象绑定描述符。更改顶点布局类型为<code>VertexPosNormalTex</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化游戏对象</span></span><br><span class="line">ComPtr&lt;ID3D11ShaderResourceView&gt; texture;</span><br><span class="line"><span class="comment">//初始化木箱</span></span><br><span class="line">CreateDDSTextureFromFile(m_pDevice.Get(), <span class="string">L"Texture\\WoodCrate.dds"</span>, <span class="literal">nullptr</span>, texture.GetAddressOf());</span><br><span class="line">m_WoodCrate.SetBuffer(m_pDevice.Get(), Geometry::CreateBox());</span><br><span class="line">m_WoodCrate.SetTexture(texture.Get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化地板</span></span><br><span class="line">CreateDDSTextureFromFile(m_pDevice.Get(), <span class="string">L"Texture\\floor.dds"</span>, <span class="literal">nullptr</span>, texture.ReleaseAndGetAddressOf());</span><br><span class="line">m_Floor.SetBuffer(m_pDevice.Get(),</span><br><span class="line">Geometry::CreatePlane(XMFLOAT2(<span class="number">20.0f</span>, <span class="number">20.0f</span>), XMFLOAT2(<span class="number">5.0f</span>, <span class="number">5.0f</span>)));</span><br><span class="line">m_Floor.SetTexture(texture.Get());</span><br><span class="line">m_Floor.GetTransform().SetPosition(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化采样器状态</span></span><br><span class="line">D3D11_SAMPLER_DESC sampDesc;</span><br><span class="line">ZeroMemory(&amp;sampDesc, <span class="keyword">sizeof</span>(sampDesc));</span><br><span class="line">sampDesc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;</span><br><span class="line">sampDesc.AddressU = D3D11_TEXTURE_ADDRESS_WRAP;</span><br><span class="line">sampDesc.AddressV = D3D11_TEXTURE_ADDRESS_WRAP;</span><br><span class="line">sampDesc.AddressW = D3D11_TEXTURE_ADDRESS_WRAP;</span><br><span class="line">sampDesc.ComparisonFunc = D3D11_COMPARISON_NEVER;</span><br><span class="line">sampDesc.MinLOD = <span class="number">0</span>;</span><br><span class="line">sampDesc.MaxLOD = D3D11_FLOAT32_MAX;</span><br><span class="line">m_pDevice-&gt;CreateSamplerState(&amp;sampDesc, m_pSampler.GetAddressOf());</span><br></pre></td></tr></table></figure><p>绑定缓冲区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_pContext-&gt;PSSetSamplers(0, 1, m_pSampler.GetAddressOf());</span><br></pre></td></tr></table></figure><p>在Draw函数中设置纹理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置纹理</span><br><span class="line">deviceContext-&gt;PSSetShaderResources(0, 1, m_pTexture.GetAddressOf());</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>1.《DirectX 12 3D游戏开发实战 第7章》</p><p>2.<a href="https://www.cnblogs.com/X-Jun/p/9297810.html">DirectX11 With Windows SDK–09 纹理映射与采样器状态</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中实现了摄像机与游戏类，但现在游戏中的物体还没有贴图材质。纹理贴图就是这样一种将图像数据映射到网格三角形上的技术，可以使我们为场景增添更多细节，令它更具真实感。一个纹理可以当作&lt;strong&gt;渲染目标&lt;/strong&gt;（即Direct3D中的渲染到纹理技术），又能把它作为&lt;strong&gt;着色器资源&lt;/strong&gt;（即在着色器中对该纹理进行采样），但是不能同时“身兼数职”。 &lt;/p&gt;
&lt;p&gt;为场景中的物体添加贴图，我们需要引入&lt;em&gt;DDSTextureLoader&lt;/em&gt;与&lt;em&gt;WICTextureLoader&lt;/em&gt;这两个库，前者用来加载.dds格式的贴图，后者则为通用贴图加载。</summary>
    
    
    
    <category term="Direct3D" scheme="http://www.zanple.top/categories/Direct3D/"/>
    
    
    <category term="C++" scheme="http://www.zanple.top/tags/C/"/>
    
    <category term="Direct3D" scheme="http://www.zanple.top/tags/Direct3D/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>DirectX11入门笔记-05-摄像机类与游戏对象类</title>
    <link href="http://www.zanple.top/2021/01/09/directx11-05-camera/"/>
    <id>http://www.zanple.top/2021/01/09/directx11-05-camera/</id>
    <published>2021-01-09T06:17:25.000Z</published>
    <updated>2021-03-06T09:53:35.093Z</updated>
    
    <content type="html"><![CDATA[<p>这一节中将实现第一人称摄像机与第三人称摄像机建立Camera类，同时将摄像机的空间与游戏对象中涉及到的位移，建立Transform类。随着场景中的物体不断增加，为了尽可能方便地去管理每一个物体实现了GameObject类。<a id="more"></a></p><hr><h1 id="1-Transform类"><a href="#1-Transform类" class="headerlink" title="1. Transform类"></a>1. Transform类</h1><h2 id="1-1-观察空间变换"><a href="#1-1-观察空间变换" class="headerlink" title="1.1 观察空间变换"></a>1.1 观察空间变换</h2><div align=center><img src="Fig15-1.jpg" alt="摄像机坐标系。摄像机在自己专属的坐标系中，位于坐标系原点并沿着z轴正方向观察" style="zoom:33%;" /></div><p>如上图所示，<strong>观察空间</strong>附属于摄像机的坐标系。在此空间中，摄像机位于坐标系的原点并沿着z轴正方向观察，x轴指向摄像机右侧，y轴指向摄像机的正上方。从世界空间至观察空间的坐标变换称为观察变换，对应的矩阵称为<strong>观察矩阵</strong>。</p><p>如果<strong><em>Q</em></strong>=(Qx,Qy,Qz,1)、<strong><em>u</em></strong>=(ux,uy,uz,0)、<strong><em>v</em></strong>=(vx,vy,vz,0)且<strong><em>w</em></strong>=(wx,wy,wz,0)分别表示观察空间中的原点、<strong><em>x</em></strong>轴、<strong><em>y</em></strong>轴与<strong><em>z</em></strong>轴相对于世界空间的齐次坐标，并且物体的xyz缩放比例都为1，则<strong>从观察空间至世界空间</strong>的坐标比变换矩阵为：<br>$$<br>W=\left[\begin{array}{llll}<br>u_{x} &amp; u_{y} &amp; u_{z} &amp; 0 \<br>v_{x} &amp; v_{y} &amp; v_{z} &amp; 0 \<br>w_{x} &amp; w_{y} &amp; w_{z} &amp; 0 \<br>Q_{x} &amp; Q_{y} &amp; Q_{z} &amp; 1<br>\end{array}\right]<br>$$<br>然而现在我们需要做的是从世界坐标系转换到观察空间坐标系，如果把摄像机看做物体的话，实际上观察空间坐标系就是摄像机物体的局部坐标系(右方向为X轴，上方向为Y轴，目视方向为Z轴）。因此我们可利用<strong><em>W</em></strong>的逆矩阵将坐标<strong>从世界空间变换到观察空间</strong>，则<strong>观察矩阵</strong>为：<br>$$<br>V=\left[\begin{array}{cccc}<br>u_{x} &amp; v_{x} &amp; w_{x} &amp; 0 \<br>u_{y} &amp; v_{y} &amp; w_{y} &amp; 0 \<br>u_{z} &amp; v_{z} &amp; w_{z} &amp; 0 \<br>-Q \cdot u &amp; -Q \cdot v &amp; -Q \cdot w &amp; 1<br>\end{array}\right]<br>$$</p><h2 id="1-2-世界变换的复合"><a href="#1-2-世界变换的复合" class="headerlink" title="1.2 世界变换的复合"></a>1.2 <a href="https://www.cnblogs.com/X-Jun/p/9316048.html">世界变换的复合</a></h2><p>假设在初始化阶段，物体经历了初始旋转变换和平移变换，则此时的变换矩阵为<br>$$<br>\mathbf{W_{0}=R_{0} T_{0}}<br>$$<br>若每一帧都产生缩放、旋转和位移，把当前帧的缩放、旋转和位移矩阵分别记为<strong><em>Sn</em></strong>、<strong><em>Rn</em></strong>和<strong><em>Tn</em></strong>，有的人会认为当前帧的世界变换为：<br>$$<br>\mathbf{W_{n}=W_{n-1}S_{n}R_{n}T_{n}}<br>$$<br>然而这种复合变换可能会导致异常的变换，在前面的变换一章我们就举了一个例子。归根结底在于矩阵乘法不满足交换律，<strong>且缩放操作如果不先进行（前面还有旋转或平移）的话会导致物体产生畸变。</strong>所以要先让缩放进行：<br>$$<br>\mathbf{W_{n}=S_{0}S_{1}…S_{n}…}<br>$$<br>此时旋转和平移操作就可以自行指定顺序了。如果先平移再旋转，离开原点的物体会绕原点旋转。如果先旋转再平移，就是先改变物体的朝向再放到指定的位置上。</p><p>通常对物体修改旋转是基于原点位置的旋转，因此它的世界变换复合为：<br>$$<br>\mathbf{W_{n}=S_{0}S_{1}…S_{n}R_{0}R_{1}…R_{n}T_{0}T_{1}…T_{n}}<br>$$<br>而如果涉及到具有父子关系物体的世界变换，则会更复杂一些。以Unity的为例，设父级物体的缩放矩阵、旋转矩阵和位移矩阵分别为<strong><em>S0</em></strong>、<strong><em>R0</em></strong>和<strong><em>T0</em></strong>，子一级物体的缩放矩阵、旋转矩阵和位移矩阵为<strong><em>S1</em></strong>、<strong><em>R1</em></strong>和<strong><em>T1</em></strong>。那么子N级物体的世界变换复合为：<br>$$<br>\mathbf{W_{n}=S_{0}S_{1}…S_{n}R_{n}T_{n}R_{n-1}T_{n-1}…R_{0}T_{0}}<br>$$</p><h2 id="1-3-Transform类的实现"><a href="#1-3-Transform类的实现" class="headerlink" title="1.3 Transform类的实现"></a>1.3 Transform类的实现</h2><p>根据上面的复合形式，我们可以将<code>缩放</code>、<code>旋转</code>和<code>平移</code>部分拆开来分别更新，其中缩放和平移部分都可以使用一个向量来保存，然后缩放矩阵的连乘相当于缩放向量的分量乘法，平移矩阵的连乘相当于平移向量的分量加法。</p><p>至于旋转矩阵的表示形式有三种：<code>旋转四元数</code>、<code>基于特定的坐标轴顺序进行旋转的三个旋转欧拉角</code>、<code>三个相互正交的坐标轴向量</code>。这三种表示形式是可以相互转换的。由于到目前旋转四元数还没涉及，因此等学到四元数之后就可以用它替换欧拉角存储了。</p><p>在DirectXMath中，存在这样一系列旋转矩阵构造函数，采用的是Roll-Pitch-Yaw的旋转形式，实际上说的就是先绕Z轴旋转，再绕X轴旋转，最后再绕Y轴旋转。选择这样的旋转顺序，首先考虑到的是要最大限度避免万向节死锁的出现，而物体+Z轴竖直朝上或朝下的情况都是非常少见的。</p><p>Transform类的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transform</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Transform() = <span class="keyword">default</span>;</span><br><span class="line">Transform(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; scale, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; rotation, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; <span class="built_in">position</span>);</span><br><span class="line">~Transform() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Transform(<span class="keyword">const</span> Transform&amp;) = <span class="keyword">default</span>;</span><br><span class="line">Transform&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Transform&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">Transform(Transform&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">Transform&amp; <span class="keyword">operator</span>=(Transform&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象欧拉角</span></span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetRotation</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMVECTOR <span class="title">GetRotationXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象位置</span></span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMVECTOR <span class="title">GetPositionXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取基向量</span></span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetRightAxis</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMVECTOR <span class="title">GetRightAxisXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetUpAxis</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMVECTOR <span class="title">GetUpAxisXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetForwardAxis</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMVECTOR <span class="title">GetForwardAxisXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取世界变换矩阵及逆世界变换矩阵</span></span><br><span class="line"><span class="function">DirectX::XMMATRIX <span class="title">GetLocalToWorldMatrixXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMMATRIX <span class="title">GetWorldToLocalMatrixXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置对象欧拉角</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRotation</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; eulerAnglesInRadian)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRotation</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置对象位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPosition</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; <span class="built_in">position</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPosition</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span>;</span><br><span class="line"><span class="comment">//旋转位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotatePos</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; <span class="built_in">point</span>, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; axis, <span class="keyword">float</span> delta)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//沿着某一方向平移</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Translate</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; direction, <span class="keyword">float</span> magnitude)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察某一点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LookAt</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; target, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; up = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;)</span></span>;</span><br><span class="line"><span class="comment">//沿着某一方向观察</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LookTo</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; direction, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; up = &#123; <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span> &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">//从旋转矩阵获取旋转欧拉角</span></span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetEulerAnglesFromRotationMatrix</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT4X4&amp; rotationMatrix)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">DirectX::XMFLOAT3 m_Scale = &#123; <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span> &#125;;<span class="comment">//缩放</span></span><br><span class="line">DirectX::XMFLOAT3 m_Rotation = &#123;&#125;;<span class="comment">//旋转欧拉角</span></span><br><span class="line">DirectX::XMFLOAT3 m_Position = &#123;&#125;;<span class="comment">//位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>部分实现为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::RotatePos</span><span class="params">(<span class="keyword">const</span> XMFLOAT3&amp; <span class="built_in">point</span>, <span class="keyword">const</span> XMFLOAT3&amp; axis, <span class="keyword">float</span> delta)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">XMVECTOR rotationVec = XMLoadFloat3(&amp;m_Rotation);</span><br><span class="line">XMVECTOR positionVec = XMLoadFloat3(&amp;m_Position);</span><br><span class="line">XMVECTOR centerVec = XMLoadFloat3(&amp;<span class="built_in">point</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以point作为原点进行旋转</span></span><br><span class="line"><span class="comment">//根据已有的数据将算出旋转平移矩阵</span></span><br><span class="line">XMMATRIX RT = XMMatrixRotationRollPitchYawFromVector(rotationVec) * XMMatrixTranslationFromVector(positionVec);</span><br><span class="line"><span class="comment">//将旋转中心平移到原点</span></span><br><span class="line">RT *= XMMatrixTranslationFromVector(-centerVec);</span><br><span class="line"><span class="comment">//旋转轴</span></span><br><span class="line">RT *= XMMatrixRotationAxis(XMLoadFloat3(&amp;axis), delta);</span><br><span class="line"><span class="comment">//旋转完成后平移回原来位置</span></span><br><span class="line">RT *= XMMatrixTranslationFromVector(centerVec);</span><br><span class="line">XMStoreFloat3(&amp;m_Position, RT.r[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::Translate</span><span class="params">(<span class="keyword">const</span> XMFLOAT3&amp; direction, <span class="keyword">float</span> magnitude)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">XMVECTOR directionVec = XMVector3Normalize(XMLoadFloat3(&amp;direction));</span><br><span class="line">XMVECTOR newPosition = XMVectorMultiplyAdd(XMVectorReplicate(magnitude), directionVec, XMLoadFloat3(&amp;m_Position));</span><br><span class="line">XMStoreFloat3(&amp;m_Position, newPosition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::LookAt</span><span class="params">(<span class="keyword">const</span> XMFLOAT3&amp; target, <span class="keyword">const</span> XMFLOAT3&amp; up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">XMMATRIX View = XMMatrixLookAtLH(XMLoadFloat3(&amp;m_Position), XMLoadFloat3(&amp;target), XMLoadFloat3(&amp;up));</span><br><span class="line">XMMATRIX InvView = XMMatrixInverse(<span class="literal">nullptr</span>, View);</span><br><span class="line">XMFLOAT4X4 rotMatrix;</span><br><span class="line">XMStoreFloat4x4(&amp;rotMatrix, InvView);</span><br><span class="line">m_Rotation = GetEulerAnglesFromRotationMatrix(rotMatrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::LookTo</span><span class="params">(<span class="keyword">const</span> XMFLOAT3&amp; direction, <span class="keyword">const</span> XMFLOAT3&amp; up)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">XMMATRIX View = XMMatrixLookToLH(XMLoadFloat3(&amp;m_Position), XMLoadFloat3(&amp;direction), XMLoadFloat3(&amp;up));</span><br><span class="line">XMMATRIX InvView = XMMatrixInverse(<span class="literal">nullptr</span>, View);</span><br><span class="line">XMFLOAT4X4 rotMatrix;</span><br><span class="line">XMStoreFloat4x4(&amp;rotMatrix, InvView);</span><br><span class="line">m_Rotation = GetEulerAnglesFromRotationMatrix(rotMatrix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">XMFLOAT3 <span class="title">Transform::GetEulerAnglesFromRotationMatrix</span><span class="params">(<span class="keyword">const</span> XMFLOAT4X4&amp; rotationMatrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//通过旋转矩阵反求欧拉角</span></span><br><span class="line"><span class="keyword">float</span> c = sqrtf(<span class="number">1.0f</span> - rotationMatrix(<span class="number">2</span>, <span class="number">1</span>) * rotationMatrix(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line"><span class="comment">//防止r[2][1]出现大于1的情况</span></span><br><span class="line"><span class="keyword">if</span> (isnan(c))</span><br><span class="line">c = <span class="number">0.0f</span>;</span><br><span class="line">XMFLOAT3 rotation;</span><br><span class="line">rotation.z = atan2f(rotationMatrix(<span class="number">0</span>, <span class="number">1</span>), rotationMatrix(<span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">rotation.x = atan2f(-rotationMatrix(<span class="number">2</span>, <span class="number">1</span>), c);</span><br><span class="line">rotation.y = atan2f(rotationMatrix(<span class="number">2</span>, <span class="number">0</span>), rotationMatrix(<span class="number">2</span>, <span class="number">2</span>));</span><br><span class="line"><span class="keyword">return</span> rotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-摄像机类"><a href="#2-摄像机类" class="headerlink" title="2. 摄像机类"></a>2. 摄像机类</h1><p>摄像机类基于Transform实现 ，定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camera</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Camera() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">virtual</span> ~Camera() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取摄像机位置</span></span><br><span class="line"><span class="function">DirectX::XMVECTOR <span class="title">GetPositionXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取矩阵</span></span><br><span class="line"><span class="function">DirectX::XMMATRIX <span class="title">GetViewXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMMATRIX <span class="title">GetProjXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function">DirectX::XMMATRIX <span class="title">GetViewProjXM</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取视口</span></span><br><span class="line"><span class="function">D3D11_VIEWPORT <span class="title">GetViewPort</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置视锥体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetFrustum</span><span class="params">(<span class="keyword">float</span> fovY, <span class="keyword">float</span> aspect, <span class="keyword">float</span> nearZ, <span class="keyword">float</span> farZ)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置视口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetViewPort</span><span class="params">(<span class="keyword">const</span> D3D11_VIEWPORT&amp; viewPort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetViewPort</span><span class="params">(<span class="keyword">float</span> topLeftX, <span class="keyword">float</span> topLeftY, <span class="keyword">float</span> <span class="built_in">width</span>, <span class="keyword">float</span> <span class="built_in">height</span>, <span class="keyword">float</span> minDepth = <span class="number">0.0f</span>, <span class="keyword">float</span> maxDepth = <span class="number">1.0f</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">Transform m_Transform = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//视锥体属性</span></span><br><span class="line"><span class="keyword">float</span> m_NearZ = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> m_FarZ = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> m_Aspect = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> m_FovY = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前视口</span></span><br><span class="line">D3D11_VIEWPORT m_ViewPort = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-1-第一人称摄像机"><a href="#2-1-第一人称摄像机" class="headerlink" title="2.1 第一人称摄像机"></a>2.1 第一人称摄像机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstPersonCamera</span> :</span> <span class="keyword">public</span> Camera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FirstPersonCamera() = <span class="keyword">default</span>;</span><br><span class="line">~FirstPersonCamera() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置摄像机位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPosition</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, <span class="keyword">float</span> z)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetPosition</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置摄像机的朝向</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LookAt</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; pos, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; target, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; up)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LookTo</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; pos, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; to, <span class="keyword">const</span> DirectX::XMFLOAT3&amp; up)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将相机进行旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pitch</span><span class="params">(<span class="keyword">float</span> rad)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotateY</span><span class="params">(<span class="keyword">float</span> rad)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="2-2-第三人称摄像机"><a href="#2-2-第三人称摄像机" class="headerlink" title="2.2 第三人称摄像机"></a>2.2 第三人称摄像机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirdPersonCamera</span> :</span> <span class="keyword">public</span> Camera</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">ThirdPersonCamera() = <span class="keyword">default</span>;</span><br><span class="line">~ThirdPersonCamera() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前跟踪目标位置与距离</span></span><br><span class="line"><span class="function">DirectX::XMFLOAT3 <span class="title">GetTargetPosition</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">GetDistance</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//拉近物体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Approach</span><span class="params">(<span class="keyword">float</span> dist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绕目标旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotateX</span><span class="params">(<span class="keyword">float</span> rad)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RotateY</span><span class="params">(<span class="keyword">float</span> rad)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRotationX</span><span class="params">(<span class="keyword">float</span> rad)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRotationY</span><span class="params">(<span class="keyword">float</span> rad)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置跟踪目标的位置与距离</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetTarget</span><span class="params">(<span class="keyword">const</span> DirectX::XMFLOAT3&amp; target)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetDistance</span><span class="params">(<span class="keyword">float</span> dist)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetDistanceMinMax</span><span class="params">(<span class="keyword">float</span> minDist, <span class="keyword">float</span> maxDist)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">DirectX::XMFLOAT3 m_Target = &#123;&#125;;</span><br><span class="line"><span class="keyword">float</span> m_Distance = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">//最小允许距离与最大允许距离</span></span><br><span class="line"><span class="keyword">float</span> m_MinDist = <span class="number">0.0f</span>, m_MaxDist = <span class="number">0.0f</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="3-游戏对象类"><a href="#3-游戏对象类" class="headerlink" title="3. 游戏对象类"></a>3. 游戏对象类</h1><p>在上文中我们将几个不同的变换矩阵都放到了同一个常量缓冲区中，但其实并不是每个矩阵都会每帧进行更新。因此这里将不同矩阵放到不同的常量缓冲区中。每个物体的worldMatrix都会不一样，所以每绘制一个物体都要刷新一遍，而摄像机的viewMatrix只要每帧刷新一遍即可，projMatrix则根据屏幕的大小有没有改变来刷新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBChangesEveryDrawing</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMMATRIX world;</span><br><span class="line">DirectX::XMMATRIX worldInvTranspose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBChangesEveryFrame</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMMATRIX view;</span><br><span class="line">DirectX::XMFLOAT4 eyePos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBChangesOnResize</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMMATRIX proj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CBChangesRarely</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectionalLight dirLight;</span><br><span class="line">Material material;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>将创建顶点缓冲区与索引缓冲区的操作封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">IndexType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">GameApp</span>:</span>:GameObject::SetBuffer(ID3D11Device* device, <span class="keyword">const</span> Geometry::MeshData&lt;VertexType, IndexType&gt;&amp; meshData)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//……主要是创建顶点缓冲区描述、顶点缓冲区；索引缓冲区描述、索引缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将绘制索引的操作封装：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GameApp::GameObject::Draw(ID3D11DeviceContext* deviceContext)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//……更新经常被更改的常量缓冲区部分，更改较少的更新则留在InitResource中，InitResource为初始化资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>参考：</p><p>1.《DirectX 12 3D游戏开发实战 第7章》</p><p>2.<a href="https://www.cnblogs.com/X-Jun/p/9316048.html">DirectX11 With Windows SDK–10 基于Transform的摄像机类与GameObject类</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这一节中将实现第一人称摄像机与第三人称摄像机建立Camera类，同时将摄像机的空间与游戏对象中涉及到的位移，建立Transform类。随着场景中的物体不断增加，为了尽可能方便地去管理每一个物体实现了GameObject类。</summary>
    
    
    
    <category term="Direct3D" scheme="http://www.zanple.top/categories/Direct3D/"/>
    
    
    <category term="C++" scheme="http://www.zanple.top/tags/C/"/>
    
    <category term="Direct3D" scheme="http://www.zanple.top/tags/Direct3D/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>DirectX11入门笔记-04-光照与光栅化</title>
    <link href="http://www.zanple.top/2021/01/07/directx11-04-light/"/>
    <id>http://www.zanple.top/2021/01/07/directx11-04-light/</id>
    <published>2021-01-07T07:15:25.000Z</published>
    <updated>2021-03-06T09:53:11.637Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中，我们绘制出了各种几何体。但这些几何体的所有面都是相同的颜色，看起来像是一个2D平面。<a id="more"></a></p><div align=center><p><img src="image-1.png" alt=""></p></div><p>这是因为我们视觉上对世界的感知依靠的是光照及其与材质的交互，因此首先要解决的就是遵循自然规律实现精确的光照模型。</p><div align=center><img src="image-2.png" alt="" style="zoom: 50%;" /></div><p>在开启光照的同时，我们不再直接指定顶点的颜色，而是指定材质与光照，再运用光照方程基于两者的交互来计算顶点颜色。这样做会使物体的颜色更趋于真实。</p><hr><h1 id="1-光照"><a href="#1-光照" class="headerlink" title="1. 光照"></a>1. 光照</h1><h2 id="1-1-法向量"><a href="#1-1-法向量" class="headerlink" title="1.1 法向量"></a>1.1 法向量</h2><p>我们把对每个像素逐一进行法线插值并执行光照计算的方法称为<strong>逐像素光照</strong>或<strong>phong光照模型</strong>。而之前对每个顶点逐一进行光照计算的则为<strong>逐顶点光照</strong>，开销虽低但精度也低。这里将通过顶点着色器输出每个顶点光照的计算结果，再到像素着色器中对三角形中的像素进行插值。</p><blockquote><p>将运算作业从像素着色器移至顶点着色器是一种常见的性能优化手段。</p></blockquote><h3 id="1-1-1-计算法向量"><a href="#1-1-1-计算法向量" class="headerlink" title="1.1.1 计算法向量"></a>1.1.1 计算法向量</h3><p>三角形网络运用一种被称为求顶点法线平均值的计算方法。此方法通过对网格中共享顶点<strong>v</strong>的多边形的平面法线求平均值，从而获得网格中任意顶点v处的顶点法线<strong>n</strong>。</p><div align=center><img src="image-3.png" alt="顶点法线" style="zoom:33%;" /></div><p>对于上图网格中的四个多边形共用顶点<strong>v</strong>，因此，<strong>v</strong>处的顶点法线为：<br>$$<br>\mathbf{n}<em>{\text {avg }}=\frac{\mathbf{n}</em>{0}+\mathbf{n}<em>{1}+\mathbf{n}</em>{2}+\mathbf{n}<em>{3}}{\left|\mathbf{n}</em>{0}+\mathbf{n}<em>{1}+\mathbf{n}</em>{2}+\mathbf{n}_{3}\right|}<br>$$<br>但对于棱角分明的物体，如立方体，一共由12个三角形组成，2个三角形的4个顶点构成一个面。由于该面的4个顶点要求法向量朝向一致，而一个顶点虽然与立方体的三个面邻接，但是法向量只有一个，因此需要分化出3个包含不同法向量的顶点。</p><h3 id="1-1-2-法向量的变换"><a href="#1-1-2-法向量的变换" class="headerlink" title="1.1.2 法向量的变换"></a>1.1.2 法向量的变换</h3><p>在游戏中，模型的顶点携带的信息中，法线就是其中一种。我们变换一个模型，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理（如片元着色器）中计算光照等。</p><p>但在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性。</p><div align=center><p><img src="image-4.png" alt="进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直"></p></div><p>因此，在法线的变换过程中，我们使用原变换矩阵的<code>逆转置矩阵</code>来变换法线就可以得到正确的结果。</p><blockquote><p>尽管运用了逆转置变换，但法向量仍可能会失去其单位长度。所以在变换完成后，可能需要对它再次进行规范化处理。</p></blockquote><p>因为逆矩阵的计算比较麻烦，所以我们可以根据变换类型尽可能的避免逆矩阵的计算过程：</p><ul><li>变换只包括旋转变换，那么这个变换矩阵就是正交矩阵（正交矩阵的转置矩阵与逆矩阵相同）；</li><li>变换只包括旋转和统一缩放，则可以利用统一缩放指数<em>k</em>来得到变换矩阵的逆转置矩阵；</li><li>变换包括了非统一变换，则必须求解<strong>逆转置矩阵</strong>。</li></ul><p>我们在头文件<code>MathHelper.h</code>中为计算逆转置矩阵实现了一个辅助函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> DirectX::XMMATRIX XM_CALLCONV <span class="title">InverseTranspose</span><span class="params">(DirectX::FXMMATRIX M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"></span><br><span class="line"><span class="comment">//针对法向量的逆转置</span></span><br><span class="line">XMMATRIX A = M;</span><br><span class="line"><span class="comment">//将向量变换矩阵中与平移操作有关的项清零</span></span><br><span class="line">A.r[<span class="number">3</span>] = XMVectorSet(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"></span><br><span class="line">XMVECTOR det = XMMatrixDeterminant(A);</span><br><span class="line"><span class="keyword">return</span> XMMatrixTranspose(XMMatrixInverse(&amp;det, A));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-参与光照计算的一些关键向量"><a href="#1-2-参与光照计算的一些关键向量" class="headerlink" title="1.2 参与光照计算的一些关键向量"></a>1.2 参与光照计算的一些关键向量</h2><div align=center><img src="image-5.png" alt="光照计算中所需要的各种重要向量" style="zoom:50%;" /></div><p>如上图所示，<code>E</code>为观察者的观察位置，观察向量<code>v</code>为单位向量，<code>r</code>为反射向量，<code>I</code>为光线的入射方向，<code>n</code>为<code>p点</code>的表面法线，光向量<code>L</code>为单位向量，其所指方向与入射光线I的方向刚好相反。</p><h2 id="1-3-漫反射光照"><a href="#1-3-漫反射光照" class="headerlink" title="1.3 漫反射光照"></a>1.3 漫反射光照</h2><p>我们将漫反射光照的计算分为两个部分。第一部分，我们要指定光照颜色以及<strong>漫反射反照率（Diffuse Albedo）</strong>颜色。漫反射反照率表示的是根据表面的<strong>漫反射率</strong>而被反射的入射光量。要对它们进行处理就需要分量式颜色乘法。</p><p>设<code>ID</code>表示漫反射光颜色向量，<code>md</code>表示漫反射反照率，<code>L</code>为光向量，而<code>n</code>为表面法线。则根据上述表示某点的漫反射光量为：<br>$$<br>\mathbf{c}<em>{d}=\mathbf{I}</em>{d} \otimes \mathbf{m}_{d}<br>$$</p><p>但上述公式并非十分准确，我们还需将朗伯余弦定律（根据表面法线与光向量之间的夹角来控制表面接收原始光照的量）考虑在内。</p><div align=center><img src="image-6.png" alt="(a)横截面面积为A1的光束垂直照射到表面(b)将横截面面积为A1的光束以某角度照射到表面上的最大面积为A2，因此等量光能将扩散到更大的面积上，继而导致照射到物体表面的光束看起来“偏暗”" style="zoom: 50%;" /></div><p>则位于表面上某点处的漫反射光量为：</p><p>$$<br>\mathbf{c}<em>{d}=\mathbf{k}</em>{d}\mathbf{D}=\max (\mathbf{L} \cdot \mathbf{n}, 0) \cdot \mathbf{I}<em>{d} \otimes \mathbf{m}</em>{d}<br>$$</p><h2 id="1-4-环境光照"><a href="#1-4-环境光照" class="headerlink" title="1.4 环境光照"></a>1.4 环境光照</h2><p>我们的光照模型虽然并没有考虑到场景中其他物体反射来的间接光照。事实上，我们在真实世界所看到的多是间接光。为了处理这些间接光照，我们给光照方程引进了一个环境光（Ambient Light）项：<br>$$<br>\mathbf{c}<em>{a}=\mathbf{I}</em>{a} \otimes \mathbf{m}_{d}<br>$$</p><p>环境光颜色向量为<code>Ia</code>，漫反射反照率<code>md</code>指示了根据表面漫反射而被表面反射的入射光量。</p><p>总体思路是：<strong>间接光照在场景中会发生多次的散射与反射，并会在所有方向上均等的射向目标物体。</strong></p><h2 id="1-5-镜面光照"><a href="#1-5-镜面光照" class="headerlink" title="1.5 镜面光照"></a>1.5 镜面光照</h2><p>与漫反射不同，高光可能不会传入眼睛，因为它只在一个特定的方向上反射；高光的计算过程与观察点的位置相关。也就是说，当场景中的观察点位置发生变化时，我们看到的高光强度也会跟着变化。</p><div align=center><img src="image-7.png" alt="镜面反射" style="zoom:80%;" /></div><p>设<code>L</code>表示从被照射点向光源的方向向量，<code>v</code>为物体表面一点到人眼的单位方向向量，<code>r</code>为光反射后的单位方向向量，<code>p</code>为镜面系数（系数越大，表面越光滑，而且p的值必须大于等于1），可以用下面的公式来表达亮度<code>ks</code>：</p><p>$$<br>k_{s}=\left{\begin{array}{l}<br>\max (\mathbf{v} \cdot \mathbf{r}, 0)^{p}, \mathbf{L} \cdot \mathbf{n}&gt;0 \<br>0, \mathbf{L} \cdot \mathbf{n}\leq 0<br>\end{array}\right.<br>$$</p><p>因此高光项为：<br>$$<br>\mathbf{c}<em>{s}=\mathbf{k}</em>{s}\mathbf{S}=\mathbf{k}<em>{s}\cdot \mathbf{I}</em>{s} \otimes \mathbf{m}_{s}<br>$$</p><h2 id="1-6-光照模型"><a href="#1-6-光照模型" class="headerlink" title="1.6 光照模型"></a>1.6 光照模型</h2><p>将漫反射光、环境光以及镜面光所组合起来即可得到光照方程：<br>$$<br>\text{LitColor}=\mathbf{c}<em>{a} +\mathbf{c}</em>{d}+\mathbf{c}<em>{s}<br>$$<br>其中，<br>$$<br>\mathbf{c}</em>{a}=\mathbf{I}<em>{a} \otimes \mathbf{m}</em>{d}<br>$$<br>$$<br>\mathbf{c}<em>{d}=\max (\mathbf{L} \cdot \mathbf{n}, 0) \cdot \mathbf{I}</em>{d} \otimes \mathbf{m}<em>{d}<br>$$<br>$$<br>\mathbf{c}</em>{s}=\mathbf{k}<em>{s}\cdot \mathbf{I}</em>{s} \otimes \mathbf{m}<em>{s}<br>$$<br>$$<br>k</em>{s}=\left{\begin{array}{l}<br>\max (\mathbf{v} \cdot \mathbf{r}, 0)^{p}, \mathbf{L} \cdot \mathbf{n}&gt;0 \<br>0, \mathbf{L} \cdot \mathbf{n}\leq 0<br>\end{array}\right.<br>$$</p><h3 id="1-6-1-平行光"><a href="#1-6-1-平行光" class="headerlink" title="1.6.1 平行光"></a>1.6.1 平行光</h3><p>平行光是一种距离目标物体极远的光源，因此我们能够忽略距离带来的影响，而仅指定照射到场景中光线的向量。</p><div align=center><img src="image-8.png" alt="平行光" style="zoom:33%;" /></div><p>在C++中定义平行光的结构体并初始化平行光数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirectionalLight</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMFLOAT4 ambient;</span><br><span class="line">DirectX::XMFLOAT4 diffuse;</span><br><span class="line">DirectX::XMFLOAT4 specular;</span><br><span class="line">DirectX::XMFLOAT3 direction;</span><br><span class="line"><span class="keyword">float</span> pad; <span class="comment">//最后用一个浮点数填充使得该结构体大小满足16的倍数，便于我们以后在HLSL设置数组</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">m_DirLight.ambient = XMFLOAT4(<span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">m_DirLight.diffuse = XMFLOAT4(<span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">0.8f</span>, <span class="number">1.0f</span>);</span><br><span class="line">m_DirLight.specular = XMFLOAT4(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</span><br><span class="line">m_DirLight.direction = XMFLOAT3(<span class="number">-0.577f</span>, <span class="number">-0.577f</span>, <span class="number">0.577f</span>);</span><br></pre></td></tr></table></figure><p>在HLSL中定义平行光的结构体和计算函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平行光</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DirectionalLight</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 Ambient;</span><br><span class="line">    float4 Diffuse;</span><br><span class="line">    float4 Specular;</span><br><span class="line">    float3 Direction;</span><br><span class="line">    <span class="keyword">float</span> Pad;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ComputeDirectionalLight</span><span class="params">(Material mat, DirectionalLight L,</span></span></span><br><span class="line"><span class="function"><span class="params">float3 normal, float3 toEye,</span></span></span><br><span class="line"><span class="function"><span class="params">out float4 ambient,</span></span></span><br><span class="line"><span class="function"><span class="params">out float4 diffuse,</span></span></span><br><span class="line"><span class="function"><span class="params">out float4 spec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化输出</span></span><br><span class="line">    ambient = float4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    diffuse = float4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">    spec = float4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//光向量与光向量刚好相反</span></span><br><span class="line">    float3 lightVec = -L.Direction;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加环境光</span></span><br><span class="line">    ambient = mat.Ambient * L.Ambient;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加漫反射光和镜面光</span></span><br><span class="line">    <span class="keyword">float</span> diffuseFactor = dot(lightVec, normal);</span><br><span class="line"></span><br><span class="line"><span class="comment">//展开，避免动态分支</span></span><br><span class="line">[flatten]</span><br><span class="line">    <span class="keyword">if</span> (diffuseFactor &gt; <span class="number">0.0f</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        float3 v = reflect(-lightVec, normal);</span><br><span class="line">        <span class="keyword">float</span> specFactor = <span class="built_in">pow</span>(<span class="built_in">max</span>(dot(v, toEye), <span class="number">0.0f</span>), mat.Specular.w);</span><br><span class="line"></span><br><span class="line">        diffuse = diffuseFactor * mat.Diffuse * L.Diffuse;</span><br><span class="line">        spec = specFactor * mat.Specular * L.Specular;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里用到了HLSL中的关键字<strong>flatten</strong>，这些关键词是HLSL编译器为了优化代码为if和for语句添加的标签，具体含义如下：</p><ol><li><p>if语句</p></li><li><ol><li>branch<br>添加了branch标签的if语句shader会根据判断语句只执行当前情况的代码，这样会产生跳转指令。</li><li>flatten<br>添加了flatten标签的if语句shader会执行全部情况的分支代码，然后根据判断语句来决定使用哪个结果。</li></ol></li><li><p>for语句</p></li><li><ol><li>unroll<br>添加了unroll标签的for循环是可以展开的，直到循环条件终止，代价是产生更多机器码</li><li>loop<br>添加了loop标签的for循环不能展开，流式控制每次的循环迭代，for默认是loop</li></ol></li></ol></blockquote><h2 id="1-7-材质"><a href="#1-7-材质" class="headerlink" title="1.7 材质"></a>1.7 材质</h2><p>光在照射到物体上时，由于物体的材质特性会反射一部分光到人眼，最终我们观察到的物体颜色就是被反射的那部分光的颜色。不同的物体有不同的材质属性，决定了各种颜色分量的反射系数是多少。</p><p>在C++中定义材质的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//物体表面材质</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMFLOAT4 ambient;</span><br><span class="line">DirectX::XMFLOAT4 diffuse;</span><br><span class="line">DirectX::XMFLOAT4 specular; </span><br><span class="line">DirectX::XMFLOAT4 reflect;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在HLSL中定义材质的结构体初始化像素着色器中的材质数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//物体表面材质</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Material</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 Ambient;</span><br><span class="line">    float4 Diffuse;</span><br><span class="line">    float4 Specular; <span class="comment">// w = SpecPower</span></span><br><span class="line">    float4 Reflect;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//初始化用于PS的常量缓冲区的值</span></span><br><span class="line">m_PSConstantBuffer.material.ambient = XMFLOAT4(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">1.0f</span>);</span><br><span class="line">m_PSConstantBuffer.material.diffuse = XMFLOAT4(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">m_PSConstantBuffer.material.specular = XMFLOAT4(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">5.0f</span>);</span><br></pre></td></tr></table></figure><h2 id="1-8-常量缓冲区"><a href="#1-8-常量缓冲区" class="headerlink" title="1.8 常量缓冲区"></a>1.8 常量缓冲区</h2><p>由于需要对顶点做一些不同的变换，同时在像素着色器中添加光照。因此更改常量缓冲区与着色器：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VSConstantBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMMATRIX world;</span><br><span class="line">DirectX::XMMATRIX view;</span><br><span class="line">DirectX::XMMATRIX proj;</span><br><span class="line">DirectX::XMMATRIX worldInvTranspose;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PSConstantBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectionalLight dirLight;</span><br><span class="line">Material material;</span><br><span class="line">DirectX::XMFLOAT4 eyePos;</span><br><span class="line">&#125;;</span><br><span class="line">ComPtr&lt;ID3D11Buffer&gt;m_pConstantBuffers[<span class="number">2</span>]; <span class="comment">//常量缓冲区</span></span><br><span class="line">VSConstantBuffer m_VSConstantBuffer; <span class="comment">//用于修改用于VS的GPU常量缓冲区的变量</span></span><br><span class="line">PSConstantBuffer m_PSConstantBuffer; <span class="comment">//用于修改用于PS的GPU常量缓冲区的变量</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cbuffer VSConstantBuffer : <span class="keyword">register</span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    matrix g_World;</span><br><span class="line">    matrix g_View;</span><br><span class="line">    matrix g_Proj;</span><br><span class="line">    matrix g_WorldInvTranspose;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cbuffer PSConstantBuffer : <span class="keyword">register</span>(b1)</span><br><span class="line">&#123;</span><br><span class="line">    DirectionalLight g_DirLight;</span><br><span class="line">    Material g_Material;</span><br><span class="line">    float3 g_EyePosW;</span><br><span class="line">    <span class="keyword">float</span> g_Pad;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-9-着色器"><a href="#1-9-着色器" class="headerlink" title="1.9 着色器"></a>1.9 着色器</h2><h3 id="1-9-1-顶点着色器"><a href="#1-9-1-顶点着色器" class="headerlink" title="1.9.1 顶点着色器"></a>1.9.1 顶点着色器</h3><p>在顶点着色器中将顶点变换到不同空间输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点着色器</span></span><br><span class="line"><span class="function">VertexOut <span class="title">VS</span><span class="params">(VertexIn vIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VertexOut vOut;</span><br><span class="line">    matrix viewProj = mul(g_View, g_Proj);</span><br><span class="line">    <span class="comment">//将顶点变换到世界空间</span></span><br><span class="line">    float4 posW = mul(float4(vIn.PosL, <span class="number">1.0f</span>), g_World);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从顶点变换到齐次裁剪空间</span></span><br><span class="line">    vOut.PosH = mul(posW, viewProj);</span><br><span class="line">    vOut.PosW = posW.xyz;</span><br><span class="line">    <span class="comment">//假设这里进行的是等比缩放，否则这里需要使用世界矩阵的逆转置矩阵</span></span><br><span class="line">    vOut.NormalW = mul(vIn.NormalL, (float3x3) g_WorldInvTranspose);</span><br><span class="line">    vOut.Color = vIn.Color; <span class="comment">// 这里alpha通道的值默认为1.0</span></span><br><span class="line">    <span class="keyword">return</span> vOut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-2-像素着色器"><a href="#1-9-2-像素着色器" class="headerlink" title="1.9.2 像素着色器"></a>1.9.2 像素着色器</h3><p>在像素着色器中规范化法线，计算每个像素的最终颜色：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//像素着色器</span></span><br><span class="line"><span class="function">float4 <span class="title">PS</span><span class="params">(VertexOut pIn)</span> : SV_Target</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//对法线插值可能导致其非规范化，因此需要再次对它进行规范化处理</span></span><br><span class="line">    pIn.NormalW = normalize(pIn.NormalW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//光线经表面上一点反射到观察点这一方向上的向量</span></span><br><span class="line">    float3 toEyeW = normalize(g_EyePosW - pIn.PosW);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化为0 </span></span><br><span class="line">    float4 ambient, diffuse, spec;</span><br><span class="line">    float4 A, D, S;</span><br><span class="line">    ambient = diffuse = spec = A = D = S = float4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">    ComputeDirectionalLight(g_Material, g_DirLight, pIn.NormalW, toEyeW, A, D, S);</span><br><span class="line">    ambient += A;</span><br><span class="line">    diffuse += D;</span><br><span class="line">    spec += S;</span><br><span class="line"></span><br><span class="line">    float4 litColor = pIn.Color * (ambient + diffuse) + spec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从漫反射材质中获得alpha的常见手段</span></span><br><span class="line">    litColor.a = g_Material.Diffuse.a * pIn.Color.a;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> litColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-光栅化状态"><a href="#2-光栅化状态" class="headerlink" title="2. 光栅化状态"></a>2. 光栅化状态</h1><p>Direct3D是基于状态机的，我们可以通过修改这些状态来修改渲染管线的当前行为。有三种状态值得我们现在以及后续留意：</p><ol><li>光栅化状态（光栅化阶段）</li><li>混合状态（输出合并阶段）</li><li>深度/模板状态（输出合并阶段）</li></ol><blockquote><p>光栅化阶段尽管是不可编程的，<strong>但在该阶段需要完成许多任务：</strong></p><ol><li>顶点着色器、几何着色器完成了顶点输出后，光栅化阶段会负责对前面传来的顶点数据，尤其是对4D位置向量(SV_POSITION)进行透视除法，判断顶点是否在NDC空间内。</li><li>其次，根据光栅化状态来决定顶点顺(逆)时针排布的三角形是否通过。</li><li>它还能指定额外的裁剪区域，即矩形区域外的三角形(或者部分)被裁剪掉，仅留下剩余在矩形区域内的像素片元传递到像素着色器中进行处理。</li><li>根据三角形的三个顶点，光栅化就可以通过线性插值法对顶点内的所有成员(如位置，颜色，法向量等)进行插值运算，并根据视口信息计算出位于三角形内的所有像素顶点以传递给像素着色器，如前面的彩色渐变三角形。</li><li>由于光栅化阶段会进行视口变换，在像素着色器中，<code>SV_POSITION</code>的<code>x</code>分量和<code>y</code>分量都已经经过视口变换成为最终的屏幕坐标，且带有小数点<code>0.5</code>，这是因为要取到像素的中心位置，即对于800x600的视口区域，实际上的屏幕坐标取值范围为<code>[0.5, 799.5]x[0.5, 599.5]</code>，<code>z</code>分量取值范围为<code>[0, 1]</code>。</li></ol></blockquote><h2 id="2-1-D3D11-RASTERIZER-DESC结构体"><a href="#2-1-D3D11-RASTERIZER-DESC结构体" class="headerlink" title="2.1 D3D11_RASTERIZER_DESC结构体"></a>2.1 D3D11_RASTERIZER_DESC结构体</h2><p>用于配置渲染流水线中光栅化阶段的光栅器状态组由结构体<code>D3D11_RASTERIZER_DESC</code>表示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">D3D11_RASTERIZER_DESC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    D3D11_FILL_MODE FillMode;       <span class="comment">//填充模式，默认为D3D11_FULL_MODE_SOLID</span></span><br><span class="line">    D3D11_CULL_MODE CullMode;       <span class="comment">//裁剪模式，默认为D3D11_CULL_MODE_BACK</span></span><br><span class="line">    BOOL FrontCounterClockwise;     <span class="comment">//是否三角形顶点按逆时针排布时为正面，默认为false</span></span><br><span class="line">    INT DepthBias;                  <span class="comment">//忽略，默认为0</span></span><br><span class="line">    FLOAT DepthBiasClamp;           <span class="comment">//忽略，默认为0.0f</span></span><br><span class="line">    FLOAT SlopeScaledDepthBias;     <span class="comment">//忽略，默认为0.0f</span></span><br><span class="line">    BOOL DepthClipEnable;           <span class="comment">//是否允许深度测试将范围外的像素进行裁剪，默认为true</span></span><br><span class="line">    BOOL ScissorEnable;             <span class="comment">//是否允许指定矩形范围的裁剪，默认为false</span></span><br><span class="line">    BOOL MultisampleEnable;         <span class="comment">//是否允许多重采样，默认为false</span></span><br><span class="line">    BOOL AntialiasedLineEnable;     <span class="comment">//是否允许反走样线，仅当无多重采样为时才有效，默认为false</span></span><br><span class="line">&#125;D3D11_RASTERIZER_DESC;</span><br></pre></td></tr></table></figure><p>其中有3个关键成员：</p><h3 id="2-1-1-FillMode"><a href="#2-1-1-FillMode" class="headerlink" title="2.1.1 FillMode"></a>2.1.1 FillMode</h3><table><thead><tr><th>枚举值</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>D3D11_FILL_WIREFRAME</td><td>采用线框模式进行渲染</td></tr><tr><td>D3D11_FILL_SOLID</td><td>使用实体模式进行渲染，默认</td></tr></tbody></table><h3 id="2-1-2-CullMode"><a href="#2-1-2-CullMode" class="headerlink" title="2.1.2 CullMode"></a>2.1.2 CullMode</h3><table><thead><tr><th>枚举值</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>D3D11_CULL_NONE</td><td>禁用剔除操作</td></tr><tr><td>D3D11_CULL_BACK</td><td>剔除背面朝向的三角形，默认</td></tr><tr><td>D3D11_CULL_FRONT</td><td>剔除正面朝向的三角形</td></tr></tbody></table><h3 id="2-1-3-FrontCounterClockwise"><a href="#2-1-3-FrontCounterClockwise" class="headerlink" title="2.1.3 FrontCounterClockwise"></a>2.1.3 FrontCounterClockwise</h3><table><thead><tr><th>枚举值</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>FrontCounterClockwise = false</td><td>根据摄像机的观察视角，将顶点顺序为顺时针方向的三角形看作正面朝向，而把逆时针绕序的三角形当作背面朝向。默认。</td></tr><tr><td>FrontCounterClockwise = true</td><td>根据摄像机的观察视角，将顶点顺序为逆时针方向的三角形看作正面朝向，而把顺时针绕序的三角形当作背面朝向。</td></tr></tbody></table><h2 id="2-2-初始化光栅化状态"><a href="#2-2-初始化光栅化状态" class="headerlink" title="2.2 初始化光栅化状态"></a>2.2 初始化光栅化状态</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D3D11_RASTERIZER_DESC rasterizerDesc;</span><br><span class="line">ZeroMemory(&amp;rasterizerDesc, <span class="keyword">sizeof</span>(rasterizerDesc));</span><br><span class="line">rasterizerDesc.FillMode = D3D11_FILL_WIREFRAME;</span><br><span class="line">rasterizerDesc.CullMode = D3D11_CULL_NONE;</span><br><span class="line">rasterizerDesc.FrontCounterClockwise = <span class="literal">false</span>;</span><br><span class="line">rasterizerDesc.DepthClipEnable = <span class="literal">true</span>;</span><br><span class="line">m_pDevice-&gt;CreateRasterizerState(&amp;rasterizerDesc, m_pRSWireframe.GetAddressOf());</span><br></pre></td></tr></table></figure><p>运行程序，便可看到带有平行光的效果了，同时还可以切换显示模式。</p><div align=center><p><img src="gif-1.gif" alt="光照效果"></p></div><hr><p>参考：</p><p>1.<a href="http://zanple.top/2020/04/07/cg-unity-matrix/">计算机图形学-Unity中矩阵变换、坐标空间的回顾</a></p><p>2.《DirectX 12 3D游戏开发实战 第8章》</p><p>3.<a href="https://www.cnblogs.com/X-Jun/p/9095615.html">DirectX11 With Windows SDK–07 添加光照与常用几何模型、光栅化状态</a></p><p>4.<a href="https://zhuanlan.zhihu.com/p/115871017">HLSL 关键词branch flatten unroll loop</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一节中，我们绘制出了各种几何体。但这些几何体的所有面都是相同的颜色，看起来像是一个2D平面。</summary>
    
    
    
    <category term="Direct3D" scheme="http://www.zanple.top/categories/Direct3D/"/>
    
    
    <category term="C++" scheme="http://www.zanple.top/tags/C/"/>
    
    <category term="Direct3D" scheme="http://www.zanple.top/tags/Direct3D/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>DirectX11入门笔记-03-不同形状的几何体</title>
    <link href="http://www.zanple.top/2021/01/06/directx11-03-geometry/"/>
    <id>http://www.zanple.top/2021/01/06/directx11-03-geometry/</id>
    <published>2021-01-06T09:12:45.000Z</published>
    <updated>2021-03-06T09:51:40.804Z</updated>
    
    <content type="html"><![CDATA[<p>在上一节中我们在GameApp类中创建了立方体，并设置了其顶点索引等数据。绘制一个物体需要设置多种参数，例如绑定顶点缓冲区和索引缓冲区、绑定与物体有关的常量数据、设定图元类型以及指定参数。但随着场景中所绘制的物体数量和种类逐渐增多，如椭球体、球体、柱体等，我们便需要创建一个类来生成这些简单的几何体。<a id="more"></a></p><hr><h1 id="1-Geometry类生成几何体"><a href="#1-Geometry类生成几何体" class="headerlink" title="1. Geometry类生成几何体"></a>1. Geometry类生成几何体</h1><p>因此我们将程序性几何体的生成代码放入Geometry类中。Geometry类是一个工具类，用于生成如栅格、球体、柱体以及长方体这类简单的几何体。此类将数据生成在系统内存中，因此我们需要将这些数据复制到顶点缓冲区和索引缓冲区内。</p><p>首先我们创建Geometry与Vertex类，将之前在GameApp中关于顶点布局的部分放入Vertex类，并实现Geometry类来生成简单的几何体。</p><h2 id="1-1-创建立方体"><a href="#1-1-创建立方体" class="headerlink" title="1.1 创建立方体"></a>1.1 创建立方体</h2><p>立方体的创建与上一节类似，将立方体的每个面分为两个三角面，不同的是，立方体的每个顶点都对应则三个平面，因此每个顶点都有三个对应的法向量。</p><div align=center><p><img src="image-1.png" alt="立方体顶点"></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">IndexType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">MeshData</span>&lt;VertexType, IndexType&gt; <span class="title">CreateBox</span>(<span class="title">float</span> <span class="title">width</span>, <span class="title">float</span> <span class="title">height</span>, <span class="title">float</span> <span class="title">depth</span>, <span class="title">const</span> <span class="title">DirectX</span>:</span>:XMFLOAT4&amp; color)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line">MeshData&lt;VertexType, IndexType&gt; meshData;</span><br><span class="line">meshData.vertexVec.resize(<span class="number">24</span>);</span><br><span class="line"></span><br><span class="line">Internal::VertexData vertexDataArr[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">float</span> w2 = <span class="built_in">width</span> / <span class="number">2</span>, h2 = <span class="built_in">height</span> / <span class="number">2</span>, d2 = depth / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//右面(+X面)</span></span><br><span class="line">vertexDataArr[<span class="number">0</span>].pos = XMFLOAT3(w2, -h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">1</span>].pos = XMFLOAT3(w2, h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">2</span>].pos = XMFLOAT3(w2, h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">3</span>].pos = XMFLOAT3(w2, -h2, d2);</span><br><span class="line"><span class="comment">//左面(-X面)</span></span><br><span class="line">vertexDataArr[<span class="number">4</span>].pos = XMFLOAT3(-w2, -h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">5</span>].pos = XMFLOAT3(-w2, h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">6</span>].pos = XMFLOAT3(-w2, h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">7</span>].pos = XMFLOAT3(-w2, -h2, -d2);</span><br><span class="line"><span class="comment">//顶面(+Y面)</span></span><br><span class="line">vertexDataArr[<span class="number">8</span>].pos = XMFLOAT3(-w2, h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">9</span>].pos = XMFLOAT3(-w2, h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">10</span>].pos = XMFLOAT3(w2, h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">11</span>].pos = XMFLOAT3(w2, h2, -d2);</span><br><span class="line"><span class="comment">//底面(-Y面)</span></span><br><span class="line">vertexDataArr[<span class="number">12</span>].pos = XMFLOAT3(w2, -h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">13</span>].pos = XMFLOAT3(w2, -h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">14</span>].pos = XMFLOAT3(-w2, -h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">15</span>].pos = XMFLOAT3(-w2, -h2, -d2);</span><br><span class="line"><span class="comment">//背面(+Z面)</span></span><br><span class="line">vertexDataArr[<span class="number">16</span>].pos = XMFLOAT3(w2, -h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">17</span>].pos = XMFLOAT3(w2, h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">18</span>].pos = XMFLOAT3(-w2, h2, d2);</span><br><span class="line">vertexDataArr[<span class="number">19</span>].pos = XMFLOAT3(-w2, -h2, d2);</span><br><span class="line"><span class="comment">//正面(-Z面)</span></span><br><span class="line">vertexDataArr[<span class="number">20</span>].pos = XMFLOAT3(-w2, -h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">21</span>].pos = XMFLOAT3(-w2, h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">22</span>].pos = XMFLOAT3(w2, h2, -d2);</span><br><span class="line">vertexDataArr[<span class="number">23</span>].pos = XMFLOAT3(w2, -h2, -d2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//右面(+X面)</span></span><br><span class="line">vertexDataArr[i].normal = XMFLOAT3(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertexDataArr[i].tangent = XMFLOAT4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i].color = color;</span><br><span class="line"><span class="comment">//左面(-X面)</span></span><br><span class="line">vertexDataArr[i + <span class="number">4</span>].normal = XMFLOAT3(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">4</span>].tangent = XMFLOAT4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">4</span>].color = color;</span><br><span class="line"><span class="comment">//顶面(+Y面)</span></span><br><span class="line">vertexDataArr[i + <span class="number">8</span>].normal = XMFLOAT3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">8</span>].tangent = XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">8</span>].color = color;</span><br><span class="line"><span class="comment">//底面(-Y面)</span></span><br><span class="line">vertexDataArr[i + <span class="number">12</span>].normal = XMFLOAT3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">12</span>].tangent = XMFLOAT4(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">12</span>].color = color;</span><br><span class="line"><span class="comment">//背面(+Z面)</span></span><br><span class="line">vertexDataArr[i + <span class="number">16</span>].normal = XMFLOAT3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">16</span>].tangent = XMFLOAT4(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">16</span>].color = color;</span><br><span class="line"><span class="comment">//正面(-Z面)</span></span><br><span class="line">vertexDataArr[i + <span class="number">20</span>].normal = XMFLOAT3(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">20</span>].tangent = XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i + <span class="number">20</span>].color = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">vertexDataArr[i * <span class="number">4</span>].tex = XMFLOAT2(<span class="number">0.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">vertexDataArr[i * <span class="number">4</span> + <span class="number">1</span>].tex = XMFLOAT2(<span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertexDataArr[i * <span class="number">4</span> + <span class="number">2</span>].tex = XMFLOAT2(<span class="number">1.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line">vertexDataArr[i * <span class="number">4</span> + <span class="number">3</span>].tex = XMFLOAT2(<span class="number">1.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[i], vertexDataArr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">meshData.indexVec = &#123;</span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>,<span class="comment">//右面(+X面)</span></span><br><span class="line"><span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>,<span class="comment">//左面(-X面)</span></span><br><span class="line"><span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">8</span>,<span class="comment">//顶面(+Y面)</span></span><br><span class="line"><span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">12</span>,<span class="comment">//底面(-Y面)</span></span><br><span class="line"><span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">16</span>, <span class="comment">//背面(+Z面)</span></span><br><span class="line"><span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">20</span><span class="comment">//正面(-Z面)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-创建柱体"><a href="#1-2-创建柱体" class="headerlink" title="1.2 创建柱体"></a>1.2 创建柱体</h2><p>在定义一个柱体时，需要指定其顶、底面半径，高度，切片数量（slice count，即将截面分割的块数），以及堆叠层数（stack count，即横向切割的层数），如图所示。</p><div align=center><p><img src="image-2.png" alt="切片数量和堆叠层控制着构成圆台的三角形密集程度，三角形越多则所绘图形越接近预定的几何体。因为创建的顶面半径和底面半径可以是不同的，因此也可以创建出锥体"></p></div><p>我们将柱体的构成分为侧面几何体，顶面几何体与底面几何体三部分。</p><h3 id="1-2-1-柱体的侧面几何体"><a href="#1-2-1-柱体的侧面几何体" class="headerlink" title="1.2.1 柱体的侧面几何体"></a>1.2.1 柱体的侧面几何体</h3><p>我们要生成的是中心（即1/2高度处截面的中心点）位于<code>原点</code>，且旋转轴平行于<code>y轴</code>的圆台。从上图中可以看出，圆台的所有顶点都列于其各层侧面的环上。共有<code>stackCount+1</code>环，而每个环上的顶点数量都为<code>sliceCount</code>。相邻环的半径差为<code>△r=(topRadius-buttomRadius)/stackCount</code>。如果从底面上的环开始用索引<code>0</code>来表示，那么第<code>i</code>环的半径就是<code>ri=bottomRadius+i△r</code>，且第<code>i</code>环的高度值为<code>hi=(-h/2)+i△h</code>（可见，1/2高度以下为负值，1/2高度以上为正值），其中<code>△h</code>是每层的高度，<code>h</code>为圆台的高度。由此可见，生成圆台的<strong>基本思路是遍历每个环，并生成列于环上的各个顶点。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">IndexType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">MeshData</span>&lt;VertexType, IndexType&gt; <span class="title">CreateCylinderNoCap</span>(<span class="title">float</span> <span class="title">radius</span>, <span class="title">float</span> <span class="title">height</span>, <span class="title">UINT</span> <span class="title">slices</span>, <span class="title">UINT</span> <span class="title">stacks</span>,</span></span><br><span class="line"><span class="class"><span class="title">float</span> <span class="title">texU</span>, <span class="title">float</span> <span class="title">texV</span>, <span class="title">const</span> <span class="title">DirectX</span>:</span>:XMFLOAT4&amp; color)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"></span><br><span class="line">MeshData&lt;VertexType, IndexType&gt; meshData;</span><br><span class="line">UINT vertexCount = (slices + <span class="number">1</span>) * (stacks + <span class="number">1</span>);</span><br><span class="line">UINT indexCount = <span class="number">6</span> * slices * stacks;</span><br><span class="line">meshData.vertexVec.resize(vertexCount);</span><br><span class="line">meshData.indexVec.resize(indexCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> h2 = <span class="built_in">height</span> / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">float</span> theta = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> per_theta = XM_2PI / slices;</span><br><span class="line"><span class="comment">//构建堆叠层</span></span><br><span class="line"><span class="keyword">float</span> stackHeight = <span class="built_in">height</span> / stacks;</span><br><span class="line"></span><br><span class="line">Internal::VertexData vertexData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从底面开始，由下至上计算每个堆叠层环上的顶点坐标</span></span><br><span class="line">UINT vIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; stacks + <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">float</span> y = -h2 + i * stackHeight;</span><br><span class="line"><span class="comment">//当前层顶点</span></span><br><span class="line"><span class="keyword">for</span> (UINT j = <span class="number">0</span>; j &lt;= slices; ++j)</span><br><span class="line">&#123;</span><br><span class="line">theta = j * per_theta;</span><br><span class="line"><span class="keyword">float</span> u = theta / XM_2PI;</span><br><span class="line"><span class="keyword">float</span> v = <span class="number">1.0f</span> - (<span class="keyword">float</span>)i / stacks;</span><br><span class="line">vertexData = &#123; XMFLOAT3(radius * cosf(theta), y, radius * sinf(theta)), XMFLOAT3(cosf(theta), <span class="number">0.0f</span>, sinf(theta)),</span><br><span class="line">XMFLOAT4(-sinf(theta), <span class="number">0.0f</span>, cosf(theta), <span class="number">1.0f</span>), color, XMFLOAT2(u * texU, v * texV) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img src="image-3.png" alt="柱面" style="zoom: 50%;" /></div><p>构建完顶点则需要将其放入索引中。由上图可知，由每个分层以及切片分割出的侧面块都是一个四边形（由两个三角形构成）。而以第<code>i</code>层与第<code>j</code>块切片所确定下来的侧面块中的两个三角形的索引分别为：<br>$$<br>\begin{array}{l}<br>\Delta A B C=(i \cdot n+j,(i+1) \cdot n+j,(i+1) \cdot n+j+1) \<br>\Delta A C D=(i \cdot n+j,(i+1) \cdot n+j+1, i \cdot n+j+1)<br>\end{array}<br>$$<br>其中，<code>n</code>是每个环上的顶点数量。因此，求取圆台侧面块上的所有三角形索引的<strong>主要思路是：便利每个堆叠层和每个切片，并运用上述公式进行计算。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算每个侧面块中的三角形索引</span></span><br><span class="line">UINT iIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; stacks; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (UINT j = <span class="number">0</span>; j &lt; slices; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//+1是希望让每环的第一个顶点和最后一个顶点重合，这是因为它们的纹理坐标并不相同</span></span><br><span class="line">meshData.indexVec[iIndex++] = i * (slices + <span class="number">1</span>) + j;</span><br><span class="line">meshData.indexVec[iIndex++] = (i + <span class="number">1</span>) * (slices + <span class="number">1</span>) + j;</span><br><span class="line">meshData.indexVec[iIndex++] = (i + <span class="number">1</span>) * (slices + <span class="number">1</span>) + j + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = i * (slices + <span class="number">1</span>) + j;</span><br><span class="line">meshData.indexVec[iIndex++] = (i + <span class="number">1</span>) * (slices + <span class="number">1</span>) + j + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = i * (slices + <span class="number">1</span>) + j + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-2-柱面的端面几何体"><a href="#1-2-2-柱面的端面几何体" class="headerlink" title="1.2.2 柱面的端面几何体"></a>1.2.2 柱面的端面几何体</h3><p>生成圆台端面的几何体，相当于在其顶面和底面的截面上切割出多个三角形，使之逼近一个圆形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">IndexType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">MeshData</span>&lt;VertexType, IndexType&gt; <span class="title">CreateCylinder</span>(<span class="title">float</span> <span class="title">radius</span>, <span class="title">float</span> <span class="title">height</span>, <span class="title">UINT</span> <span class="title">slices</span>, <span class="title">UINT</span> <span class="title">stacks</span>,</span></span><br><span class="line"><span class="class"><span class="title">float</span> <span class="title">texU</span>, <span class="title">float</span> <span class="title">texV</span>, <span class="title">const</span> <span class="title">DirectX</span>:</span>:XMFLOAT4&amp; color)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line"><span class="keyword">auto</span> meshData = CreateCylinderNoCap&lt;VertexType, IndexType&gt;(radius, <span class="built_in">height</span>, slices, stacks, texU, texV, color);</span><br><span class="line">UINT vertexCount = (slices + <span class="number">1</span>) * (stacks + <span class="number">3</span>) + <span class="number">2</span>;</span><br><span class="line">UINT indexCount = <span class="number">6</span> * slices * (stacks + <span class="number">1</span>);</span><br><span class="line">meshData.vertexVec.resize(vertexCount);</span><br><span class="line">meshData.indexVec.resize(indexCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> h2 = <span class="built_in">height</span> / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">float</span> theta = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> per_theta = XM_2PI / slices;</span><br><span class="line"></span><br><span class="line">IndexType vIndex = (slices + <span class="number">1</span>) * (stacks + <span class="number">1</span>), iIndex = <span class="number">6</span> * slices * stacks;</span><br><span class="line">IndexType offset = vIndex;</span><br><span class="line">Internal::VertexData vertexData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入顶端圆心</span></span><br><span class="line">vertexData = &#123; XMFLOAT3(<span class="number">0.0f</span>, h2, <span class="number">0.0f</span>), XMFLOAT3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>), color, XMFLOAT2(<span class="number">0.5f</span>, <span class="number">0.5f</span>) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使圆台端面环上的首尾顶点重合，因为这两个顶点的纹理坐标和法线是不同的</span></span><br><span class="line"><span class="comment">//放入顶端圆上各点</span></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt;= slices; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//根据圆台的高度使顶面纹理坐标的范围缩小</span></span><br><span class="line">theta = i * per_theta;</span><br><span class="line"><span class="keyword">float</span> u = cosf(theta) * radius / <span class="built_in">height</span> + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">float</span> v = sinf(theta) * radius / <span class="built_in">height</span> + <span class="number">0.5f</span>;</span><br><span class="line">vertexData = &#123; XMFLOAT3(radius * cosf(theta), h2, radius * sinf(theta)), XMFLOAT3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>), color, XMFLOAT2(u, v) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入底端圆心</span></span><br><span class="line">vertexData = &#123; XMFLOAT3(<span class="number">0.0f</span>, -h2, <span class="number">0.0f</span>), XMFLOAT3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">XMFLOAT4(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>), color, XMFLOAT2(<span class="number">0.5f</span>, <span class="number">0.5f</span>) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入底部圆上各点</span></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt;= slices; ++i)</span><br><span class="line">&#123;</span><br><span class="line">theta = i * per_theta;</span><br><span class="line"><span class="keyword">float</span> u = cosf(theta) * radius / <span class="built_in">height</span> + <span class="number">0.5f</span>;</span><br><span class="line"><span class="keyword">float</span> v = sinf(theta) * radius / <span class="built_in">height</span> + <span class="number">0.5f</span>;</span><br><span class="line">vertexData = &#123; XMFLOAT3(radius * cosf(theta), -h2, radius * sinf(theta)), XMFLOAT3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">XMFLOAT4(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>), color, XMFLOAT2(u, v) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入顶部三角形索引</span></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">1</span>; i &lt;= slices; ++i)</span><br><span class="line">&#123;</span><br><span class="line">meshData.indexVec[iIndex++] = offset;</span><br><span class="line">meshData.indexVec[iIndex++] = offset + i % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = offset + i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入底部三角形索引</span></span><br><span class="line">offset += slices + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">1</span>; i &lt;= slices; ++i)</span><br><span class="line">&#123;</span><br><span class="line">meshData.indexVec[iIndex++] = offset;</span><br><span class="line">meshData.indexVec[iIndex++] = offset + i;</span><br><span class="line">meshData.indexVec[iIndex++] = offset + i % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-创建球体"><a href="#1-3-创建球体" class="headerlink" title="1.3 创建球体"></a>1.3 创建球体</h2><div align=center><img src="image-4.png" alt="柱体的切片与分层实现也同样可以应用到球体上，借此来控制球体的曲面细分级别" style="zoom:33%;" /></div><p>定义一个球体需要指定其半径、切片数量以及堆叠层数，如上图所示。除了每个环上的半径是依三角函数非线性变化，生成球体的算法与生成圆台的算法非常接近。此外，若采用<strong>不等比缩放世界</strong>变换，即可将球体转换为<strong>椭球体</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">VertexType</span>, <span class="title">class</span> <span class="title">IndexType</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">MeshData</span>&lt;VertexType, IndexType&gt; <span class="title">CreateSphere</span>(<span class="title">float</span> <span class="title">radius</span>, <span class="title">UINT</span> <span class="title">levels</span>, <span class="title">UINT</span> <span class="title">slices</span>, <span class="title">const</span> <span class="title">DirectX</span>:</span>:XMFLOAT4&amp; color)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> DirectX;</span><br><span class="line">MeshData&lt;VertexType, IndexType&gt; meshData;</span><br><span class="line">UINT vertexCount = <span class="number">2</span> + (levels - <span class="number">1</span>) * (slices + <span class="number">1</span>);</span><br><span class="line">UINT indexCount = <span class="number">6</span> * (levels - <span class="number">1</span>) * slices;</span><br><span class="line">meshData.vertexVec.resize(vertexCount);</span><br><span class="line">meshData.indexVec.resize(indexCount);</span><br><span class="line"></span><br><span class="line">Internal::VertexData vertexData;</span><br><span class="line">IndexType vIndex = <span class="number">0</span>, iIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> phi = <span class="number">0.0f</span>, theta = <span class="number">0.0f</span>;</span><br><span class="line"><span class="keyword">float</span> per_phi = XM_PI / levels;</span><br><span class="line"><span class="keyword">float</span> per_theta = XM_2PI / slices;</span><br><span class="line"><span class="keyword">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入顶端点</span></span><br><span class="line">vertexData = &#123; XMFLOAT3(<span class="number">0.0f</span>, radius, <span class="number">0.0f</span>), XMFLOAT3(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>), XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>), color, XMFLOAT2(<span class="number">0.0f</span>, <span class="number">0.0f</span>) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">1</span>; i &lt; levels; ++i)</span><br><span class="line">&#123;</span><br><span class="line">phi = per_phi * i;</span><br><span class="line"><span class="comment">//需要slices + 1个顶点是因为 起点和终点需为同一点，但纹理坐标值不一致</span></span><br><span class="line"><span class="keyword">for</span> (UINT j = <span class="number">0</span>; j &lt;= slices; ++j)</span><br><span class="line">&#123;</span><br><span class="line">theta = per_theta * j;</span><br><span class="line">x = radius * sinf(phi) * cosf(theta);</span><br><span class="line">y = radius * cosf(phi);</span><br><span class="line">z = radius * sinf(phi) * sinf(theta);</span><br><span class="line"><span class="comment">//计算出局部坐标、法向量、Tangent向量和纹理坐标</span></span><br><span class="line">XMFLOAT3 pos = XMFLOAT3(x, y, z), normal;</span><br><span class="line">XMStoreFloat3(&amp;normal, XMVector3Normalize(XMLoadFloat3(&amp;pos)));</span><br><span class="line">vertexData = &#123; pos, normal, XMFLOAT4(-sinf(theta), <span class="number">0.0f</span>, cosf(theta), <span class="number">1.0f</span>), color, XMFLOAT2(theta / XM_2PI, phi / XM_PI) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入底端点</span></span><br><span class="line">vertexData = &#123; XMFLOAT3(<span class="number">0.0f</span>, -radius, <span class="number">0.0f</span>), XMFLOAT3(<span class="number">0.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">XMFLOAT4(<span class="number">-1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>), color, XMFLOAT2(<span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;;</span><br><span class="line">Internal::InsertVertexElement(meshData.vertexVec[vIndex++], vertexData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入索引</span></span><br><span class="line"><span class="keyword">if</span> (levels &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (UINT j = <span class="number">1</span>; j &lt;= slices; ++j)</span><br><span class="line">&#123;</span><br><span class="line">meshData.indexVec[iIndex++] = <span class="number">0</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = j % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (UINT i = <span class="number">1</span>; i &lt; levels - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (UINT j = <span class="number">1</span>; j &lt;= slices; ++j)</span><br><span class="line">&#123;</span><br><span class="line">meshData.indexVec[iIndex++] = (i - <span class="number">1</span>) * (slices + <span class="number">1</span>) + j;</span><br><span class="line">meshData.indexVec[iIndex++] = (i - <span class="number">1</span>) * (slices + <span class="number">1</span>) + j % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = i * (slices + <span class="number">1</span>) + j % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = i * (slices + <span class="number">1</span>) + j % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = i * (slices + <span class="number">1</span>) + j;</span><br><span class="line">meshData.indexVec[iIndex++] = (i - <span class="number">1</span>) * (slices + <span class="number">1</span>) + j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐渐放入索引</span></span><br><span class="line"><span class="keyword">if</span> (levels &gt; <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (UINT j = <span class="number">1</span>; j &lt;= slices; ++j)</span><br><span class="line">&#123;</span><br><span class="line">meshData.indexVec[iIndex++] = (levels - <span class="number">2</span>) * (slices + <span class="number">1</span>) + j;</span><br><span class="line">meshData.indexVec[iIndex++] = (levels - <span class="number">2</span>) * (slices + <span class="number">1</span>) + j % (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">meshData.indexVec[iIndex++] = (levels - <span class="number">1</span>) * (slices + <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> meshData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种方法生成的球体的三角形面积并不相同，这在某些情境中并非我们所愿。</p><h3 id="1-3-1-创建几何球体网络"><a href="#1-3-1-创建几何球体网络" class="headerlink" title="1.3.1 创建几何球体网络"></a>1.3.1 创建几何球体网络</h3><p>相对上面的方法来创建球体而言，我们还可以利用面积相同且边长相等的三角形来逼近球体，如图所示。</p><div align=center><img src="image-5.png" alt="通过反复细分并将新生成的顶点重新投影到球面上，便可以近似地表示一个几何球体" style="zoom: 50%;" /></div><p>为了生成几何球体，我们以一个正二十面体作为基础，细分其上的三角形，再根据给定的半径向球面投影新生成的顶点。反复重复这个过程，便可以提高该几何球体的曲面细分程度。</p><div align=center><img src="image-6.png" alt="将一个三角形细分为4个等面积小三角形的过程" style="zoom: 67%;" /></div><p>如上图所示，我们可以将一个三角形细分为<code>4个</code>大小相等的小三角形。不难发现，新生成的顶点都位于原始三角形边上的中点。先将定点投影到单位球面上，在利用<code>r</code>进行标量乘法：<br>$$<br>\mathbf{v}^{\prime}=r \frac{\mathbf{v}}{|\mathbf{v}|}<br>$$<br>即可把新顶点都投影到半径为<code>r</code>的球体上。</p><h1 id="2-绘制几何体"><a href="#2-绘制几何体" class="headerlink" title="2.绘制几何体"></a>2.绘制几何体</h1><p>在GameApp中include Geometry类后，创建一个绘制物体的索引数组大小<code>m_IndexCount</code>，在初始化资源函数中将原先绘制立方体部分换成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化网格模型</span></span><br><span class="line"><span class="keyword">auto</span> meshData = Geometry::CreateBox&lt;VertexPosColor&gt;();</span><br><span class="line">ResetMesh(meshData);</span><br></pre></td></tr></table></figure><p>此外，添加一个重新设置要使用的模型的方法<code>ResetMesh</code>，用于重新设置要使用的模型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GameApp::ResetMesh</span><span class="params">(<span class="keyword">const</span> Geometry::MeshData&lt;VertexPosColor&gt;&amp; meshData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//释放旧资源</span></span><br><span class="line">m_pVertexBuffer.Reset();</span><br><span class="line">m_pIndexBuffer.Reset();</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置顶点缓冲区描述</span></span><br><span class="line">D3D11_BUFFER_DESC vbd;</span><br><span class="line">ZeroMemory(&amp;vbd, <span class="keyword">sizeof</span>(vbd));</span><br><span class="line">vbd.Usage = D3D11_USAGE_IMMUTABLE;</span><br><span class="line">vbd.ByteWidth = (UINT)meshData.vertexVec.<span class="built_in">size</span>() * <span class="keyword">sizeof</span>(VertexPosColor);</span><br><span class="line">vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;</span><br><span class="line">vbd.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//新建顶点缓冲区</span></span><br><span class="line">D3D11_SUBRESOURCE_DATA InitData;</span><br><span class="line">ZeroMemory(&amp;InitData, <span class="keyword">sizeof</span>(InitData));</span><br><span class="line">InitData.pSysMem = meshData.vertexVec.data();</span><br><span class="line">m_pDevice-&gt;CreateBuffer(&amp;vbd, &amp;InitData, m_pVertexBuffer.GetAddressOf());</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入装配阶段的顶点缓冲区设置</span></span><br><span class="line">UINT stride = <span class="keyword">sizeof</span>(VertexPosColor);<span class="comment">//跨越字节数</span></span><br><span class="line">UINT offset = <span class="number">0</span>;<span class="comment">//起始偏移量</span></span><br><span class="line"></span><br><span class="line">m_pContext-&gt;IASetVertexBuffers(<span class="number">0</span>, <span class="number">1</span>, m_pVertexBuffer.GetAddressOf(), &amp;stride, &amp;offset);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//设置索引缓冲区描述</span></span><br><span class="line">m_IndexCount = (UINT)meshData.indexVec.<span class="built_in">size</span>();</span><br><span class="line">D3D11_BUFFER_DESC ibd;</span><br><span class="line">ZeroMemory(&amp;ibd, <span class="keyword">sizeof</span>(ibd));</span><br><span class="line">ibd.Usage = D3D11_USAGE_IMMUTABLE;</span><br><span class="line">ibd.ByteWidth = m_IndexCount * <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line">ibd.BindFlags = D3D11_BIND_INDEX_BUFFER;</span><br><span class="line">ibd.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//新建索引缓冲区</span></span><br><span class="line">InitData.pSysMem = meshData.indexVec.data();</span><br><span class="line">m_pDevice-&gt;CreateBuffer(&amp;ibd, &amp;InitData, m_pIndexBuffer.GetAddressOf());</span><br><span class="line"><span class="comment">//输入装配阶段的索引缓冲区设置</span></span><br><span class="line">m_pContext-&gt;IASetIndexBuffer(m_pIndexBuffer.Get(), DXGI_FORMAT_R32_UINT, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更改键盘的按键状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键盘切换模型类型</span></span><br><span class="line"><span class="keyword">if</span> (m_KeyboardTracker.IsKeyPressed(<span class="built_in">Keyboard</span>::D1))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> meshData = Geometry::CreateBox&lt;VertexPosColor&gt;();</span><br><span class="line">ResetMesh(meshData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_KeyboardTracker.IsKeyPressed(<span class="built_in">Keyboard</span>::D2))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> meshData = Geometry::CreateSphere&lt;VertexPosColor&gt;();</span><br><span class="line">ResetMesh(meshData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_KeyboardTracker.IsKeyPressed(<span class="built_in">Keyboard</span>::D3))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> meshData = Geometry::CreateCylinder&lt;VertexPosColor&gt;();</span><br><span class="line">ResetMesh(meshData);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_KeyboardTracker.IsKeyPressed(<span class="built_in">Keyboard</span>::D4))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> meshData = Geometry::CreateCone&lt;VertexPosColor&gt;();</span><br><span class="line">ResetMesh(meshData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过索引绘制的方法便可以绘制出几何体了。</p><div align=center><p><img src="gif-1.gif" alt="绘制出的几何体"></p></div><hr><p>参考：</p><p>1.《DirectX 12 3D游戏开发实战 第7章》</p><p>2.<a href="https://www.cnblogs.com/X-Jun/p/9095615.html">DirectX11 With Windows SDK–07 添加光照与常用几何模型、光栅化状态</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在上一节中我们在GameApp类中创建了立方体，并设置了其顶点索引等数据。绘制一个物体需要设置多种参数，例如绑定顶点缓冲区和索引缓冲区、绑定与物体有关的常量数据、设定图元类型以及指定参数。但随着场景中所绘制的物体数量和种类逐渐增多，如椭球体、球体、柱体等，我们便需要创建一个类来生成这些简单的几何体。</summary>
    
    
    
    <category term="Direct3D" scheme="http://www.zanple.top/categories/Direct3D/"/>
    
    
    <category term="C++" scheme="http://www.zanple.top/tags/C/"/>
    
    <category term="Direct3D" scheme="http://www.zanple.top/tags/Direct3D/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>DirectX11入门笔记-02-绘制正方体</title>
    <link href="http://www.zanple.top/2021/01/05/directx11-02-cube/"/>
    <id>http://www.zanple.top/2021/01/05/directx11-02-cube/</id>
    <published>2021-01-04T16:25:10.000Z</published>
    <updated>2021-03-06T09:50:28.291Z</updated>
    
    <content type="html"><![CDATA[<p>上一节中我们已经绘制出了2D的多边形，本节则从最简单的几何体——立方体的绘制开始<a id="more"></a></p><h1 id="1-顶点与索引"><a href="#1-顶点与索引" class="headerlink" title="1. 顶点与索引"></a>1. 顶点与索引</h1><p>正方体的绘制同样是立方体的<code>8个顶点</code>通过索引的方式进行绘制。与上一节绘制多边形不同的是，正方体的8个顶点处在不同平面，因此顶点需要储存在两个深度上。</p><div align=center><p><img src="image-1.png" alt="立方体顶点索引"></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置立方体顶点</span></span><br><span class="line">VertexPosColor vertices[] =</span><br><span class="line">&#123;</span><br><span class="line">&#123; XMFLOAT3(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), XMFLOAT4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>), XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">-1.0f</span>), XMFLOAT4(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), XMFLOAT4(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>), XMFLOAT4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">-1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>), XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>), XMFLOAT4(<span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>), XMFLOAT4(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>设置索引，将其分为<code>12个三角形</code>进行绘制。</p><div align=center><p><img src="image-2.png" alt="索引对应的三角形"></p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引数组</span></span><br><span class="line">DWORD indices[] = &#123;</span><br><span class="line"><span class="comment">//立方体前表面</span></span><br><span class="line"><span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,</span><br><span class="line"><span class="comment">//立方体后表面</span></span><br><span class="line"><span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>,</span><br><span class="line"><span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>,</span><br><span class="line"><span class="comment">//立方体左表面</span></span><br><span class="line"><span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>,</span><br><span class="line"><span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line"><span class="comment">//立方体右表面</span></span><br><span class="line"><span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>,</span><br><span class="line"><span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>,</span><br><span class="line"><span class="comment">//立方体上表面</span></span><br><span class="line"><span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line"><span class="number">1</span>, <span class="number">6</span>, <span class="number">2</span>,</span><br><span class="line"><span class="comment">//立方体下表面</span></span><br><span class="line"><span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>,</span><br><span class="line"><span class="number">4</span>, <span class="number">3</span>, <span class="number">7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时运行程序，在客户区并没有看到立方体。这是因为我们没有将顶点由局部坐标空间变换到齐次裁剪空间。</p><h1 id="2-常量缓冲区"><a href="#2-常量缓冲区" class="headerlink" title="2. 常量缓冲区"></a>2. 常量缓冲区</h1><p>因此我们需要创建<strong>常量缓冲区</strong>，其数据内容可供着色器程序使用。在<code>GameApp.h</code>中创建常量缓冲的结构体、指针和世界-观察-投影矩阵：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ConstantBuffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMMATRIX WorldViewProj; <span class="comment">//世界观察投影矩阵</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ComPtr&lt;ID3D11Buffer&gt; m_pConstantBuffer;    <span class="comment">//常量缓冲区</span></span><br><span class="line">DirectX::XMMATRIX m_world;</span><br><span class="line">DirectX::XMMATRIX m_view;</span><br><span class="line">DirectX::XMMATRIX m_proj;</span><br></pre></td></tr></table></figure><p>同样，我们需要构建一个常量缓冲区描述符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置常量缓冲区描述</span></span><br><span class="line">D3D11_BUFFER_DESC cbd;</span><br><span class="line">ZeroMemory(&amp;cbd, <span class="keyword">sizeof</span>(cbd));</span><br><span class="line">cbd.Usage = D3D11_USAGE_DYNAMIC;</span><br><span class="line">cbd.ByteWidth = <span class="keyword">sizeof</span>(ConstantBuffer);</span><br><span class="line">cbd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;</span><br><span class="line">cbd.CPUAccessFlags = D3D11_CPU_ACCESS_WRITE;</span><br><span class="line"><span class="comment">// 新建常量缓冲区，不使用初始数据</span></span><br><span class="line">m_pDevice-&gt;CreateBuffer(&amp;cbd, <span class="literal">nullptr</span>, m_pConstantBuffer.GetAddressOf());</span><br></pre></td></tr></table></figure><p>构建观察矩阵，用最新的世界-观察-投影矩阵来更新常量缓冲区。</p><blockquote><p>3D的部分包含了四大变换：世界变换、观察变换、投影变换和视口变换。其中前面三种变换需要在顶点着色器完成，必要时需要提供变换矩阵。而视口变换是在光栅化阶段完成的。</p><p><strong>注意</strong>：对于不同的物体，需要使用不同的世界变换矩阵；而对于同一个物体的所有顶点，都要使用一致的世界变换矩阵来变换。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构建观察矩阵</span></span><br><span class="line"><span class="keyword">static</span> XMVECTOR pos = XMVectorSet(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">-4.0f</span>, <span class="number">1.0f</span>);</span><br><span class="line"><span class="keyword">static</span> XMVECTOR target = XMVectorZero();</span><br><span class="line"><span class="keyword">static</span> XMVECTOR up = XMVectorSet(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>);</span><br><span class="line"></span><br><span class="line">m_world = XMMatrixIdentity();</span><br><span class="line">m_view = XMMatrixLookAtLH(pos, target, up);</span><br><span class="line">m_proj = XMMatrixPerspectiveFovLH(XM_PIDIV2, AspectRatio(), <span class="number">1.0f</span>, <span class="number">1000.0f</span>);</span><br><span class="line">XMMATRIX worldViewProj = m_world * m_view * m_proj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用最新的worldViewProj矩阵来更新常量缓冲区</span></span><br><span class="line">m_CBuffer.WorldViewProj = XMMatrixTranspose(worldViewProj);</span><br><span class="line">D3D11_MAPPED_SUBRESOURCE mappedData;</span><br><span class="line">m_pContext-&gt;Map(m_pConstantBuffer.Get(), <span class="number">0</span>, D3D11_MAP_WRITE_DISCARD, <span class="number">0</span>, &amp;mappedData);</span><br><span class="line">memcpy_s(mappedData.pData, <span class="keyword">sizeof</span>(m_CBuffer), &amp;m_CBuffer, <span class="keyword">sizeof</span>(m_CBuffer));</span><br><span class="line">m_pContext-&gt;Unmap(m_pConstantBuffer.Get(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>这里我们对世界-观察-投影坐标进行了转置<code>XMMatrixTranspose</code>，这是因为HLSL中使用的为<strong>列矩阵</strong>，而使用到的DirectXMath数学库中生成的矩阵都是<strong>行矩阵</strong>。如果没对行距阵进行转置，则需要在着色器中通过<code>row_major</code>标识指定为行距阵。</p><p>齐次坐标表示法中的第四个坐标w的取值将根据被描述对象是点还是向量而定：<strong>(x, y, z, 0)表示向量</strong>，<strong>(x, y, z, 1)表示点</strong>。</p><blockquote><p>DirectXMath中的常用矩阵：</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>XMMatrixScale</td><td>缩放矩阵</td></tr><tr><td>XMMatrixRotationX|XMMatrixRotationY|XMMatrixRotationZ</td><td>旋转矩阵</td></tr><tr><td>XMMatrixLookAtLH(<em>输入摄影机坐标</em>,<em>输入摄影机焦点坐标</em>,<em>输入摄影机上朝向坐标</em>)</td><td><em>输出视图变换矩阵</em></td></tr><tr><td>XMMatrixOrthographicLH(<em>待投影区域的宽度</em>,<em>待投影区域的高度</em>,<em>近平面</em>,<em>远平面</em>)</td><td>以原点为中心的正交投影矩阵</td></tr><tr><td>XMMatrixOrthographicOffCenterLH(<em>待投影区域的左边界</em>,<em>待投影区域的右边界</em>,<em>待投影区域的下边界</em>,<em>待投影区域的上边界</em>,<em>近平面</em>,<em>远平面</em>)</td><td>离心的正交投影矩阵</td></tr></tbody></table><p><a href="https://www.cnblogs.com/X-Jun/p/9041966.html">DirectX11 With Windows SDK–05 DirectXMath数学库</a></p></blockquote><h1 id="3-着色器"><a href="#3-着色器" class="headerlink" title="3. 着色器"></a>3. 着色器</h1><h2 id="3-1-着色器修改"><a href="#3-1-着色器修改" class="headerlink" title="3.1 着色器修改"></a>3.1 着色器修改</h2><p>完成常量缓冲区的创建后，对着色器的内容进行修改（主要是顶点着色器的内容），将顶点变换到齐次裁剪空间中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">cbuffer ConstantBuffer : <span class="keyword">register</span>(b0)</span><br><span class="line">&#123;</span><br><span class="line">    matrix gWorldViewProj; <span class="comment">//把顶点变换到齐次裁剪空间，由世界、视图、投影3种变换组合而成的矩阵</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexIn</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float3 posL : POSITION;</span><br><span class="line">    float4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    float4 posH : SV_POSITION;</span><br><span class="line">    float4 color : COLOR;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VertexOut <span class="title">VS</span><span class="params">(VertexIn vIn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    VertexOut vOut;</span><br><span class="line">    vOut.posH = mul(float4(vIn.posL, <span class="number">1.0f</span>), gWorldViewProj);</span><br><span class="line">    <span class="comment">//直接把顶点颜色传递到像素着色器</span></span><br><span class="line">    vOut.color = vIn.color; </span><br><span class="line">    <span class="keyword">return</span> vOut;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的如<code>PosW</code>、<code>PosH</code>这样带字母后缀的变量名，其字母表达了当前点或向量所处的空间：</p><table><thead><tr><th>字母后缀</th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>L</td><td>处于物体局部空间（Local Space）</td></tr><tr><td>W</td><td>处于世界空间（World Space）</td></tr><tr><td>V</td><td>处于观察空间（View Space）</td></tr><tr><td>H</td><td>处于齐次裁减空间（Homogeneous space）</td></tr></tbody></table><p>此时运行程序，便可以看到构建好的立方体绘制出来了。</p><div align=center><p><img src="image-3.png" alt="绘制立方体"></p></div><blockquote><p>不要在着色器内使用过多的常量缓冲区。根据[Thibieroz13]提出的建议，出于性能的考虑，常量缓冲区的数量应少于5个为宜。</p></blockquote><h2 id="3-2-常量缓冲区的封装规则"><a href="#3-2-常量缓冲区的封装规则" class="headerlink" title="3.2 常量缓冲区的封装规则"></a>3.2 常量缓冲区的封装规则</h2><p>在HLSL中，常量缓冲区会以<strong>补齐填充</strong>的方式将其中的元素都包装为4D向量，但每一个元素只能置于<strong>一个4D向量</strong>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如下面两个float3</span></span><br><span class="line">float3 Pos, Dir;</span><br><span class="line"><span class="comment">//会以下列方式封装在着色器的内存中</span></span><br><span class="line"><span class="built_in">vector</span> <span class="number">1</span> : (Pos.x, Pos.y, Pos.z, empty)</span><br><span class="line"><span class="built_in">vector</span> <span class="number">2</span> : (Dir.x, Dir.y, Dir.z, empty)</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/X-Jun/p/9376474.html#_lab2_1_0">总结</a>常量缓冲区的打包规则：<br><strong>1. C++中的结构体数据是以字节流的形式传输给HLSL的；</strong><br><strong>2. HLSL常量缓冲区中的向量不允许拆分；</strong><br><strong>3. HLSL常量缓冲区中多个相邻的变量若有空缺则优先打包进同一个4D向量中；</strong><br><strong>4. HLSL常量缓冲区中，结构体常量前面的所有常量都会被打包成4D向量，内部也进行打包操作，但结构体的最后一个成员可能会和后续的常量打包成4D向量；</strong><br><strong>5. 对于在常量缓冲区的数组，需要特殊对待，数组中的每一个元素都会独自打包，但对于最后一个元素来说如果后续的变量不是数组、结构体且还有空缺，则可以进行打包操作。</strong></p><p>所以避免出现潜在问题的办法如下：<br><strong>1. 若要使用数组，数组的类型最好能按16字节对齐</strong><br><strong>2. 结构体的总大小也需要按16字节对齐。</strong></p><h1 id="4-立方体旋转"><a href="#4-立方体旋转" class="headerlink" title="4. 立方体旋转"></a>4. 立方体旋转</h1><h2 id="4-1-立方体自动旋转"><a href="#4-1-立方体自动旋转" class="headerlink" title="4.1 立方体自动旋转"></a>4.1 立方体自动旋转</h2><p>立方体实现旋转比较简单，只需要更改立方体的坐标然后再更新常量缓冲区便可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> phi = <span class="number">0.0f</span>, theta = <span class="number">0.0f</span>;</span><br><span class="line">phi += <span class="number">0.0001f</span>, theta += <span class="number">0.0001f</span>;</span><br><span class="line">m_world = XMMatrixTranspose(XMMatrixRotationX(phi) * XMMatrixRotationY(theta));</span><br></pre></td></tr></table></figure><div align=center><p><img src="gif-1.gif" alt="立方体的旋转效果"></p></div><h2 id="4-2-通过鼠标-键盘旋转立方体"><a href="#4-2-通过鼠标-键盘旋转立方体" class="headerlink" title="4.2 通过鼠标/键盘旋转立方体"></a>4.2 通过鼠标/键盘旋转立方体</h2><h3 id="4-2-1-鼠标-键盘的消息响应函数"><a href="#4-2-1-鼠标-键盘的消息响应函数" class="headerlink" title="4.2.1 鼠标/键盘的消息响应函数"></a>4.2.1 鼠标/键盘的消息响应函数</h3><p>要通过鼠标/键盘控制立方体的旋转，首先需要实现鼠标/键盘的消息响应（即窗口能接收到鼠标/键盘操作的信息）。</p><p>这里直接使用DirectXTK提供的Mouse类和Keyboard类。</p><p>引入这两个类到工程文件后，需要对之前创建的D3DApp框架做一些调整。对于鼠标/键盘，我们除了获取鼠标键盘发出的信息外，还需要得到鼠标/键盘的状态信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键鼠输入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DirectX::<span class="built_in">Mouse</span>&gt; m_pMouse = <span class="built_in">std</span>::make_unique&lt;DirectX::<span class="built_in">Mouse</span>&gt;();<span class="comment">//鼠标</span></span><br><span class="line">DirectX::<span class="built_in">Mouse</span>::ButtonStateTracker m_MouseTracker;<span class="comment">//鼠标状态追踪器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DirectX::<span class="built_in">Keyboard</span>&gt; m_pKeyboard = <span class="built_in">std</span>::make_unique&lt;DirectX::<span class="built_in">Keyboard</span>&gt;(); <span class="comment">//键盘</span></span><br><span class="line">DirectX::<span class="built_in">Keyboard</span>::KeyboardStateTracker m_KeyboardTracker;<span class="comment">//键盘状态追踪器</span></span><br></pre></td></tr></table></figure><p>同时，我们还需要在D3DApp中处理鼠标/键盘的消息响应函数。</p><h3 id="4-2-2-更改立方体的信息"><a href="#4-2-2-更改立方体的信息" class="headerlink" title="4.2.2 更改立方体的信息"></a>4.2.2 更改立方体的信息</h3><p>在GameApp中对鼠标进行初始化，并设置鼠标模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m_pMouse-&gt;SetWindow(m_hMainWnd);</span><br><span class="line">m_pMouse-&gt;SetMode(DirectX::<span class="built_in">Mouse</span>::MODE_ABSOLUTE);</span><br></pre></td></tr></table></figure><p>这里将鼠标状态设置为了<code>MODE_ABSOLUTE</code>，鼠标模式有下面两种：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Mode</span><br><span class="line">&#123;</span><br><span class="line">    MODE_ABSOLUTE = <span class="number">0</span>,  <span class="comment">//绝对坐标模式，每次状态更新xy值为屏幕像素坐标，且鼠标可见</span></span><br><span class="line">    MODE_RELATIVE,      <span class="comment">//相对运动模式，每次状态更新xy值为每一帧之间的像素位移量，且鼠标不可见</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面立方体的自动旋转中，我们通过改变立方体的世界坐标来达到旋转的效果。对于鼠标，我们使用鼠标的偏移量作为旋转的距离；对于键盘， 我们使用按压持续时间来作为旋转的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> cubePhi = <span class="number">0.0f</span>, cubeTheta = <span class="number">0.0f</span>;</span><br><span class="line"><span class="comment">//获取鼠标状态</span></span><br><span class="line"><span class="built_in">Mouse</span>::State mouseState = m_pMouse-&gt;GetState();</span><br><span class="line"><span class="built_in">Mouse</span>::State lastMouseState = m_MouseTracker.GetLastState();</span><br><span class="line"><span class="comment">//获取键盘状态</span></span><br><span class="line"><span class="built_in">Keyboard</span>::State keyState = m_pKeyboard-&gt;GetState();</span><br><span class="line"><span class="built_in">Keyboard</span>::State lastKeyState = m_KeyboardTracker.GetLastState();</span><br><span class="line"><span class="comment">//更新鼠标按钮状态跟踪器，仅当鼠标按住的情况下才进行移动</span></span><br><span class="line">m_MouseTracker.Update(mouseState);</span><br><span class="line">m_KeyboardTracker.Update(keyState);</span><br><span class="line"><span class="comment">//根据鼠标的移动距离计算旋转角度</span></span><br><span class="line"><span class="keyword">if</span> (mouseState.leftButton == <span class="literal">true</span> &amp;&amp; m_MouseTracker.leftButton == m_MouseTracker.HELD)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//使场景中的每个像素按鼠标移动距离的0.01倍进行缩放</span></span><br><span class="line">cubeTheta -= (mouseState.x - lastMouseState.x) * <span class="number">0.01f</span>;</span><br><span class="line">cubePhi -= (mouseState.y - lastMouseState.y) * <span class="number">0.01f</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据键盘按键的时长计算旋转角度</span></span><br><span class="line"><span class="keyword">if</span> (keyState.IsKeyDown(<span class="built_in">Keyboard</span>::W))</span><br><span class="line">cubePhi += dt * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (keyState.IsKeyDown(<span class="built_in">Keyboard</span>::S))</span><br><span class="line">cubePhi -= dt * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (keyState.IsKeyDown(<span class="built_in">Keyboard</span>::A))</span><br><span class="line">cubeTheta += dt * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (keyState.IsKeyDown(<span class="built_in">Keyboard</span>::D))</span><br><span class="line">cubeTheta -= dt * <span class="number">2</span>;</span><br><span class="line">m_world = XMMatrixRotationY(cubeTheta) * XMMatrixRotationX(cubePhi);</span><br></pre></td></tr></table></figure><div align=center><p><img src="gif-2.gif" alt="鼠标控制立方体旋转"></p></div><hr><p>参考：</p><p>1.<a href="https://www.cnblogs.com/X-Jun/p/9032810.html">DirectX11 With Windows SDK–03 索引缓冲区、常量缓冲区</a></p><p>2.《DirectX 12 3D游戏开发实战 第6章&amp;附录B》</p><p>3.<a href="https://github.com/microsoft">microsoft</a>/<strong><a href="https://github.com/microsoft/DirectXTK">DirectXTK</a></strong></p><p>4.<a href="https://www.cnblogs.com/X-Jun/p/9034692.html">DirectX11 With Windows SDK–06 键盘和鼠标输入</a></p><p>5.<a href="https://www.cnblogs.com/X-Jun/p/9376474.html">DirectX11–深入理解HLSL常量缓冲区打包规则</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一节中我们已经绘制出了2D的多边形，本节则从最简单的几何体——立方体的绘制开始</summary>
    
    
    
    <category term="Direct3D" scheme="http://www.zanple.top/categories/Direct3D/"/>
    
    
    <category term="C++" scheme="http://www.zanple.top/tags/C/"/>
    
    <category term="Direct3D" scheme="http://www.zanple.top/tags/Direct3D/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>DirectX11入门笔记-01-绘制三角形</title>
    <link href="http://www.zanple.top/2021/01/04/directx11-01-triangle/"/>
    <id>http://www.zanple.top/2021/01/04/directx11-01-triangle/</id>
    <published>2021-01-04T08:12:21.000Z</published>
    <updated>2021-03-06T09:48:48.155Z</updated>
    
    <content type="html"><![CDATA[<p>在完成Direct3D的初始化后，我们可以运行便可得到一个带有FPS与帧时间的窗口。<a id="more"></a></p><div align=center><p><img src="image-1.png" alt="初始化"></p></div><blockquote><p>初始化部分分为Win32窗口的创建和Direct3D的初始化。</p><p>Win32部分可参考龙书附录或<a href="https://www.bilibili.com/video/BV1PV411Y7Sb">Win32 API高级编程教程</a>，Direct3D的初始化可参考龙书第四章或<a href="https://www.cnblogs.com/X-Jun/p/9069608.html">X-Jun的博客</a>。</p></blockquote><hr><h1 id="1-DirectX11中的渲染管线"><a href="#1-DirectX11中的渲染管线" class="headerlink" title="1. DirectX11中的渲染管线"></a>1. DirectX11中的渲染管线</h1><p>在开始绘制三角形前，先了解一下DirectX11中的渲染管线：</p><div align=center><p><img src="image-2.png" alt="说明绘制管道的功能块的关系图"></p></div><ol><li><strong>Input Assembler（输入装配器）</strong>：“输入装配器”阶段使用固定的函数操作从内存中读取顶点。 然后，输入汇编会形成几何基元，并创建管道工作项。 自动生成的顶点标识符、实例标识符 (可用于顶点着色器) ， (几何着色器或像素着色器可用的基元标识符) 启用特定于标识符的处理。 图中的虚线显示特定于标识符的处理流程。</li><li><strong>Vertex Shader（顶点着色器）</strong>：顶点着色器阶段使用一个顶点作为输入，并输出一个顶点。</li><li><strong>Hull Shader（外壳着色器）</strong>：此球面着色器每个修补程序运行一次。 可以将 “球面” 着色器与输入汇编程序提供的修补程序结合使用。 “球面” 着色器可以将构成修补程序的输入控制点转换为输出控制点。 可以对 fixed 函数细化器阶段执行其他设置。 例如，”球面” 着色器可以输出 tess 系数，这是指示进行分割的数量。</li><li><strong>Tessellator（细化器/细分曲面）</strong>：细化器是一个固定函数单元，其操作由 “球面” 着色器中的声明定义。细化器对每个由凸着色器输出的修补程序运行一次。外凸着色器会生成 tess 因素，这些因素是通知细化器多少到进行分割 (生成几何和连接性) 到修补程序域的数字。</li><li><strong>Domain Shader（域着色器）</strong>：每个顶点调用一次域着色器，这是由细化器生成的。每个调用都通过其在泛型域上的坐标进行标识。域着色器的作用是将此坐标转换为有形 (例如，3-d 空间中的一个点) 用于域着色器的下向下传递。 修补程序的每个域着色器调用还会访问所有的 “球面” 着色器输出的共享输入。</li><li><strong>Geometry Shader（几何着色器）</strong>：几何着色器阶段使用一个基元作为输入，输出零个、一个或多个基元。 输出基元包含的数据可能会超出几何着色器的可能数量。 每个操作的输出数据总量 (顶点大小 x 顶点计数) 。</li><li><strong>Stream Output（流输出）</strong>：流输出阶段将(基元)流连接起来，从而将几何图形着色器的输出传递到输出缓冲区。 流输出与几何图形着色器相关联，并且两者同时进行了编程。</li><li><strong>Rasterizer（光栅器）</strong>：光栅器阶段剪辑 (包括自定义剪辑边界) 基元，对基元执行透视划分，实现视区和剪选，执行呈现目标选择，并执行基元设置。</li><li><strong>Pixel Shader（像素着色器）</strong>：“像素着色器”阶段使用一个像素作为输入，并输出同一位置上的一个像素或无像素。 像素着色器无法读取当前渲染器目标。</li><li><strong>Output Merger（输出合并）</strong>：输出合并阶段执行固定的函数呈现-目标混合、深度和模具操作。</li></ol><h1 id="2-三角形绘制"><a href="#2-三角形绘制" class="headerlink" title="2. 三角形绘制"></a>2. 三角形绘制</h1><p>在初始化后完成框架的搭建后，D3DApp与GameTimer这两个类基本就不需要进行修改了。</p><p>项目框架结构如下</p><table><thead><tr><th>类名</th><th>功能</th></tr></thead><tbody><tr><td>Main</td><td>WinMain函数的入口，程序的主入口</td></tr><tr><td>D3DApp</td><td>Direct3D应用程序框架类</td></tr><tr><td>GameTimer</td><td>游戏计时器类</td></tr><tr><td>GameApp</td><td>游戏应用程序扩展类，游戏逻辑在这里实现，继承自D3DApp类</td></tr></tbody></table><h2 id="2-1-顶点与输入布局"><a href="#2-1-顶点与输入布局" class="headerlink" title="2.1 顶点与输入布局"></a>2.1 顶点与输入布局</h2><p>首先定义顶点的结构体：由位置和颜色信息注册。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexPosColor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DirectX::XMFLOAT3 pos;</span><br><span class="line">DirectX::XMFLOAT4 color;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> D3D11_INPUT_ELEMENT_DESC inputLayout[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>定义了顶点结构体之后，我们还需要向Direct3D提供该顶点结构体的描述，使它了解应怎样来处理结构体中的每个成员。用户提供给Direct3D的这种描述被成为<strong>输入布局描述</strong>(input layout description)，这里将输入布局描述中的D3D11_INPUT_ELEMENT_DESC设为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> D3D11_INPUT_ELEMENT_DESC GameApp::VertexPosColor::inputLayout[<span class="number">2</span>] = &#123;</span><br><span class="line">&#123; <span class="string">"POSITION"</span>, <span class="number">0</span>, DXGI_FORMAT_R32G32B32_FLOAT,<span class="number">0</span>, <span class="number">0</span>, D3D11_INPUT_PER_VERTEX_DATA, <span class="number">0</span>  &#125;,</span><br><span class="line">&#123; <span class="string">"COLOR"</span>,<span class="number">0</span>,DXGI_FORMAT_R32G32B32A32_FLOAT,<span class="number">0</span>,<span class="number">12</span>,D3D11_INPUT_PER_VERTEX_DATA, <span class="number">0</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着在GameApp::InitResource()中创建三角形顶点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建三角形顶点</span></span><br><span class="line">VertexPosColor vertices[] =</span><br><span class="line">&#123;</span><br><span class="line">&#123; XMFLOAT3(<span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>), XMFLOAT4(<span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.5f</span>), XMFLOAT4(<span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">1.0f</span>) &#125;,</span><br><span class="line">&#123; XMFLOAT3(<span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.5f</span>), XMFLOAT4(<span class="number">1.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>) &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在创建顶点布局前我们需要获取顶点着色器的编译文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ComPtr&lt;ID3DBlob&gt; pBlob;</span><br><span class="line">D3DReadFileToBlob(<span class="string">L"Shader\\Triangle_VS.cso"</span>, &amp;pBlob);</span><br><span class="line"><span class="comment">//创建顶点布局</span></span><br><span class="line">m_pDevice-&gt;CreateInputLayout(VertexPosColor::inputLayout, ARRAYSIZE(VertexPosColor::inputLayout),</span><br><span class="line">pBlob-&gt;GetBufferPointer(), pBlob-&gt;GetBufferSize(), m_pVertexLayout.GetAddressOf());</span><br></pre></td></tr></table></figure><p>最后我们需要将顶点布局绑定到渲染管线中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定顶点布局</span></span><br><span class="line">m_pContext-&gt;IASetInputLayout(m_pVertexLayout.Get());</span><br></pre></td></tr></table></figure><p>此外，我们还需要设置顶点的图元拓扑状态：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将基本拓扑设置为三角形列表（每组3个顶点）</span></span><br><span class="line">m_pContext-&gt;IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);</span><br></pre></td></tr></table></figure><p>基本图元拓扑分为多种类型，如下图（可参考<a href="https://docs.microsoft.com/zh-cn/windows/win32/direct3d11/d3d10-graphics-programming-guide-primitive-topologies">官方文档</a>或龙书5.5输入装配器阶段）：</p><div align=center><p><img src="image-6.png" alt="基本类型的顶点排序图"></p></div><h2 id="2-2-顶点缓冲区"><a href="#2-2-顶点缓冲区" class="headerlink" title="2.2 顶点缓冲区"></a>2.2 顶点缓冲区</h2><p>为了使GPU可以访问顶点数组，就需要把它们放在<strong>缓存区</strong>（buffer）的GPU资源里。此处我们创建存储顶点的缓冲区——顶点缓冲区，在创建缓冲区前我们先创建顶点缓冲区的描述并进行设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置顶点缓冲区描述</span></span><br><span class="line">D3D11_BUFFER_DESC vbd;</span><br><span class="line">ZeroMemory(&amp;vbd, <span class="keyword">sizeof</span>(vbd));</span><br><span class="line">vbd.BindFlags = D3D11_BIND_VERTEX_BUFFER;<span class="comment">//绑定为顶点缓存</span></span><br><span class="line">vbd.Usage = D3D11_USAGE_IMMUTABLE;</span><br><span class="line">vbd.ByteWidth = <span class="keyword">sizeof</span> vertices;</span><br><span class="line">vbd.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line">D3D11_SUBRESOURCE_DATA vsd;</span><br><span class="line">ZeroMemory(&amp;vsd, <span class="keyword">sizeof</span>(vsd));</span><br><span class="line">vsd.pSysMem = vertices;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建顶点缓冲区</span></span><br><span class="line">m_pDevice-&gt;CreateBuffer(&amp;vbd, &amp;vsd, m_pVertexBuffer.GetAddressOf());</span><br></pre></td></tr></table></figure><p>同样将顶点缓冲区绑定到渲染管线中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定顶点缓冲</span></span><br><span class="line">m_pContext-&gt;IASetVertexBuffers(<span class="number">0</span>, <span class="number">1</span>, m_pVertexBuffer.GetAddressOf(), &amp;stride, &amp;offset);</span><br></pre></td></tr></table></figure><p>在这里需要详细讲述一下<code>D3D11_USAGE</code>枚举类型对应的读写关系：</p><table><thead><tr><th></th><th align="center">CPU读</th><th align="center">CPU写</th><th align="center">GPU读</th><th align="center">GPU写</th></tr></thead><tbody><tr><td>D3D11_USAGE_DEFAULT</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center">√</td></tr><tr><td>D3D11_USAGE_IMMUTABLE</td><td align="center"></td><td align="center"></td><td align="center">√</td><td align="center"></td></tr><tr><td>D3D11_USAGE_DYNAMIC</td><td align="center"></td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td>D3D11_USAGE_STAGING</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><blockquote><p>对于<code>D3D11_USAGE_DEFAULT</code>类型的缓冲区，应当使用 <code>ID3D11DeviceContext::UpdateSubresource</code>方法来更新缓冲区资源，它的原理是将内存中的某段数据传递到显存中，然后再将该显存中的数据复制到在显存中的缓冲区。这种更新方式我们是无法直接访问缓冲区的内容的。在绘制完成/开始前调用可以比较快地更新显存中的数据。</p><p>而对于<code>D3D11_USAGE_DYNAMIC</code>类型的缓冲区，则应当使用<code>ID3D11DeviceContext::Map</code>和<code>ID3D11DeviceContext::Unmap</code>方法，将显存中的数据映射到内存中，然后修改该片内存的数据，最后将修改好的数据映射回显存中。这种更新方式我们是可以直接获取来自显存的数据的，但代价就是更新的效率会比上面的方式更低一些。</p></blockquote><h2 id="2-3-着色器"><a href="#2-3-着色器" class="headerlink" title="2.3 着色器"></a>2.3 着色器</h2><p>绘制三角形前，我们需要创建两个着色器：顶点着色器和像素着色器。</p><p>在编译着色器前先对Shader文件的属性进行设置：</p><div align=center><p><img src="image-3.png" alt="确保着色器的类型为创建的着色器类型"></p></div><p>并更改着色器的输出文件：</p><div align=center><p><img src="image-5.png" alt="着色器的输出文件"></p></div><p>另外，可以安装Visual Studio的HLSL插件实现着色器代码的高亮等：</p><div align=center><p><img src="image-4.png" alt="HLSL插件"></p></div><h3 id="2-3-1-顶点着色器"><a href="#2-3-1-顶点着色器" class="headerlink" title="2.3.1 顶点着色器"></a>2.3.1 顶点着色器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VSOut</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">float3 color : Color;</span><br><span class="line">float4 pos : SV_Position;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cbuffer CBuf</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//标明这个矩阵是按行排列的，缺点是GPU计算行矩阵的速度比列矩阵慢</span></span><br><span class="line"><span class="comment">//CPU和GPU对矩阵的排列方式不一样，正确的做法应该是将其转置</span></span><br><span class="line">row_major matrix transform; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">VSOut <span class="title">main</span><span class="params">(float2 pos : POSITION, float3 color : COLOR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">VSOut vso;</span><br><span class="line">vso.color = color;</span><br><span class="line"><span class="keyword">return</span> vso;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-像素着色器"><a href="#2-3-2-像素着色器" class="headerlink" title="2.3.2 像素着色器"></a>2.3.2 像素着色器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">main</span><span class="params">(float3 color : Color)</span> : SV_TARGET <span class="comment">//像素着色器无需指定每个像素的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> float4(color, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-3-着色器语义"><a href="#2-3-3-着色器语义" class="headerlink" title="2.3.3 着色器语义"></a>2.3.3 着色器语义</h3><p>上述着色器用到了几个HLSL的语义：</p><table><thead><tr><th>语义名</th><th>具体含义</th></tr></thead><tbody><tr><td>POSITION</td><td>描述该变量是一个坐标点</td></tr><tr><td>SV_POSITION</td><td>说明该顶点的位置在从顶点着色器输出后，后续的着色器都不能改变它的值，作为光栅化时最终确定的像素位置</td></tr><tr><td>COLOR</td><td>描述该变量是一个颜色</td></tr><tr><td>SV_Target</td><td>说明输出的颜色值将会直接保存到渲染目标视图的后备缓冲区对应位置</td></tr></tbody></table><h3 id="2-3-4-着色器的创建和绑定"><a href="#2-3-4-着色器的创建和绑定" class="headerlink" title="2.3.4 着色器的创建和绑定"></a>2.3.4 着色器的创建和绑定</h3><p>完成Shader文件后需要在GameApp中进行创建与绑定：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ComPtr&lt;ID3DBlob&gt; pBlob;</span><br><span class="line"><span class="comment">//创建顶点着色器</span></span><br><span class="line">D3DReadFileToBlob(<span class="string">L"Shader\\Triangle_VS.cso"</span>, &amp;pBlob);</span><br><span class="line">m_pDevice-&gt;CreateVertexShader(pBlob-&gt;GetBufferPointer(), pBlob-&gt;GetBufferSize(), <span class="literal">nullptr</span>, m_pVertexShader.GetAddressOf());</span><br><span class="line"><span class="comment">//创建像素着色器</span></span><br><span class="line">D3DReadFileToBlob(<span class="string">L"Shader\\Triangle_PS.cso"</span>, &amp;pBlob);</span><br><span class="line">m_pDevice-&gt;CreatePixelShader(pBlob-&gt;GetBufferPointer(), pBlob-&gt;GetBufferSize(), <span class="literal">nullptr</span>, m_pPixelShader.GetAddressOf());</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定着色器</span></span><br><span class="line">m_pContext-&gt;VSSetShader(m_pVertexShader.Get(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">m_pContext-&gt;PSSetShader(m_pPixelShader.Get(), <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>至此，完成三角形的绘制。</p><div align=center><p><img src="image-7.png" alt="三角形的绘制"></p></div><h1 id="3-多边形的绘制（拓展）"><a href="#3-多边形的绘制（拓展）" class="headerlink" title="3. 多边形的绘制（拓展）"></a>3. 多边形的绘制（拓展）</h1><div align=center><p><img src="image-8.png" alt="多边形"></p></div><p>如果需要绘制上图这样一个多边形，先将其拆分为多个三角形。</p><div align=center><p><img src="image-9.png" alt="多边形拆分"></p></div><p>对于这样一个由多个三角形组成的多边形，如果按照上面画三角形的思路：将每一个三角形的顶点存储到顶点缓存中，再对每一个三角形进行绘制。这样虽然也能够绘制出多边形，但是有很多重复的顶点。</p><div align=center><p><img src="image-10.png" alt="重复顶点"></p></div><p>因此引入索引的概念，对于上面这个多边形，我们只存储其外圈6个顶点。并根据每个顶点的存储顺序创建索引，并根据索引来绘制每个三角形。</p><div align=center><p><img src="C:%5CUsers%5CZanple%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210104235449127.png" alt="多边形索引"></p></div><p>与顶点相似，为了使GPU可以访问索引数组，构建一个存储索引的缓冲区——索引缓冲区，并创建一个索引缓冲区描述并将其绑定到渲染流水线上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//索引数组</span></span><br><span class="line">DWORD indices[] = &#123;</span><br><span class="line"><span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line"><span class="number">0</span>,<span class="number">4</span>,<span class="number">1</span>,</span><br><span class="line"><span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设置索引缓冲区描述</span></span><br><span class="line">D3D11_BUFFER_DESC ibd;</span><br><span class="line">ZeroMemory(&amp;ibd, <span class="keyword">sizeof</span>(ibd));</span><br><span class="line">ibd.Usage = D3D11_USAGE_IMMUTABLE;</span><br><span class="line">ibd.ByteWidth = <span class="keyword">sizeof</span> indices;</span><br><span class="line">ibd.BindFlags = D3D11_BIND_INDEX_BUFFER;</span><br><span class="line">ibd.CPUAccessFlags = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//新建索引缓冲区</span></span><br><span class="line">vsd.pSysMem = indices;</span><br><span class="line">m_pDevice-&gt;CreateBuffer(&amp;ibd, &amp;vsd, m_pIndexBuffer.GetAddressOf());</span><br><span class="line"><span class="comment">//绑定索引缓冲</span></span><br><span class="line">m_pContext-&gt;IASetIndexBuffer(m_pIndexBuffer.Get(), DXGI_FORMAT_R32_UINT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>再将绘制函数改为索引绘制即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制多边形</span></span><br><span class="line">m_pContext-&gt;DrawIndexed(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><div align=center><p><img src="image-11.png" alt="绘制多边形"></p></div><hr><p>参考：</p><p>1.<a href="https://www.cnblogs.com/X-Jun/p/9031959.html">DirectX11 With Windows SDK–02 顶点/像素着色器的创建、顶点缓冲区</a></p><p>2.<a href="https://www.youtube.com/channel/UCsyHonfwHi4fLb2lkq0DEAA">Beginner C++ Game Programming Tutorial 0 DirectX</a></p><p>3.《DirectX 12 3D游戏开发实战 第4章》</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在完成Direct3D的初始化后，我们可以运行便可得到一个带有FPS与帧时间的窗口。</summary>
    
    
    
    <category term="Direct3D" scheme="http://www.zanple.top/categories/Direct3D/"/>
    
    
    <category term="C++" scheme="http://www.zanple.top/tags/C/"/>
    
    <category term="Direct3D" scheme="http://www.zanple.top/tags/Direct3D/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>游戏资源常见贴图类型</title>
    <link href="http://www.zanple.top/2020/10/01/gaming-texture/"/>
    <id>http://www.zanple.top/2020/10/01/gaming-texture/</id>
    <published>2020-10-01T08:10:37.000Z</published>
    <updated>2021-03-04T04:48:01.359Z</updated>
    
    <content type="html"><![CDATA[<p>游戏模型制作中用到了很多贴图类型，通过不同类型贴图的组合使用以达到最终需要得到的模型效果。最常见的类型有<strong>Diffuse</strong>、<strong>Emissive</strong>、<strong>Normal</strong>、<strong>Opacity</strong>、<strong>Specular</strong>、<strong>Roughness</strong>。游戏制作中根据项目资产的需要使用不同的贴图类型。<a id="more"></a></p><p><img src="2workflow.jpg" alt="金属/粗糙度和高光反射/光泽度工作流程"></p><p>在基于物理纹理的渲染（PBR）中，有两种最常见的工作流程，即<em>金属/粗糙度</em>和<em>高光反射/光泽度</em>。在使用过程中，两种工作流程各有利弊（详见<a href="https://academy.substance3d.com/courses/the-pbr-guide-part2-zh">PBR-Guide</a>）。</p><hr><h1 id="1-颜色贴图"><a href="#1-颜色贴图" class="headerlink" title="1. 颜色贴图"></a>1. 颜色贴图</h1><p>颜色贴图主要为Diffuse、Albedo、Base Color三种。一般认为这三者是等同的。</p><h2 id="1-1-Diffuse"><a href="#1-1-Diffuse" class="headerlink" title="1.1 Diffuse"></a>1.1 Diffuse</h2><p>光照模型在Lambertian（兰伯特材质球）着色器中会把颜色贴图叫做<strong>Diffuse Map</strong>（也叫颜色贴图），通常在绘制这张Diffuse Map的时候会把物体的结构阴影信息也绘制进去。在传统工作流中，Diffuse Map是带着光影信息的。</p><p><img src="Diffuse.jpg" alt="不同工作流中的Diffuse"></p><p><strong>Diffuse Map</strong>（漫反射颜色）应该表示物体表面的颜色，在Unity中叫做Albedo。在Specular/Glossiness工作流程中，对于金属材质而言它没有漫反射(或者说比较少)，所以使用黑色来填充。而非金属材质反射光少于金属材质，并且它折射的光只有较少的吸收通常重新折射回表面，因此对于非金属材质，使用的是漫反射颜色来填充。<strong>需要特别注意的是，漫反射纹理不应该包含任何光照信息，因为将基于（环境）添加光照到物体的纹理上。</strong></p><h2 id="1-2-Albedo"><a href="#1-2-Albedo" class="headerlink" title="1.2 Albedo"></a>1.2 Albedo</h2><p>主要体现模型的纹理和颜色。Unity的Shader（着色器）中，把颜色贴图叫做<strong>Albedo</strong>。</p><h2 id="1-3-Base-Color"><a href="#1-3-Base-Color" class="headerlink" title="1.3 Base Color"></a>1.3 Base Color</h2><p><strong>Base Color</strong>是把颜色贴图剔除光影变化后，我们看到的最基础的颜色。在PBR工作流中颜色贴图叫做Base Color， 其中包含了<em>电介质的反射颜色</em>和金属的反射率值这两种类型的数据。因为Base Color Map中带了金属的反射率值，所以需要配合上Metallic Map一起使用的。</p><blockquote><p><img src="BaseColorandDiffuse.jpg" alt="BaseColor和Diffuse"></p><p>比较容易造成混淆的是<strong>金属/粗糙度</strong>工作流中的Base Color和<strong>高光反射/光泽度</strong>工作流中的Diffuse(Albedo)的区别，两种工作流使用了不同的贴图方法来处理颜色。实际上，<strong>金属/粗糙度工作流中的Base Color本质上是高光反射/光泽度工作流中的Diffuse和Specular的结合</strong>，这也是有时候通过先创建金属/粗糙度材质再将其转化为高光反射/光泽度的原因之一。</p><div align=center><p><img src="TextureMapComparison.gif" alt="BaseColor包含了Diffuse中的介电材质值和Specular中的金属材质值"></p></div><p>在高光反射/光泽度工作流中，Diffuse贴图严格影响着材质的基本颜色而对材质的其他特征（如发射率）没有影响。对于介电材质而言，其材质颜色来自Diffuse贴图；对于金属材质而言，大部分颜色来自Specular高光贴图。</p><p>在金属/粗糙度工作流中，BaseColor贴图实则包含了漫反射和高光贴图的信息。而Metallic贴图这决定了有多少BaseColor被解释为漫反射或者高光。</p></blockquote><h2 id="1-4-Gradient-amp-Ramp、ColorLUT"><a href="#1-4-Gradient-amp-Ramp、ColorLUT" class="headerlink" title="*1.4 Gradient&amp;Ramp、ColorLUT"></a>*1.4 Gradient&amp;Ramp、ColorLUT</h2><p><strong>Gradient&amp;Ramp Map</strong>（渐变图）和ColorLUT（颜色查找表）也可以认为是颜色贴图的一种，这类贴图通过在一维或二维的方式将一种颜色映射到另一种颜色。且通常作为全局资源使用（不是特定于某一模型）。</p><div align=center><p><img src="TeamFortress2.jpg" alt="使用渐变纹理来控制漫反射光照"></p></div><p>Valve在<a href="https://cdn.cloudflare.steamstatic.com/apps/valve/2007/NPAR07_IllustrativeRenderingInTeamFortress2.pdf">Team Fortress 2</a>中使用渐变纹理来控制漫反射光照，渲染游戏中具有插画风格的角色。</p><p><img src="ColorLUT.jpg" alt="ColorLUT"></p><p>ColorLUT是预先生成的一张结果纹理，可用于优化复杂光照的渲染，如皮肤、毛发等。</p><h1 id="2-凹凸贴图"><a href="#2-凹凸贴图" class="headerlink" title="2. 凹凸贴图"></a>2. 凹凸贴图</h1><p>凹凸贴图主要为<strong>Bump</strong>、<strong>Normal</strong>和<strong>Displacement</strong>三种，三种贴图都是为模型提供更多的细节。其中Displacement有时用于改变模型的顶点位置（作为Parallax视差贴图使用），而Bump和Normal则<strong>不会</strong>改变模型的顶点位置。</p><p><img src="bumpnordis.jpg" alt="凹凸贴图对比"></p><p><em>就实现复杂度/质量与性能开销而言，Dispalcement&gt;Normal&gt;Bump(&gt;Reflection)。</em></p><h2 id="2-1-Bump"><a href="#2-1-Bump" class="headerlink" title="2.1 Bump"></a>2.1 Bump</h2><p><strong>Bump Map</strong>（凹凸贴图 ）是一个类似于法线贴图的概念，有时也称为<strong>Height</strong>（高度图）。但是凹凸贴图只包含高度信息而不包含角度信息。凹凸贴图的优点是可以很直观地看出模型表面的凹凸情况（颜色越浅表明该位置的表面越像外凸起，反之亦然），但是计算更复杂，因此更性能开销更大。高度图通常与法线贴图结合使用，用于给出表面凹凸的额外信息。</p><blockquote><p>Substance Painter、Substance Designer导出的Height高度图等同于Bump凹凸贴图，而不是Displacement置换贴图的信息。</p></blockquote><h2 id="2-2-Normal"><a href="#2-2-Normal" class="headerlink" title="2.2 Normal"></a>2.2 Normal</h2><p><strong>Normal Map</strong>（法线贴图）是凹凸映射技术的另一种应用。法线贴图包含角度信息而不包含任何高度信息，其R、G、B三个通道储存的信息表示了斜面的方向和陡峭程度。</p><p><img src="softedge.jpg" alt="法线贴图与凹凸贴图对比"></p><p>这一特征使得我们可以使用法线贴图储存的角度信息来柔化尖锐的边缘（仅使用Bump高度信息无法做到这一点，因为只有高度信息无法知道边缘应该沿着哪个方向弯曲）。柔化边缘不仅可以让物体看起来更真实，还能进一步突出物体的形状（尤其是在游戏对象在屏幕上占比较小的时候）。</p><p><img src="3normal.jpg" alt="不同空间下的法线贴图"></p><p>由于法线贴图存储的是表面的法线方向，而方向是相对于坐标空间而言的。因此存在三种不同的空间法线贴图：<em>Tangent切线空间</em>、<em>Object对象空间</em>、<em>World世界空间</em>，三种法线贴图都有各自的优缺点且能达到相同的效果，只是计算方式有所不同。</p><h3 id="2-2-1-Tangent-Space"><a href="#2-2-1-Tangent-Space" class="headerlink" title="2.2.1 Tangent Space"></a>2.2.1 Tangent Space</h3><p><img src="TanNormal.jpg" alt="切线空间下的法线贴图"></p><p><strong>Tangent Space</strong>（切线空间），顾名思义，切线空间法线是基于每个面的切线方向。切线空间下的法线贴图是最常见的法线贴图形式，大部分看起来都是浅蓝紫色的。其中，<strong>B通道</strong>表示法线方向的斜率；<strong>R通道</strong>表示左右切线方向的斜率；<strong>G通道</strong>表示切线方向向上或向下的斜率（<strong>OpenGl向上，DirectX向下</strong>）。</p><h3 id="2-2-2-Object-Space"><a href="#2-2-2-Object-Space" class="headerlink" title="2.2.2 Object Space"></a>2.2.2 Object Space</h3><p><img src="ObjNormal.jpg" alt="模型空间下的法线贴图"></p><p><strong>Object Space</strong>（对象空间或模型空间）法线贴图基于整个对象而不是每个面，大部分看起来都是五颜六色的。对象空间法线贴图在渲染上较快，但由于其无法镜像任何UV，在对称模型上会浪费大量纹理空间，且无法进行UV动画。因此在很多情况下切线空间较优于对象空间。</p><h3 id="2-2-3-World-Space"><a href="#2-2-3-World-Space" class="headerlink" title="2.2.3 World Space"></a>2.2.3 World Space</h3><div align=center><p><img src="WldNormal.png" alt="世界空间下的法线贴图"></p></div><p><strong>World Space</strong>（世界空间）是基于全局坐标的法线贴图，也是三种法线贴图中最不灵活的一种。 这种类型的法线贴图一般仅用于环境这类大型，静态和非对称的物体，或者临时用于诸如Substance Painter、Substance Designer之类软件中作为计算特殊效果（如风化效果）的一种方法。</p><h2 id="2-3-Displacement"><a href="#2-3-Displacement" class="headerlink" title="2.3 Displacement"></a>2.3 Displacement</h2><p><strong>Displacement Map</strong>（置换贴图，也叫移位贴图）可以改变模型对象的几何形状，因此在提供最真实的效果的同时也会大幅增加渲染性能的开销。</p><p><img src="rocksdisp.jpg" alt="置换贴图效果"></p><p>置换贴图能实现很多仅仅通过Bump和Normal无法实现的效果（尤其是模型对象的轮廓表现）。</p><div align=center><p><img src="image05.jpg" alt="结合凹凸贴图使用"></p></div><p>置换贴图也常作为高度图来生成地形，并结合凹凸贴图实现丰富的地形效果。</p><h3 id="2-3-1-Parallax-Map"><a href="#2-3-1-Parallax-Map" class="headerlink" title="2.3.1 Parallax Map"></a>2.3.1 Parallax Map</h3><p>置换贴图的另一个用途是作为<strong>Parallax Map</strong>（视差贴图，也称为Virtual Displacement Map虚拟置换贴图）使用。</p><p>![视差贴图效果](Comparison Parallax.png)</p><p>视差贴图是一种更高级的技术，能够提供比凹凸贴图更多的深度。视差贴图通过偏移每个像素的纹理坐标以达到更好的视觉表现，但仍不如性能开销更大的<strong>Relief Map</strong>（浮雕贴图）。</p><h3 id="2-3-2-Relief-Map"><a href="#2-3-2-Relief-Map" class="headerlink" title="2.3.2 Relief Map"></a>2.3.2 Relief Map</h3><p><strong>Relief Map</strong>（浮雕贴图，也称为Parallax Occlusion Map视差遮挡贴图）能够实现比视差贴图更深的凹凸深度，并能实现自阴影和遮挡效果。</p><div align=center><p><img src="CrysisParallax.jpg" alt="孤岛危机中的浮雕映射效果"></p></div><h3 id="2-3-3-Vector-Displacement"><a href="#2-3-3-Vector-Displacement" class="headerlink" title="2.3.3 Vector Displacement"></a>2.3.3 Vector Displacement</h3><p><strong>Vector Displacement Map</strong>（矢量置换贴图）是高度贴图的扩展，与传统Displacement（置换贴图）不同的是矢量置换贴图记录了模型上各点的高度和方向信息，并储存为16/32位浮点颜色信息。</p><p><img src="VectorDisp02.jpg" alt="矢量置换贴图与传统置换贴图"></p><p>传统的置换贴图使用的是低模的UV坐标，贴图记录了高模和低模之间的差异。而矢量置换贴图在使用类似映射方法的同时，而另一个模型最近的顶点之间的距离，还能在空间中移动顶点。因此也能记录复杂的凹面下（如蘑菇、耳朵等）的顶点信息，将雕刻细节从一个模型转移到另一个模型。</p><h1 id="3-反射贴图"><a href="#3-反射贴图" class="headerlink" title="3. 反射贴图"></a>3. 反射贴图</h1><p>与颜色贴图中的Diffuse和Base Color一样，反射贴图中根据工作流的不同也有不一样的贴图类型。</p><h2 id="3-1-Metal-Roughness"><a href="#3-1-Metal-Roughness" class="headerlink" title="3.1 Metal - Roughness"></a>3.1 Metal - Roughness</h2><p><img src="MetRoug.jpg" alt="金属/粗糙度工作流"></p><p>在<em>金属/粗糙度</em>工作流中，使用的反射贴图为<strong>Metallic</strong>和<strong>Roughness</strong>。</p><h3 id="3-1-1-Metallic"><a href="#3-1-1-Metallic" class="headerlink" title="3.1.1 Metallic"></a>3.1.1 Metallic</h3><p><strong>Metallic</strong>（金属贴图）起到类似于蒙版的作用，区分固有色贴图中的金属和绝缘体数据。在金属性贴图中，0（黑色-0 sRGB）表示绝缘体，而1（白-255 sRGB）表示金属。</p><div align=center><p><img src="Metallic.jpg" alt="金属贴图"></p></div><p><strong>金属贴图的运行方式类似于掩码的运作方式，因为该贴图向着色器阐释如何分析基础色中的数据。</strong>金属感对象的光泽度由粗糙度控制。 材质越粗糙，其光泽度就会越低， 而缺少粗糙度将使金属显得非常有光泽。</p><h3 id="3-1-2-Roughness"><a href="#3-1-2-Roughness" class="headerlink" title="3.1.2 Roughness"></a>3.1.2 Roughness</h3><p><strong>Roughness</strong>（粗糙度贴图）定义材质得粗糙度信息，0（黑色-0 sRGB）表示光滑，1（白-255 sRGB）表示粗糙。粗粗糙度是指造成光漫射的表面不规则状况，反射方向根据表面粗糙度自由变化。这改变了光的方向，但是光强度保持恒定不变。表面越粗糙，高光越散越暗。表面越光滑，高光反射集中，尽管反射的光的总量是一点的，表面也会更亮，光会更强。</p><p>粗糙度贴图采样得来的粗糙度数值会影响一个表面的微平面统计学上的取向度。一个比较粗糙的表面会得到更宽阔更模糊的镜面反射（高光），而一个比较光滑的表面则会得到集中而清晰的镜面反射。</p><div align=center><p><img src="Roughness.jpg" alt="粗糙度贴图"></p></div><p>Roughness粗糙度贴图 与Glossiness Map光泽度贴图是<strong>相反的</strong>。Roughness 反向就变成Glossiness Map 。</p><h2 id="3-2-Specular-Glossiness"><a href="#3-2-Specular-Glossiness" class="headerlink" title="3.2 Specular - Glossiness"></a>3.2 Specular - Glossiness</h2><p><img src="SpeGlos.jpg" alt="高光反射/光泽度工作流"></p><p>在<em>高光反射/光泽度</em>工作流中，使用的反射贴图为<strong>Specular</strong>和<strong>Glossiness</strong>。</p><h3 id="3-2-1-Specular"><a href="#3-2-1-Specular" class="headerlink" title="3.2.1 Specular"></a>3.2.1 Specular</h3><p><strong>Specular</strong>（高光贴图）表示高光得范围、强度、颜色，在<strong>Specular工作流中，</strong>颜色越亮高光越强，黑色表示没有高光。</p><div align=center><p><img src="Specular.jpg" alt="高光贴图"></p></div><p>高光反射规定了金属的反射率值和非金属的F0。使用RGB贴图可以在贴图中创建不同反射率的电介质材质。</p><p><strong>高光度也可影响材质的光泽度。</strong> 将“高光度（Specular）”值调整到接近1时，将使材质的反射和反射高光显得特别强特别显眼， 而将该值减小到接近0会弱化反射及反射高光，直到它们几乎不存在为止。</p><p><strong>高光度（Specular）也深受粗糙度影响。</strong> 即使“高光度（Specular）”输入设置为1，通过将“粗糙度（Roughness）”的值设置为1，也可以取消高光度效果。 另外，如果启用了金属感，那么调整高光度不会影响材质。</p><h3 id="3-2-2-Glossiness"><a href="#3-2-2-Glossiness" class="headerlink" title="3.2.2 Glossiness"></a>3.2.2 Glossiness</h3><p><strong>Glossiness</strong>（缩写Gloss，光泽度贴图），定义材质得粗糙度信息，跟Roughness相反，0（黑色-0 sRGB）表示粗糙，1（白-255 sRGB）表示光滑。</p><div align=center><p><img src="Glossiness.jpg" alt="光泽度贴图"></p></div><p>光泽度无非是指表面反射光线的能力。 表面能够反射的光线越多，光泽度越高。 表面能够反射的光线越少，光泽度越低。 表面反射光线的能力受环境中各种因素的影响，例如落在对象上的那些非常小颗粒的灰尘，以及接触对象时从手上沾染到对象上的油污， 所有这一切都会影响表面反射光线的能力。</p><h2 id="3-3-Anisotropic-Map"><a href="#3-3-Anisotropic-Map" class="headerlink" title="*3.3 Anisotropic Map"></a>*3.3 Anisotropic Map</h2><div align=center><p><img src="brushmore.jpg" alt="各向异性贴图"></p></div><p><strong>Anisotropic Map</strong>（各向异性贴图）是一种特殊的反射贴图。拉丝金属通常具有各向异性的高光，这是由表面的微划痕引起的。有时使用各项异性贴图去制作拉丝金属的效果。</p><h1 id="4-结构贴图"><a href="#4-结构贴图" class="headerlink" title="4. 结构贴图"></a>4. 结构贴图</h1><h2 id="4-1-Ambient-Occlusion"><a href="#4-1-Ambient-Occlusion" class="headerlink" title="4.1 Ambient Occlusion"></a>4.1 Ambient Occlusion</h2><p><strong>Ambient Occlusion</strong>（AO，环境光遮蔽贴图）描述了较大尺度的光线遮蔽信息，通常由高模烘培得到。指表面某点能获得多少环境中的光，用来模拟物体之间所产生的阴影，在不打光的时候增加体积感。</p><p>比如我们有一个砖块表面，反照率纹理上的砖块裂缝部分应该没有任何阴影信息。然而AO贴图则会把那些光线较难逃逸出来的暗色边缘指定出来。在光照的结尾阶段引入环境遮蔽可以明显的提升你场景的视觉效果。</p><p><img src="AO.jpg" alt="AO图"></p><p>环境光遮蔽贴图基于物体与其他物体越接近的区域，受到反射光线的照明越弱这一现象来模拟现实照明的一部分效果。<strong>该贴图只影响漫反射分配，不影响高光反射分配。</strong></p><h2 id="4-2-Cavity"><a href="#4-2-Cavity" class="headerlink" title="4.2 Cavity"></a>4.2 Cavity</h2><p><strong>Cavity Map</strong>（缝隙图）描述了比AO图更小尺度的光线遮蔽信息，通常由高模或者法线贴图烘培得到。</p><p><img src="Cav.jpg" alt="缝隙图"></p><p>缝隙图只包含模型对象表面的凹面区域而不包括凸面区域，因此缝隙图通常大部分都是白色的，只有凹陷区域是深色的。<strong>与AO图不同的是，缝隙图影响不仅会影响漫反射，还会影响高光反射部分。</strong></p><h2 id="4-3-Bent-Normal"><a href="#4-3-Bent-Normal" class="headerlink" title="4.3 Bent Normal"></a>4.3 Bent Normal</h2><p><strong>Bent Normal Map</strong>（环境法线贴图）有助于减少照明构建之后发生的漏光现象。</p><p><img src="BentNormal.jpg" alt="环境法线贴图"></p><p>环境法线贴图能够和AO图结合使用以改善漫反射间接照明，通过将环境发现代替法线用于间接照明来使漫反射间接照明更接近于全局光照。</p><h2 id="4-4-Curvature"><a href="#4-4-Curvature" class="headerlink" title="4.4 Curvature"></a>4.4 Curvature</h2><p><strong>Curvature</strong>（曲率贴图）是存储网格的凸度/凹度的纹理，可用于遮盖表面会出现更多磨损的地方或可能发生次表面散射的地方（凸面），可能积累更多污垢（凹面）的地方，以检查表面的连续性等。</p><p><img src="Cur.jpg" alt="曲率贴图"></p><p>曲率贴图允许提取和存储凹凸信息。黑色的值代表了凹区域，白色的值代表了凸区域，灰色值表示中性/平坦区域。。</p><h2 id="4-5-Thickness"><a href="#4-5-Thickness" class="headerlink" title="4.5 Thickness"></a>4.5 Thickness</h2><p><strong>Thickness</strong>（厚度贴图）记录了表面厚度信息，可以用于辅助制作表面散射(SSS，简称3S材质)材质，或直接扩散/反照率假装SSS的效果。 </p><p><img src="Thi.jpg" alt="厚度贴图"></p><p>其黑色代表薄的地方、白色代表厚的地方。</p><h1 id="5-光照与环境贴图"><a href="#5-光照与环境贴图" class="headerlink" title="5. 光照与环境贴图"></a>5. 光照与环境贴图</h1><h2 id="5-1-Light-Map"><a href="#5-1-Light-Map" class="headerlink" title="5.1 Light Map"></a>5.1 Light Map</h2><p><strong>Light Map</strong>（光照贴图）用来存储预渲染的光照信息，用于静态模型上的间接光照，解决实时动态光源效果不好且消耗性能的问题。</p><div align=center><p><img src="Lightmapping.jpg" alt="光照贴图"></p></div><p>光照贴图通常存储了静态烘培光源的颜色和亮度，由于光照贴图是预渲染的，因此可以使用如光能传递等非实时方法来得到更真实的效果。</p><h2 id="5-2-Spherical-Environment-Map"><a href="#5-2-Spherical-Environment-Map" class="headerlink" title="5.2 Spherical Environment Map"></a>5.2 Spherical Environment Map</h2><p><strong>Spherical Environment Map</strong>（球面环境贴图）是最简单的反射映射技术之一。球面环境贴图将环境光存储在球面上，然后用环境光去渲染整个的物体。</p><p><img src="Snipaste_2020-09-30_23-50-35.jpg" alt="球面环境贴图"></p><p><img src="Snipaste_2020-09-30_23-50-53.jpg" alt="球面环境贴图的缺陷"></p><p>由于是通过球体来存储环境信息，这就导致了描述的不是均匀的信息，<strong>会在靠近极点的地方出现扭曲</strong>（墨卡托投影：将地球进行投影到平面，维度高的地方在平面地图上看起来会更大）</p><h2 id="5-2-Cube-Map"><a href="#5-2-Cube-Map" class="headerlink" title="5.2 Cube Map"></a>5.2 Cube Map</h2><p><strong>Cube Map</strong>（立方体贴图）是环境映射的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。</p><p><img src="Snipaste_2020-09-30_23-51-12.jpg" alt="立方体贴图"></p><p>立方体贴图包含了6张图像，对应着立方体的6个面，每个面表示沿着世界空间下的轴向观察所得的图像。</p><p><img src="Snipaste_2020-09-30_23-51-42.jpg" alt="立方体贴图"></p><p>立方体贴图解决了球面环境贴图图像扭曲的问题，<strong>但立方体贴图不能模拟多次反射的结果。</strong></p><h2 id="5-3-Radiosity-Normal-Map"><a href="#5-3-Radiosity-Normal-Map" class="headerlink" title="5.3 Radiosity Normal Map"></a>5.3 Radiosity Normal Map</h2><p><strong>Radiosity Normal Map</strong>（辐射度法线贴图）是光贴图和法线贴图的特殊混合。可以将照明作为一组三个光照贴图进行烘焙，以存储照明矢量，而不仅仅是亮度/颜色。这使表面法线贴图可以接收定向照明，因此，通过烘焙的照明信息可以更准确地照明凹凸。</p><div align=center><p><img src="RadiosityNormalMap.jpg" alt="Half-Life®2/ Valve Source™Shading"></p></div><p>Valve在Half-Life 2中广泛使用了此方法，他们在GDC 2004论文*<a href="http://www.decew.net/OSS/References/D3DTutorial10_Half-Life2_Shading.pdf">Half-Life®2/ Valve Source™Shading</a>*中将其称为“辐射度法线贴图” 。</p><h1 id="6-其他贴图"><a href="#6-其他贴图" class="headerlink" title="6. 其他贴图"></a>6. 其他贴图</h1><h2 id="6-1-ID-Mask"><a href="#6-1-ID-Mask" class="headerlink" title="6.1 ID/Mask"></a>6.1 ID/Mask</h2><p><strong>ID/Mask Map</strong>（ID、遮罩贴图）用于选择不同的区域，进行分别绘制。</p><p><img src="ID.jpg" alt="ID/遮罩贴图"></p><h2 id="6-2-Emissive"><a href="#6-2-Emissive" class="headerlink" title="6.2 Emissive"></a>6.2 Emissive</h2><p><strong>Emissive Map</strong>（自发光贴图）控制表面发射光的颜色和亮度。当场景中使用了自发光材质时，它看起来像一个可见光。物体将呈现发光效果。</p><p><img src="EmissionOn.jpg" alt="自发光贴图"></p><p>自发光材质通常用于某些部位应该从内部照亮的物体上，例如监视器屏幕、高速制动的汽车盘式制动器、控制面板上的发光按钮，或黑暗中仍然可见的怪物眼睛。简单的自发光材质可以通过一个颜色和亮度来定义。</p><h2 id="6-3-Opacity"><a href="#6-3-Opacity" class="headerlink" title="6.3 Opacity"></a>6.3 Opacity</h2><p><strong>Opacity</strong>（透明贴图）定义贴图的不透明度，用于裁剪表面的一部分。黑色是透明的部分，白色为不透明的部分，灰色为半透明的部分。</p><div align=center><p><img src="Opacity.jpg" alt="透明贴图的应用"></p></div><p>当材质使用不透明度贴图时，它将充当遮罩，该遮罩将隐藏对象的某些部分。例如可以将“不透明度”贴图用于剪切树叶形状，穿孔表面和网格等。</p><h2 id="6-5-Position"><a href="#6-5-Position" class="headerlink" title="6.5 Position"></a>6.5 Position</h2><p><strong>Position Map</strong>（位置贴图）使用R/G/B三个通道描述X/Y/Z轴上顶点对应的位置。</p><p><img src="PositionMap.jpg" alt="位置贴图"></p><p>通常位置贴图来实现模型底部到顶部的渐变效果等，如墙壁底部的污渍、石块底部的青苔。</p><h2 id="6-6-Detail-Map"><a href="#6-6-Detail-Map" class="headerlink" title="6.6 Detail Map"></a>6.6 Detail Map</h2><p><strong>Detail</strong>（细节贴图）是用于平铺的局部贴图纹理，以相对较低的成本，内存和性能来增加表面细节（微观和宏观）。</p><p><img src="DetailMap.jpg" alt="细节贴图的使用"></p><div align=center><p><img src="Detail.jpg" alt="细节贴图的组成"></p></div><p>细节贴图通常为四方连续纹理，并由一组贴图组合而成（法线、反射率、光泽度等）。</p><h2 id="6-7-Flow-Map"><a href="#6-7-Flow-Map" class="headerlink" title="6.7 Flow Map"></a>6.7 Flow Map</h2><p><strong>Flow Map</strong>（流动贴图）存储的是向量场数据，可以用来制作流动的水面效果。</p><p><img src="Flowmap.gif" alt="Flowmap"></p><p>Valve在Portal 2和Left 4 Dead 2中广泛使用了此方法，他们在SIGGRAPH 2010论文*<a href="http://advances.realtimerendering.com/s2010/Vlachos-Waterflow(SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course).pdf">Vlachos/Water Flow in Portal 2</a>*中分享了用流动贴图制作流动水面的技术。</p><h2 id="6-8-DuDv-Map"><a href="#6-8-DuDv-Map" class="headerlink" title="6.8 DuDv Map"></a>6.8 DuDv Map</h2><p><strong>DuDv</strong>贴图是使用一种纹理扭曲另一种纹理的像素的一种简单方法。常用于火上的热雾、涟漪折射的水面等。</p><div align=center><p><img src="dudvmap.jpg" alt="DuDv贴图"></p></div><p>DuDv贴图与法线贴图类似，都是将方向信息存储在纹理中，但DuDv贴图仅用到了R通道和G通道。</p><div align=center><p><img src="dudvmap2.jpg" alt="DuDv贴图原理"></p></div><p>DuDv的工作方式与视差贴图扭曲曲面的方式类似，只是DuDv不考虑视角（无视差）。从DuDv贴图中获取Du和Dv，对反射贴图中的每个像素，将Du添加到反射贴图的U纹理坐标，并将Dv添加到其V坐标。最后偏移反射贴图像素，从而产生失真。</p><h1 id="7-一些注意事项"><a href="#7-一些注意事项" class="headerlink" title="7. 一些注意事项"></a>7. 一些注意事项</h1><p>在使用这些贴图时，如果要对其进行运算则需要格外注意其贴图储存的信息是否经过伽马编码。<strong>其中，颜色值和颜色操作的计算应该在线性空间内执行。</strong></p><p>一般来说，基本颜色(Base Color)贴图在创建的时候就已经在sRGB空间了，因此我们需要在光照计算之前先把他们转换到线性空间。环境光遮蔽贴图(Ambient Occlusion maps)通常也需要我们转换到线性空间。而像金属度贴图(Metallic)和粗糙度贴图(Roughness)大多都会保证在线性空间中。</p><p>可以简单地区分为，如果贴图代表着我们看到的颜色，则它该被阐释为sRGB；如果贴图代表数据，则应该将其阐释为线性。</p><hr><ol><li>《Unity Shader入门精要》</li><li>《Real-Time Rendering 4th Edition》</li><li>GAMES101:现代计算机图形学入门[<a href="http://games-cn.org/intro-graphics/]">http://games-cn.org/intro-graphics/]</a></li><li>游戏美术基础：游戏贴图[<a href="https://www.jianshu.com/p/c1ed26cbb6b4]">https://www.jianshu.com/p/c1ed26cbb6b4]</a></li><li>Polycount - Texture types[<a href="http://wiki.polycount.com/wiki/Texture_types]">http://wiki.polycount.com/wiki/Texture_types]</a></li><li>《Real-time Shallow Water Simulation and Environment Mapping and Clouds - Rene Truelsen》</li><li>What are the different texture maps for?[<a href="https://help.poliigon.com/en/articles/1712652-what-are-the-different-texture-maps-for]">https://help.poliigon.com/en/articles/1712652-what-are-the-different-texture-maps-for]</a></li><li>The PBR Guide part 1[<a href="https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh]">https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh]</a></li><li>The PBR Guide part 2[<a href="https://academy.substance3d.com/courses/the-pbr-guide-part2-zh]">https://academy.substance3d.com/courses/the-pbr-guide-part2-zh]</a></li><li>Diffuse/Specular vs BaseColor[<a href="https://resources.turbosquid.com/stemcell/stemcell-3d-modeling-workflow/stemcell-textures-materials/diffuse-specular-vs-basecolor/]">https://resources.turbosquid.com/stemcell/stemcell-3d-modeling-workflow/stemcell-textures-materials/diffuse-specular-vs-basecolor/]</a></li><li>Normal vs. Displacement Mapping &amp; Why Games Use Normals[<a href="https://cgcookie.com/articles/normal-vs-displacement-mapping-why-games-use-normals]">https://cgcookie.com/articles/normal-vs-displacement-mapping-why-games-use-normals]</a></li><li>Physically-Based Rendering, And You Can Too![<a href="https://marmoset.co/posts/physically-based-rendering-and-you-can-too/]">https://marmoset.co/posts/physically-based-rendering-and-you-can-too/]</a></li><li>Level of Detail[<a href="https://resources.turbosquid.com/level-of-detail/]">https://resources.turbosquid.com/level-of-detail/]</a></li><li>Elliminate Texture Confusion: Bump, Normal and Displacement Maps[<a href="https://www.pluralsight.com/blog/film-games/bump-normal-and-displacement-maps]">https://www.pluralsight.com/blog/film-games/bump-normal-and-displacement-maps]</a></li><li>VECTOR DISPLACEMENT MAPS[<a href="http://docs.pixologic.com/user-guide/3d-modeling/exporting-your-model/vector-displacement-Maps/]">http://docs.pixologic.com/user-guide/3d-modeling/exporting-your-model/vector-displacement-Maps/]</a></li><li>Parallax Map with Offset Limiting: A PerPixel Approximation of Uneven Surfaces</li><li>BRUSHED METAL V-RAY MATERIAL[<a href="https://resources.turbosquid.com/library-tutorials/brushed-metal/]">https://resources.turbosquid.com/library-tutorials/brushed-metal/]</a></li><li>Half Avocado[<a href="https://quixel.com/megascans/home?category=3D%20asset&amp;category=edible&amp;category=fruit&amp;assetId=ujcxeblva]">https://quixel.com/megascans/home?category=3D%20asset&amp;category=edible&amp;category=fruit&amp;assetId=ujcxeblva]</a></li><li>Art of Lighting Game Environments in Unity[<a href="https://cgcookie.com/articles/art-of-lighting-game-environments]">https://cgcookie.com/articles/art-of-lighting-game-environments]</a></li><li>Detail Maps[<a href="https://docs.cryengine.com/display/SDKDOC2/Detail+Maps]">https://docs.cryengine.com/display/SDKDOC2/Detail+Maps]</a></li><li>180701 UE4 Flowmap Fields Visualizer[<a href="https://www.youtube.com/watch?v=frfcRzuw6OM]">https://www.youtube.com/watch?v=frfcRzuw6OM]</a></li><li>Theory[<a href="https://link.zhihu.com/?target=https%3A//learnopengl.com/PBR/Theory">https://learnopengl.com/PBR/Theory</a>]</li><li>Lighting[<a href="https://link.zhihu.com/?target=https%3A//learnopengl.com/PBR/Lighting">https://learnopengl.com/PBR/Lighting</a>]</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏模型制作中用到了很多贴图类型，通过不同类型贴图的组合使用以达到最终需要得到的模型效果。最常见的类型有&lt;strong&gt;Diffuse&lt;/strong&gt;、&lt;strong&gt;Emissive&lt;/strong&gt;、&lt;strong&gt;Normal&lt;/strong&gt;、&lt;strong&gt;Opacity&lt;/strong&gt;、&lt;strong&gt;Specular&lt;/strong&gt;、&lt;strong&gt;Roughness&lt;/strong&gt;。游戏制作中根据项目资产的需要使用不同的贴图类型。</summary>
    
    
    
    <category term="游戏美术" scheme="http://www.zanple.top/categories/%E6%B8%B8%E6%88%8F%E7%BE%8E%E6%9C%AF/"/>
    
    
    <category term="游戏" scheme="http://www.zanple.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="美术" scheme="http://www.zanple.top/tags/%E7%BE%8E%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Graphic Debugger工具简单入门</title>
    <link href="http://www.zanple.top/2020/09/13/graphic-debugger-intro/"/>
    <id>http://www.zanple.top/2020/09/13/graphic-debugger-intro/</id>
    <published>2020-09-13T10:42:50.000Z</published>
    <updated>2020-09-16T16:21:26.231Z</updated>
    
    <content type="html"><![CDATA[<p>游戏制作学习过程中无论是对自己的游戏进行分析，还是学习其他游戏用到的先进的制作方法和工艺流程，进行渲染调试都必不可少。<a id="more"></a></p><hr><h1 id="1-PC游戏"><a href="#1-PC游戏" class="headerlink" title="1.PC游戏"></a>1.PC游戏</h1><p>PC游戏可以选择的工具有工具有<strong>NSight</strong>，<strong>Intel GPA</strong>，<strong>RenderDoc</strong>。这里以<strong>Intel GPA</strong>的使用为例。</p><p>在Intel的<a href="https://software.intel.com/content/www/us/en/develop/tools/graphics-performance-analyzers.html">官网</a>上下载安装包安装完成后，会在桌面上看到4个图标。</p><div align=center><p><img src="Sni50-47.png" alt="Intel GPA"></p></div><p>其中<strong>Graphics Monitor</strong>是我们使用的主要工具。打开<strong>Graphics Monitor</strong>后，点击示例项目的<code>播放按钮</code>。</p><p><img src="Sni58-13.png" alt="Graphics Monitor界面"></p><p>打开游戏窗口，可以点击右侧的<strong>Capture frame</strong>或按<code>Ctrl+Shift+C</code>键进行当前帧的抓取。</p><div align=center><p><img src="Sni58-23.png" alt="示例"></p></div><p>回到<strong>Graphics Monitor</strong>出口，在右侧可看到刚才抓的帧。双击打开这一帧。</p><p><img src="Sni58-39.png" alt="Graphics Monitor窗口"></p><p>在弹出的<strong>Graphics Frame Analyzer</strong>窗口中，选择需要打开的帧，点击左侧的<code>Open</code>打开分析界面。</p><p><img src="Sni59-11.png" alt="Graphics Frame Analyzer窗口"></p><p>进入帧分析界面后，点击<strong>Frame Statistics-DrawIndexed-Show All Resources</strong>可以看到这一帧下的全部资源，包括<em>贴图</em>、<em>模型</em>等。</p><p><img src="Sni00-31.png" alt="分析界面"></p><p><img src="Sni00-40.png" alt="贴图资源"></p><p><img src="Sni01-49.png" alt="模型资源"></p><p>如果想对其他游戏进行分析，在<strong>Graphics Monitor</strong>界面中的<code>路径位置</code>，更改为想要分析的游戏的位置，并打开右上角设置中的<code>自动检测启动应用</code>开关。</p><p><img src="Sni58-40.png" alt="设置路径"></p><p><img src="Sni02-42.png" alt="打开自动检测"></p><h1 id="2-移动端游戏"><a href="#2-移动端游戏" class="headerlink" title="2. 移动端游戏"></a>2. 移动端游戏</h1><p>移动端常用的工具有<strong>RenderDoc</strong>，或者各家GPU厂商自己推出的相应工具，比如高通系的<strong>Snapdragon Profiler</strong>。这里以<strong>Snapdragon Profiler</strong>为例。</p><p>在Qualcomm的<a href="https://developer.qualcomm.com/software/snapdragon-profiler">官网</a>上进行注册登录后，根据对应的平台下载安装<strong>Snapdragon Profiler</strong>。安装完成后会在桌面上看到Snapdragon Profiler的快捷方式。</p><div align=center><p><img src="Sni18-37.png" alt="Snapdragon Profiler"></p></div><p>打开<strong>Snapdragon Profiler</strong>，点击左侧的<code>Connect to a Device</code>。</p><p><img src="Sni26-54.png" alt="连接设备1"></p><p>手机打开USB调试并连接电脑，点击<code>Connect</code>按钮。</p><p><img src="Sni27-03.png" alt="连接设备2"></p><p>成功连接后左侧的New Trace Capture和New Snapshot Capture按钮变为可点击状态，点击<code>New Snapshot Capture</code>。</p><p><img src="Sni32-05.png" alt="帧抓取"></p><p>找到需要抓帧的进程，点击<code>Take Snapshot</code>。</p><p><img src="Sni32-12.png" alt="抓取当前帧"></p><p><img src="Sni33-14.png" alt="分析界面"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;游戏制作学习过程中无论是对自己的游戏进行分析，还是学习其他游戏用到的先进的制作方法和工艺流程，进行渲染调试都必不可少。</summary>
    
    
    
    <category term="性能分析" scheme="http://www.zanple.top/categories/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
    
    <category term="游戏" scheme="http://www.zanple.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="性能分析" scheme="http://www.zanple.top/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Unity卡通地编-Hylia小岛(完善中)</title>
    <link href="http://www.zanple.top/2020/09/12/unity-hylia-island/"/>
    <id>http://www.zanple.top/2020/09/12/unity-hylia-island/</id>
    <published>2020-09-12T03:44:50.000Z</published>
    <updated>2021-03-06T10:13:42.192Z</updated>
    
    <content type="html"><![CDATA[<p>跟着猴子老师学习的一个Unity卡通地编的制作。使用Unity的LWRP轻量级渲染管线制作，通过Substance Designer，Zbrush，Maya，Photoshop来辅助完成模型贴图部分。材质部分涉及水和互动草的Shader制作，利用GPU的特性来快速实例像旷野之息一样的草坪。使用Houdini来制作树的叶子，给物件做LOD优化。<a id="more"></a></p><hr><h1 id="1-地形系统"><a href="#1-地形系统" class="headerlink" title="1. 地形系统"></a>1. 地形系统</h1><p>地形系统的构建用到了<code>Terrain Tools</code>包，用于改善在Unity中创建地形的工作流程。</p><p>在<code>Terrain Toolbox</code>中设置创建的地形大小点击<code>Create</code>创建地形，可以通过导入外部<code>Heightmap</code>来创建地形。</p><div align=center><p><img src="image-20200912165129171.png" alt="Terrain Box"></p></div><blockquote><p>在Edit-Shortcuts-Terrain中可以更改创建地形的快捷键，如Select Set Height Tool、Select Smooth Tool等。通过ASD调节笔刷的强度、大小和旋转角度。</p></blockquote><p>使用<code>Raise or Lower Terrain</code>、<code>Set Height</code>、<code>Smooth Height</code>构建基本地形。</p><p>完成地形构建后，通过<code>Create-Terrain Layer</code>创建层，在<code>地形-Paint Texture-Layer</code>中添加图层。为地形绘制贴图。</p><h1 id="2-石头雕刻"><a href="#2-石头雕刻" class="headerlink" title="2. 石头雕刻"></a>2. 石头雕刻</h1><p>使用Zbrush对石头低模进行雕刻，其中用到了卡通风格的<a href="https://pan.baidu.com/s/1LEvg59mFISRcE8d8aZyanw">笔刷</a>(提取码uaqi)。</p><div align=center><p><img src="image-20200912195904050.png" alt="卡通笔刷"></p></div><h1 id="3-石头贴图"><a href="#3-石头贴图" class="headerlink" title="3. 石头贴图"></a>3. 石头贴图</h1><p>利用Substance Designer制作石头的贴图。首先将高模和低模导入SD中，在SD中烘培<code>AO</code>、Normal(Tangent)、Normal(World)、Curvature、Position图。</p><h2 id="3-1-Normal"><a href="#3-1-Normal" class="headerlink" title="3.1 Normal"></a>3.1 Normal</h2><p>在高模烘培的法线贴图上叠加裂痕、磨损等细节效果。细节效果通过<code>Creased节点</code>得到，裂痕效果通过<code>Cells节点</code>得到，磨损坑洼效果可通过<code>Tile Sampler节点</code>得到。</p><p>石头上的横纹使用<code>Light节点</code>通过<code>世界空间的法线贴图</code>得到石块的遮罩，以此避免石块顶部也出现横纹。</p><blockquote><p>Light节点：根据世界空间法线贴图进行伪照明，并返回黑白“光照图”蒙版。</p></blockquote><h2 id="3-2-Base-Color"><a href="#3-2-Base-Color" class="headerlink" title="3.2 Base Color"></a>3.2 Base Color</h2><p>颜色贴图用到了<code>Gradient Map节点</code>来得到表面的基本颜色，使用<code>Dirt节点</code>根据烘培的<code>Curvature</code>、<code>AO</code>、<code>世界空间的法线贴图</code>来生成石块缝隙的青苔效果。</p><blockquote><p>Gradient Map节点：从灰度映射到自定义的颜色色带，颜色色带可以通过取色曲线得到。</p><p>Dirt节点：根据烘焙的Curvature、AO、Normal(World)和用户设置生成黑白蒙版，表示在被遮挡和凹陷的边缘和角落出现了污垢。</p><p>Edge Damage节点：根据烘焙的曲率和AO对凸起的凸边缘造成的损坏图和用户设置生成黑白蒙版。</p></blockquote><h2 id="3-3-贴图导入Unity"><a href="#3-3-贴图导入Unity" class="headerlink" title="3.3 贴图导入Unity"></a>3.3 贴图导入Unity</h2><p>在Substance Designer导出贴图时，将<code>Metallic/Smoothness/Occlusion</code>合并在一张贴图内。</p><div align=center><p><img src="Snipaste_2020-10-31_16-04-00.jpg" alt=""></p></div><p>在石头的Shader中，将<code>Vertex Color</code>的<code>R通道</code>和<code>G通道</code>分别使用不同的Albedo贴图。</p><div align=center><p><img src="Snipaste_2020-10-31_16-07-58.jpg" alt="石头效果"></p></div><h1 id="4-水Shader制作"><a href="#4-水Shader制作" class="headerlink" title="4. 水Shader制作"></a>4. 水Shader制作</h1><h2 id="4-1-Normal部分"><a href="#4-1-Normal部分" class="headerlink" title="4.1 Normal部分"></a>4.1 Normal部分</h2><div align=center><p><img src="Snipaste_2020-10-31_16-52-34.jpg" alt="水的Normal部分"></p></div><p>水的Normal部分首先对世界空间的Position进行拆分，由于只是X/Z平面的移动，因此将Position的R/B组合为一个新的二维向量。</p><div align=center><p><img src="Snipaste_2020-10-31_16-31-34.jpg" alt="水Normal图"></p></div><p>使用Time节点控制移动，将法线贴图以不同的UV大小生成大小波浪叠加的效果。</p><h2 id="4-2-颜色部分"><a href="#4-2-颜色部分" class="headerlink" title="4.2 颜色部分"></a>4.2 颜色部分</h2><p>水在不同深度颜色有所差异，通常在较浅的区域颜色也比较浅，透明度也比较高。</p><h3 id="4-2-1-Alpha"><a href="#4-2-1-Alpha" class="headerlink" title="4.2.1 Alpha"></a>4.2.1 Alpha</h3><div align=center><p><img src="Snipaste_2020-10-31_17-04-26.jpg" alt="水颜色的通透颜色"></p></div><p>首先用世界空间的Position减去相机的Position，然后与相机的方向进行点积Dot并控制在0~1之间，与加上自定义深度值的结果进行平滑操作。将Scene Depth作为Smoothstep的输入。得到了水面的透明度以体现深度。</p><blockquote><p>Smoothstep节点类似类似于Lerp节点，但Smoothstep不是线性插值。</p><p>Scene Depth节点访问当前Camera深度缓冲区。</p></blockquote><h3 id="4-2-2-焦散效果"><a href="#4-2-2-焦散效果" class="headerlink" title="4.2.2 焦散效果"></a>4.2.2 焦散效果</h3><div align=center><p><img src="Snipaste_2020-10-31_17-04-56.jpg" alt="焦散效果"></p></div><p>焦散效果的模拟主要用了Voronoi节点，使用之前组合的二维向量与Time节点扭曲运动Voronoi节点，并叠加焦散颜色。</p><h3 id="4-2-3-颜色"><a href="#4-2-3-颜色" class="headerlink" title="4.2.3 颜色"></a>4.2.3 颜色</h3><p>水的颜色再进行一次透明度处理中的操作并使用两个颜色进行插值得到水面的颜色。计算相机与世界空间的距离，加深相机远处的水面颜色。</p><div align=center><p><img src="Snipaste_2020-10-31_19-13-38.jpg" alt="水面颜色"></p></div><h1 id="5-草Shader制作"><a href="#5-草Shader制作" class="headerlink" title="5.草Shader制作"></a>5.草Shader制作</h1><p>草Shader的制作主要分为更改草模型的顶点位置和材质的颜色。</p><h2 id="5-1-模型部分"><a href="#5-1-模型部分" class="headerlink" title="5.1 模型部分"></a>5.1 模型部分</h2><p>在Maya中创建简单的草模型，并制作LOD。</p><div align=center><img src="Snipaste_2020-11-23_22-16-00.jpg" alt="草模型的顶点色" style="zoom:50%;" /></div><p>然后对三个LOD绘制顶点颜色，并更改其顶点方向。</p><div align=center><img src="Snipaste_2020-11-23_22-17-21.jpg" alt="草模型顶点方向" style="zoom: 67%;" /></div><h2 id="5-2-Shader部分"><a href="#5-2-Shader部分" class="headerlink" title="5.2 Shader部分"></a>5.2 Shader部分</h2><h3 id="5-2-1-颜色"><a href="#5-2-1-颜色" class="headerlink" title="5.2.1 颜色"></a>5.2.1 颜色</h3><p>颜色主要根据预先制作的渐变图将草顶部和底部的颜色进行插值，然后加上运动的Noise图以模仿风吹过草地的效果。</p><div align=center><p><img src="Snipaste_2020-11-24_17-28-29.jpg" alt="草的颜色"></p></div><h3 id="5-2-2-Position"><a href="#5-2-2-Position" class="headerlink" title="5.2.2 Position"></a>5.2.2 Position</h3><p>Position由模拟风的效果和角色与草的互动组成。</p><p>风吹草地的摇摆效果与颜色部分类似，通过一张运动的Noise图去改变顶点的位置，并根据顶点色改变摇摆的权重。</p><div align=center><p><img src="Snipaste_2020-11-24_18-30-38.jpg" alt="草的运动效果"></p></div><p>角色与草的互动效果涉及到草的模型空间到世界空间的转换，然后根据草和角色的距离和方向改变顶点的位置。</p><div align=center><p><img src="Snipaste_2020-11-24_18-34-27.jpg" alt="改变顶点位置"></p></div><p>效果如下：</p><div align=center><p><img src="Snipaste_2020-11-24_19-24-26.jpg" alt="草的效果"></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;跟着猴子老师学习的一个Unity卡通地编的制作。使用Unity的LWRP轻量级渲染管线制作，通过Substance Designer，Zbrush，Maya，Photoshop来辅助完成模型贴图部分。材质部分涉及水和互动草的Shader制作，利用GPU的特性来快速实例像旷野之息一样的草坪。使用Houdini来制作树的叶子，给物件做LOD优化。</summary>
    
    
    
    <category term="Unity" scheme="http://www.zanple.top/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
    <category term="地编" scheme="http://www.zanple.top/tags/%E5%9C%B0%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Substance Designer-布料纹理</title>
    <link href="http://www.zanple.top/2020/09/05/sd-fabric/"/>
    <id>http://www.zanple.top/2020/09/05/sd-fabric/</id>
    <published>2020-09-05T06:12:03.000Z</published>
    <updated>2020-09-05T15:50:01.306Z</updated>
    
    <content type="html"><![CDATA[<p>利用Substance Designer制作的几个布料纹理。<a id="more"></a></p><hr><h1 id="1-效果图"><a href="#1-效果图" class="headerlink" title="1. 效果图"></a>1. 效果图</h1><div align=center><p><img src="y11.png" alt=""></p><p><img src="y22.png" alt=""></p><p><img src="l11.png" alt=""></p><p><img src="s31.png" alt=""></p><p><img src="s41.png" alt=""></p><p><img src="s51.png" alt=""></p></div>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用Substance Designer制作的几个布料纹理。</summary>
    
    
    
    <category term="Substance Designer" scheme="http://www.zanple.top/categories/Substance-Designer/"/>
    
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="Substance Designer" scheme="http://www.zanple.top/tags/Substance-Designer/"/>
    
    <category term="程序化" scheme="http://www.zanple.top/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Substance Designer-刺绣效果</title>
    <link href="http://www.zanple.top/2020/07/04/sd-embroidery/"/>
    <id>http://www.zanple.top/2020/07/04/sd-embroidery/</id>
    <published>2020-07-04T13:30:03.000Z</published>
    <updated>2020-09-05T15:49:45.424Z</updated>
    
    <content type="html"><![CDATA[<p>利用Substance Designer制作的一个刺绣效果（参考了Pauline Boiteux的《Advanced Pattern &amp; Fabric Creation in Substance Designer》制作流程以及整体的制作思路）。<a id="more"></a></p><hr><h1 id="1-效果图"><a href="#1-效果图" class="headerlink" title="1. 效果图"></a>1. 效果图</h1><p><img src="render.jpg" alt="效果图1"></p><p><img src="detail.jpg" alt="效果图2"></p><h1 id="2-制作思路"><a href="#2-制作思路" class="headerlink" title="2. 制作思路"></a>2. 制作思路</h1><p>整体的制作分为刺绣纹理、基本图案的制作，主体纹理的组合，布料纹理的制作和细节的完善几个部分。</p><h2 id="2-1-刺绣纹理"><a href="#2-1-刺绣纹理" class="headerlink" title="2.1 刺绣纹理"></a>2.1 刺绣纹理</h2><p>刺绣纹理这块分为刺绣的<code>边缘</code>和<code>刺绣内部填充</code>的纹理制作。</p><p><strong>边缘纹理</strong>的制作比较简单， 使用自带的<code>Fibers</code>平铺即可得到。</p><p><strong>内部填充纹理</strong>可以通过<code>Splatter Circular</code>创建扭曲的绳结形状拼接平铺得到。</p><div align=center><img src="image-20200905225628362.png" alt="内部填充纹理" style="zoom:80%;" /></div><h2 id="2-2-主题纹理的制作与组合"><a href="#2-2-主题纹理的制作与组合" class="headerlink" title="2.2 主题纹理的制作与组合"></a>2.2 主题纹理的制作与组合</h2><p>基本图案的制作可以利用内部<code>Shape</code>进行变换得到，也可以在其他软件（如CorelDARW、Illustrator等软件）制作。再对基本图形进行组合得到（需要注意连续的问题）。</p><div align=center><p><img src="image-20200905230147933.png" alt="主体纹理"></p></div><h2 id="2-3-布料纹理的制作"><a href="#2-3-布料纹理的制作" class="headerlink" title="2.3 布料纹理的制作"></a>2.3 布料纹理的制作</h2><p>简单的布料纹理可以通过<code>Weave Generator</code>节点生成，再叠加划痕效果丰富其细节。</p><div align=center><p><img src="image-20200905230507707.png" alt="布料纹理"></p></div><h2 id="2-4-细节的完善"><a href="#2-4-细节的完善" class="headerlink" title="2.4 细节的完善"></a>2.4 细节的完善</h2><div align=center><p><img src="image-20200905230615026.png" alt="刺绣的褶皱"></p></div><p>布料的刺绣很难避免褶皱的产生（如上图），要实现这样的效果需要对布料上刺绣相应的位置的法线信息进行修改。如下为使用褶皱效果的制作流程。</p><div align=center><p><img src="image-20200905230739856.png" alt="褶皱效果的制作流程"></p></div><p>*将上图的模糊效果由<code>Blur HQ Grayscale</code>改为非均匀模糊可以得到更好的效果。</p><h1 id="3-其他刺绣方案"><a href="#3-其他刺绣方案" class="headerlink" title="3. 其他刺绣方案"></a>3. 其他刺绣方案</h1><p>本文制作的刺绣效果还有很多可以优化的地方。此外还有很多用SD制作刺绣效果的案例，如汪锦，Pauline Boiteux制作的一些刺绣效果。</p><p><img src="Cixiu.jpg" alt="[汪锦](https://academy.substance3d.com/courses/%E5%88%BA%E7%BB%A3%E6%95%99%E7%A8%8B)"></p><p><img src="Flower.jpg" alt="[Pauline Boiteux](https://www.artstation.com/jappluz)"></p><p><img src="Japanese.jpg" alt="[Pauline Boiteux](https://www.artstation.com/jappluz)"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;利用Substance Designer制作的一个刺绣效果（参考了Pauline Boiteux的《Advanced Pattern &amp;amp; Fabric Creation in Substance Designer》制作流程以及整体的制作思路）。</summary>
    
    
    
    <category term="Substance Designer" scheme="http://www.zanple.top/categories/Substance-Designer/"/>
    
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="Substance Designer" scheme="http://www.zanple.top/tags/Substance-Designer/"/>
    
    <category term="程序化" scheme="http://www.zanple.top/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Unity小游戏-新冠入侵</title>
    <link href="http://www.zanple.top/2020/05/13/unity-coviddefend/"/>
    <id>http://www.zanple.top/2020/05/13/unity-coviddefend/</id>
    <published>2020-05-13T04:49:10.000Z</published>
    <updated>2020-09-05T08:17:37.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>利用Unity独立开发的一个塔防类的小游戏~<a id="more"></a></p></blockquote><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=583174672&bvid=BV1Mz4y1d7s3&cid=191730581&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><h1 id="1-游戏简介"><a href="#1-游戏简介" class="headerlink" title="1. 游戏简介"></a>1. 游戏简介</h1><p>《新冠入侵》是一个基于安卓平台开发的抗击新冠疫情的小游戏，使用了<code>Unity2019.3.3f1</code>进行游戏的开发、<code>Adobe Photoshop CC 2019</code>完成美术资源的设计。</p><p>游戏技术点包含常用设计模式辅助项目开发（<strong>单例，工厂，对象池，中介者，外观，状态，责任链</strong>等模式），DoTween插件的使用方法，使用JsonMapper去解析和存贮简单json与复杂json，json的使用注意事项与强制解析。编辑器拓展功能来制作地图工具（提高我们游戏开发效率，自己制作一个简单插件）。还有更多细碎知识诸如数值策划知识，游戏物体在Inspector的调整，2D开发中常遇到问题的展现与解决，面向接口编程的使用与体验，对象池技术，Unity的2D图集处理，并切割出一张张小图片。Unity中赋值顺序探索等等。</p><h1 id="2-游戏需求与流程"><a href="#2-游戏需求与流程" class="headerlink" title="2. 游戏需求与流程"></a>2. 游戏需求与流程</h1><div align=center><img src="需求.svg" alt="游戏需求与流程" width="80%" /></div><h1 id="3-美术资源设计"><a href="#3-美术资源设计" class="headerlink" title="3. 美术资源设计"></a>3. 美术资源设计</h1><h2 id="3-1-按钮设计"><a href="#3-1-按钮设计" class="headerlink" title="3.1 按钮设计"></a>3.1 按钮设计</h2><p>按钮与游戏标题保持风格一致性，大部分为手绘风格，并使用鲜明的颜色。由于本游戏是针对安卓平台开发的，因此按钮只需要常规与Press状态，Press状态大多使用阴影表现。</p><div align=center><p><img src="image-20200519173341258.png" alt="按钮设计图"></p></div><h2 id="3-2-页面设计"><a href="#3-2-页面设计" class="headerlink" title="3.2 页面设计"></a>3.2 页面设计</h2><p>按页面整体均为卡通手绘风格，使游戏能够有较大的用户群体。</p><div align=center><p><img src="image-20200519174344081.png" alt="游戏主页面"></p><p><img src="image-20200519174353151.png" alt="设置页面"></p><p><img src="image-20200519174403714.png" alt="帮助页面1"></p><p><img src="image-20200519174411958.png" alt="帮助页面2"></p><p><img src="image-20200519174420298.png" alt="帮助页面3"></p><p><img src="image-20200519174428698.png" alt="关卡选择页面"></p><p><img src="image-20200519173952073.png" alt="游戏界面"></p><p><img src="image-20200519174007004.png" alt="菜单页面"></p><p><img src="image-20200519174014180.png" alt="失败页面"></p><p><img src="image-20200519174020112.png" alt="胜利页面"></p></div><h1 id="4-游戏设计模式与玩法机制"><a href="#4-游戏设计模式与玩法机制" class="headerlink" title="4. 游戏设计模式与玩法机制"></a>4. 游戏设计模式与玩法机制</h1><h2 id="4-1-设计模式"><a href="#4-1-设计模式" class="headerlink" title="4.1 设计模式"></a>4.1 设计模式</h2><p>本游戏综合使用了多种游戏设计模式。包括单例模式、工厂模式、对象池模式、外观模式、中介者模式、建造者模式、责任链模式。</p><ol><li><strong>单例模式：</strong>单例模式是一种常见的设计模式，具有以下特点：单例类只能有一个实例、单例类必须自己创建自己的唯一实例、单例类必须给所有其他对象提供这一实例。单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。</li><li><strong>工厂模式：</strong>工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。</li><li><strong>对象池模式：</strong>对象池技术在第一次创建的时候就将对象存储在一个池子中，当需要销毁的时候不直接销毁而是隐藏，当需要时在再次使用，就不需要再次实例化一个新的对象，直接把隐藏的对象显示并拿出来用。如果对象池中已经被隐藏的物体太久没有被重新使用，应该被真正的销毁。</li><li><strong>外观模式：</strong>外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。</li><li><strong>中介者模式：</strong>中介者模式是一种比较常用的模式,一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。</li><li><strong>建造者模式**</strong>：**建造者模式是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</li><li><strong>责任链模式：</strong>责任链模式使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。</li></ol><h2 id="4-2-玩法机制"><a href="#4-2-玩法机制" class="headerlink" title="4.2 玩法机制"></a>4.2 玩法机制</h2><p>游戏初始状态下玩家拥有<code>800枚金币</code>，且有<code>10点生命值</code>。当玩家金币不足以建塔时玩家可以通过击杀病毒或打开场景中的道具来获得金币；病毒每个成功入侵玩家的生命值将会减少1点，生命值为0则游戏失败并结束。当玩家成功击退所有波次的病毒则获胜。</p><p><strong>- 病毒等级数值：</strong></p><table><thead><tr><th align="center"><strong>ID/等级</strong></th><th align="center"><strong>病毒</strong></th><th align="center"><strong>生命值</strong></th><th align="center"><strong>移动速度</strong></th><th align="center"><strong>击杀奖励</strong></th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><img src="image-20200519174750301.png" /></td><td align="center">100</td><td align="center">1</td><td align="center">50</td></tr><tr><td align="center">2</td><td align="center"><img src="image-20200519174942440.png" /></td><td align="center">200</td><td align="center">2</td><td align="center">100</td></tr><tr><td align="center">3</td><td align="center"><img src="image-20200519174945621.png" /></td><td align="center">300</td><td align="center">3</td><td align="center">150</td></tr><tr><td align="center">4</td><td align="center"><img src="image-20200519174948003.png" /></td><td align="center">400</td><td align="center">4</td><td align="center">200</td></tr><tr><td align="center">5</td><td align="center"><img src="image-20200519174950750.png" /></td><td align="center">500</td><td align="center">5</td><td align="center">250</td></tr><tr><td align="center">6</td><td align="center"><img src="image-20200519174953130.png" /></td><td align="center">600</td><td align="center">6</td><td align="center">300</td></tr></tbody></table><p><strong>-</strong> <strong>炮塔等级数值：</strong> 根据防疫物品的特征：口罩有阻挡新冠病毒传播的能力，而84消毒液、75%医用酒精、含酒精洗手液有杀死病毒的能力。按照这些特征来设定游戏中塔的能力。</p><div align=center><p><img src="image-20200519180402292.png" alt="炮塔ID"></p></div><table><thead><tr><th align="center"><strong>ID</strong></th><th align="center"><strong>等级</strong></th><th align="center"><strong>建塔价格</strong></th><th align="center"><strong>卖出价格</strong></th><th align="center"><strong>攻击CD</strong></th><th align="center"><strong>攻击范围</strong></th><th align="center"><strong>攻击速度</strong></th><th align="center"><strong>攻击伤害</strong></th><th align="center"><strong>攻击Buff</strong></th></tr></thead><tbody><tr><td align="center">1</td><td align="center">1</td><td align="center">100</td><td align="center">50</td><td align="center">1.5</td><td align="center">2</td><td align="center">2</td><td align="center">50</td><td align="center">0.12</td></tr><tr><td align="center"></td><td align="center">2</td><td align="center">150</td><td align="center">75</td><td align="center">1</td><td align="center">4</td><td align="center">3</td><td align="center">60</td><td align="center">0.48</td></tr><tr><td align="center"></td><td align="center">3</td><td align="center">225</td><td align="center">113</td><td align="center">0.8</td><td align="center">6</td><td align="center">4</td><td align="center">80</td><td align="center">1.08</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">120</td><td align="center">60</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">50</td><td align="center">0.12</td></tr><tr><td align="center"></td><td align="center">2</td><td align="center">180</td><td align="center">90</td><td align="center">0.8</td><td align="center">4</td><td align="center">4</td><td align="center">60</td><td align="center">0.48</td></tr><tr><td align="center"></td><td align="center">3</td><td align="center">270</td><td align="center">135</td><td align="center">0.6</td><td align="center">6</td><td align="center">5</td><td align="center">100</td><td align="center">1.08</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">140</td><td align="center">70</td><td align="center">2</td><td align="center">2</td><td align="center">5</td><td align="center">50</td><td align="center">-</td></tr><tr><td align="center"></td><td align="center">2</td><td align="center">150</td><td align="center">75</td><td align="center">1.5</td><td align="center">4</td><td align="center">6</td><td align="center">60</td><td align="center">-</td></tr><tr><td align="center"></td><td align="center">3</td><td align="center">225</td><td align="center">136</td><td align="center">1</td><td align="center">4</td><td align="center">7</td><td align="center">80</td><td align="center">-</td></tr><tr><td align="center">4</td><td align="center">1</td><td align="center">160</td><td align="center">80</td><td align="center">1.5</td><td align="center">2</td><td align="center">6</td><td align="center">70</td><td align="center">-</td></tr><tr><td align="center"></td><td align="center">2</td><td align="center">240</td><td align="center">120</td><td align="center">1.1</td><td align="center">4</td><td align="center">7</td><td align="center">80</td><td align="center">-</td></tr><tr><td align="center"></td><td align="center">3</td><td align="center">360</td><td align="center">180</td><td align="center">0.9</td><td align="center">6</td><td align="center">7</td><td align="center">100</td><td align="center">-</td></tr><tr><td align="center">5</td><td align="center">1</td><td align="center">160</td><td align="center">80</td><td align="center">1.2</td><td align="center">7</td><td align="center">2</td><td align="center">70</td><td align="center">-</td></tr><tr><td align="center"></td><td align="center">2</td><td align="center">240</td><td align="center">120</td><td align="center">1</td><td align="center">8</td><td align="center">3</td><td align="center">80</td><td align="center">-</td></tr><tr><td align="center"></td><td align="center">3</td><td align="center">360</td><td align="center">180</td><td align="center">0.8</td><td align="center">9</td><td align="center">4</td><td align="center">90</td><td align="center">-</td></tr></tbody></table><p><em>（buff为减速buff，表中的buff值由减速大小×减速时长的结果）</em></p><p><strong>-</strong> <strong>道具：</strong>游戏中道具的血量为800，打开道具后可获得1000金币的奖励，并且原来被道具占据的位置也可进行建塔操作。</p><p><strong>-</strong> <strong>集火：</strong>玩家可选定集火目标，目标可以是病毒和道具。选定目标后在防御塔的攻击范围内的塔会对目标进行集火攻击。</p><p><strong>-</strong> <strong>自动攻击：</strong>防御塔会自动攻击并跟踪进入其攻击范围内的病毒，可以通过升级塔来扩大攻击范围等能力。</p><p><strong>-</strong> <strong>防御塔操作：</strong>玩家可以在规定区域内建塔，其中道具所在位置和怪物入侵道路不可建塔。点击需要建塔的位置将展开建塔列表，再次点击可以收起建塔列表。点击已建的防御塔可以查看该塔目前是否可以升级，同时也可以看到塔的攻击范围。此外，玩家可以点击暂停后进行建塔，建塔完成后再点击继续。</p><p><strong>-</strong> <strong>病毒入侵：</strong>每波病毒只会在上一波病毒以完全消灭/成功入侵后开始入侵。</p><h1 id="5-UML图"><a href="#5-UML图" class="headerlink" title="5. UML图"></a>5. UML图</h1><div align=center><img src="UML1.svg" alt="UML1" style="zoom:80%;" /><img src="UML2.svg" alt="UML2" style="zoom:80%;" /><img src="UML3.svg" alt="UML3" style="zoom:80%;" /><img src="UML4.svg" alt="UML4" style="zoom:80%;" /><img src="UML5.svg" alt="UML5" style="zoom:80%;" /></div><h1 id="6-UI部分技术总结"><a href="#6-UI部分技术总结" class="headerlink" title="6. UI部分技术总结"></a>6. UI部分技术总结</h1><p>因为整个游戏项目的代码比较多，所以就只总结一些复用性比较高的部分内容。</p><h2 id="6-1-DoTween插件的缓动函数"><a href="#6-1-DoTween插件的缓动函数" class="headerlink" title="6.1 DoTween插件的缓动函数"></a>6.1 DoTween插件的缓动函数</h2><p>本游戏使用 DoTween插件来配置UI动画，缓动函数指定动画效果在执行时的速度，用于控制动画从初始值运动到最终值的速率。</p><p>DoTween的其他内容在上一篇文章已经总结过了，这里就不再赘述了。</p><h2 id="6-2-Scroll-Rect组件"><a href="#6-2-Scroll-Rect组件" class="headerlink" title="6.2 Scroll Rect组件"></a>6.2 Scroll Rect组件</h2><p>游戏中的帮助页面与选择关卡界面都使用了<code>Scroll View 组件</code>。在Scroll View中，当需要在小区域显示占用大量空间的内容时，可以使用<code>Scroll Rect</code>。滚动矩形提供了滚动浏览此内容的功能。</p><ul><li>Content：这是对用户界面要滚动的元素，例如大图像。</li><li>Horizontal/ Vertical：启用水平/垂直滚动。</li><li>Movement Type：无限制，弹性或夹紧。使用“弹性”或“夹紧”可将内容强制保留在“滚动矩形”的范围内。弹性模式在到达滚动矩形的边缘时会反弹内容。</li><li>Elasticity：弹性模式下使用的弹跳量。</li><li>Inertia：设置惯性后，拖动鼠标后释放指针，内容将继续移动。如果未设置惯性，则内容仅在拖动时才会移动。<strong>当使用DoTween插件来配置滚动动画时会产生冲突，需要关闭该选项。</strong></li><li>Deceleration Rate：设置惯性后，减速率将决定对象停止移动的速度。0将立即停止运动。值为1表示运动永远不会减速。</li><li>Scroll Sensitivity：对滚轮和触控板滚动事件的敏感性。</li><li>Viewport：引用作为内容Rect变换父级的视口Rect变换。</li><li>Scrollbar：对滚动条元素的可选引用，可以设置滚动条的隐藏属性和滚动条与视口的空间大小。</li></ul><h2 id="6-3-GridLayoutGroup组件"><a href="#6-3-GridLayoutGroup组件" class="headerlink" title="6.3 GridLayoutGroup组件"></a>6.3 GridLayoutGroup组件</h2><p>游戏中的帮助页面与选择关卡界面都使用了Scroll View 组件。在Scroll View的Content中通常会使用GridLayoutGroup组件来使内容的填充更有序。</p><ul><li>Cell Size：Content中每个单位的宽高；</li><li>Spacing：每个单位的间隔；</li><li>Start Corner：开始的位置，如Upper Left则为从左上角开始排列；</li><li>Start Axis：排列形式，分为水平排列和垂直排列；</li><li>Child Alignment：排列方式，如Upper Center则为居中靠上排列；</li><li>Constraint：约束，可选择行约束、列约束和无约束；</li><li>Padding：Content整体偏移量。</li></ul><h2 id="6-4-翻页效果的实现思路"><a href="#6-4-翻页效果的实现思路" class="headerlink" title="6.4 翻页效果的实现思路"></a>6.4 翻页效果的实现思路</h2><p>游戏中的帮助页面与选择关卡界面都需要实现翻页效果。是要翻一页或者多页，使用的方法是让ScrollView用它自身长度的单位化比例来实现。为实现这个需求我们首先需要：</p><p>①content的总长</p><p>②玩家鼠标的开始位置与结束位置，并根据开始滑动与结束滑动的事件方式计算差值。若开始位置-结束位置&gt;0，则右滑；若开始位置-结束位置&lt;0，则左滑。通过差值来决定滑动几个单元格。</p><p>③移动一个单元格玩家鼠标需要滑动的距离<strong>（一个单元格长度+左偏移量）</strong>。</p><p>④移动多个单元格玩家鼠标需要滑动的距离。其中<strong>第一个是单元格长度+左偏移量，之后的每一个滑动都是单元格长度+间隔。</strong></p><p>⑤滑动一个单元格所占的比例，可通过<strong>一个单元格所在位置中点的长度/Content的总长度</strong>得到。其中上限值与下限值为防止超过我们的最小长度与最大长度。</p><p>最后，可以推算出Content宽度与单元格长度与数量的<code>关系式</code>：</p><p><strong>宽度=原来的宽度+（每一个单元格长度+间隙）*（单元格数量-1）</strong></p><h2 id="6-5-单页效果的实现"><a href="#6-5-单页效果的实现" class="headerlink" title="6.5 单页效果的实现"></a>6.5 单页效果的实现</h2><p>本游戏中，翻页效果的实现分为<code>单页效果</code>（每次只能滑动一个页面）和<code>多页效果</code>（一次可以滑动多个页面）。其中单页效果通过使用<strong>改变局部坐标</strong>的方法实现脚本的成员变量来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line">using DG.Tweening;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 单滑</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class SlideScrollView : MonoBehaviour,IBeginDragHandler,IEndDragHandler &#123;</span><br><span class="line"></span><br><span class="line">    private RectTransform contentTrans;</span><br><span class="line">    private float beginMousePositionX;</span><br><span class="line">    private float endMousePositionX;</span><br><span class="line">    private ScrollRect scrollRect;</span><br><span class="line"></span><br><span class="line">    public int cellLength;</span><br><span class="line">    public int spacing;</span><br><span class="line">    public int leftOffset;</span><br><span class="line">    private float moveOneItemLength;</span><br><span class="line"></span><br><span class="line">    private Vector3 currentContentLocalPos;&#x2F;&#x2F;上一次的位置</span><br><span class="line">    private Vector3 contentInitPos;&#x2F;&#x2F;Content初始位置</span><br><span class="line">    private Vector2 contentTransSize;&#x2F;&#x2F;Content初始大小</span><br><span class="line"></span><br><span class="line">    public int totalItemNum;</span><br><span class="line">    private int currentIndex;</span><br><span class="line"></span><br><span class="line">    public Text pageText;</span><br><span class="line"></span><br><span class="line">    public bool needSendMessage;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        scrollRect &#x3D; GetComponent&lt;ScrollRect&gt;();</span><br><span class="line">        contentTrans &#x3D; scrollRect.content;</span><br><span class="line">        moveOneItemLength &#x3D; cellLength + spacing;</span><br><span class="line">        currentContentLocalPos &#x3D; contentTrans.localPosition;</span><br><span class="line">        contentTransSize &#x3D; contentTrans.sizeDelta;</span><br><span class="line">        contentInitPos &#x3D; contentTrans.localPosition;</span><br><span class="line">        currentIndex &#x3D; 1;</span><br><span class="line">        if (pageText !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Init()</span><br><span class="line">    &#123;</span><br><span class="line">        currentIndex &#x3D; 1;</span><br><span class="line">       </span><br><span class="line">        if (contentTrans!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            contentTrans.localPosition &#x3D; contentInitPos;</span><br><span class="line">            currentContentLocalPos &#x3D; contentInitPos;</span><br><span class="line">            if (pageText !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 通过拖拽与松开来达成翻页效果</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line"></span><br><span class="line">    public void OnEndDrag(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        endMousePositionX &#x3D; Input.mousePosition.x;</span><br><span class="line">        float offSetX &#x3D; 0;</span><br><span class="line">        float moveDistance &#x3D; 0;&#x2F;&#x2F;当次需要滑动的距离</span><br><span class="line">        offSetX &#x3D; beginMousePositionX - endMousePositionX;</span><br><span class="line"></span><br><span class="line">        if (offSetX&gt;0)&#x2F;&#x2F;右滑</span><br><span class="line">        &#123;</span><br><span class="line">            if (currentIndex&gt;&#x3D;totalItemNum)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (needSendMessage)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdatePanel(true);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            moveDistance &#x3D; -moveOneItemLength;</span><br><span class="line">            currentIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#x2F;&#x2F;左滑</span><br><span class="line">        &#123;</span><br><span class="line">            if (currentIndex&lt;&#x3D;1)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (needSendMessage)</span><br><span class="line">            &#123;</span><br><span class="line">                UpdatePanel(false);</span><br><span class="line">            &#125;</span><br><span class="line">            moveDistance &#x3D; moveOneItemLength;</span><br><span class="line">            currentIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (pageText !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">        &#125;</span><br><span class="line">        DOTween.To(()&#x3D;&gt;contentTrans.localPosition,lerpValue&#x3D;&gt;contentTrans.localPosition&#x3D;lerpValue,currentContentLocalPos+new Vector3(moveDistance,0,0),0.5f).SetEase(Ease.OutQuint);</span><br><span class="line">        currentContentLocalPos +&#x3D; new Vector3(moveDistance, 0, 0);</span><br><span class="line">        &#x2F;&#x2F;只能存在于此项目</span><br><span class="line">        GameManager.Instance.audioSourceManager.PlayPagingAudioClip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 按钮来控制翻书效果</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line"></span><br><span class="line">    public void ToNextPage()</span><br><span class="line">    &#123;</span><br><span class="line">        float moveDistance &#x3D; 0;</span><br><span class="line">        if (currentIndex&gt;&#x3D;totalItemNum)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        moveDistance &#x3D; -moveOneItemLength;</span><br><span class="line">        currentIndex++;</span><br><span class="line">        if (pageText!&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needSendMessage)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdatePanel(true);</span><br><span class="line">        &#125;</span><br><span class="line">        DOTween.To(() &#x3D;&gt; contentTrans.localPosition, lerpValue &#x3D;&gt; contentTrans.localPosition &#x3D; lerpValue, currentContentLocalPos + new Vector3(moveDistance, 0, 0), 0.5f).SetEase(Ease.OutQuint);</span><br><span class="line">        currentContentLocalPos +&#x3D; new Vector3(moveDistance, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ToLastPage()</span><br><span class="line">    &#123;</span><br><span class="line">        float moveDistance &#x3D; 0;</span><br><span class="line">        if (currentIndex &lt;&#x3D;1)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        moveDistance &#x3D; moveOneItemLength;</span><br><span class="line">        currentIndex--;</span><br><span class="line">        if (pageText !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">        &#125;</span><br><span class="line">        if (needSendMessage)</span><br><span class="line">        &#123;</span><br><span class="line">            UpdatePanel(false);</span><br><span class="line">        &#125;</span><br><span class="line">        DOTween.To(() &#x3D;&gt; contentTrans.localPosition, lerpValue &#x3D;&gt; contentTrans.localPosition &#x3D; lerpValue, currentContentLocalPos + new Vector3(moveDistance, 0, 0), 0.5f).SetEase(Ease.OutQuint);</span><br><span class="line">        currentContentLocalPos +&#x3D; new Vector3(moveDistance, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnBeginDrag(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        beginMousePositionX &#x3D; Input.mousePosition.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;设置Content的大小</span><br><span class="line">    public void SetContentLength(int itemNum)</span><br><span class="line">    &#123;</span><br><span class="line">        contentTrans.sizeDelta &#x3D; new Vector2(contentTrans.sizeDelta.x+(cellLength+spacing)*(itemNum-1),contentTrans.sizeDelta.y);</span><br><span class="line">        totalItemNum &#x3D; itemNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化Content的大小</span><br><span class="line">    public void InitScrollLength()</span><br><span class="line">    &#123;</span><br><span class="line">        contentTrans.sizeDelta &#x3D; contentTransSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;发送翻页信息的方法</span><br><span class="line">    public void UpdatePanel(bool toNext)</span><br><span class="line">    &#123;</span><br><span class="line">        if (toNext)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SendMessageUpwards(&quot;ToNextLevel&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SendMessageUpwards(&quot;ToLastLevel&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-6-多页效果的实现"><a href="#6-6-多页效果的实现" class="headerlink" title="6.6 多页效果的实现"></a>6.6 多页效果的实现</h2><p>本游戏中，翻页效果的实现分为<code>单页效果</code>（每次只能滑动一个页面）和<code>多页效果</code>（一次可以滑动多个页面）。其中多页效果通过使用<strong>比例</strong>方法来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using UnityEngine.UI;</span><br><span class="line">using UnityEngine.EventSystems;</span><br><span class="line">using DG.Tweening;</span><br><span class="line"></span><br><span class="line">public class SlideCanCoverScrollView : MonoBehaviour,IBeginDragHandler,IEndDragHandler &#123;</span><br><span class="line"></span><br><span class="line">    private float contentLength;&#x2F;&#x2F;容器长度</span><br><span class="line">    private float beginMousePostionX;</span><br><span class="line">    private float endMousePositionX;</span><br><span class="line">    private ScrollRect scrollRect;</span><br><span class="line">    private float lastProportion;&#x2F;&#x2F;上一个位置比例</span><br><span class="line"></span><br><span class="line">    public int cellLength;&#x2F;&#x2F;每个单元格长度</span><br><span class="line">    public int spacing;&#x2F;&#x2F;间隙</span><br><span class="line">    public int leftOffset;&#x2F;&#x2F;左偏移量</span><br><span class="line">    private float upperLimit;&#x2F;&#x2F;上限值</span><br><span class="line">    private float lowerLimit;&#x2F;&#x2F;下限值</span><br><span class="line">    private float firstItemLength;&#x2F;&#x2F;移动第一个单元格的距离</span><br><span class="line">    private float oneItemLength;&#x2F;&#x2F;滑动一个单元格需要的距离</span><br><span class="line">    private float oneItemProportion;&#x2F;&#x2F;滑动一个单元格所占比例</span><br><span class="line"></span><br><span class="line">    public int totalItemNum;&#x2F;&#x2F;共有几个单元格</span><br><span class="line">    private int currentIndex;&#x2F;&#x2F;当前单元格索引</span><br><span class="line"></span><br><span class="line">    public Text pageText;</span><br><span class="line"></span><br><span class="line">    private void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        scrollRect &#x3D; GetComponent&lt;ScrollRect&gt;();</span><br><span class="line">        contentLength &#x3D; scrollRect.content.rect.xMax - 2 * leftOffset - cellLength;</span><br><span class="line">        firstItemLength &#x3D; cellLength &#x2F; 2 + leftOffset;</span><br><span class="line">        oneItemLength &#x3D; cellLength + spacing;</span><br><span class="line">        oneItemProportion &#x3D; oneItemLength &#x2F; contentLength;</span><br><span class="line">        upperLimit&#x3D;1- firstItemLength &#x2F; contentLength;</span><br><span class="line">        lowerLimit &#x3D; firstItemLength &#x2F; contentLength;</span><br><span class="line">        currentIndex &#x3D; 1;</span><br><span class="line">        scrollRect.horizontalNormalizedPosition &#x3D; 0;</span><br><span class="line">        if (pageText !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Init()</span><br><span class="line">    &#123;           </span><br><span class="line">        lastProportion &#x3D; 0;</span><br><span class="line">        currentIndex &#x3D; 1;</span><br><span class="line">        if (scrollRect !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            scrollRect.horizontalNormalizedPosition &#x3D; 0;</span><br><span class="line">            pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public void OnEndDrag(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        float offSetX &#x3D; 0;</span><br><span class="line">        endMousePositionX &#x3D; Input.mousePosition.x;</span><br><span class="line">        offSetX &#x3D; (beginMousePostionX - endMousePositionX)*2;</span><br><span class="line">        &#x2F;&#x2F;Debug.Log(&quot;offSetX:&quot; + offSetX);</span><br><span class="line">        &#x2F;&#x2F;Debug.Log(&quot;firstItemLength:&quot; + firstItemLength);</span><br><span class="line">        if (Mathf.Abs(offSetX)&gt;firstItemLength)&#x2F;&#x2F;执行滑动动作的前提是要大于第一个需要滑动的距离</span><br><span class="line">        &#123;</span><br><span class="line">            if (offSetX&gt;0)&#x2F;&#x2F;右滑</span><br><span class="line">            &#123;</span><br><span class="line">                if (currentIndex&gt;&#x3D;totalItemNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                int moveCount &#x3D; </span><br><span class="line">                    (int)((offSetX - firstItemLength) &#x2F; oneItemLength) + 1;&#x2F;&#x2F;当次可以移动的格子数目</span><br><span class="line">                currentIndex +&#x3D; moveCount;</span><br><span class="line">                if (currentIndex&gt;&#x3D;totalItemNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentIndex &#x3D; totalItemNum;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;当次需要移动的比例:上一次已经存在的单元格位置</span><br><span class="line">                &#x2F;&#x2F;的比例加上这一次需要去移动的比例</span><br><span class="line">                lastProportion +&#x3D; oneItemProportion * moveCount;</span><br><span class="line">                if (lastProportion&gt;&#x3D;upperLimit)</span><br><span class="line">                &#123;</span><br><span class="line">                    lastProportion &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            else &#x2F;&#x2F;左滑</span><br><span class="line">            &#123;</span><br><span class="line">                if (currentIndex &lt;&#x3D;1)</span><br><span class="line">                &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                int moveCount &#x3D;</span><br><span class="line">                    (int)((offSetX + firstItemLength) &#x2F; oneItemLength) - 1;&#x2F;&#x2F;当次可以移动的格子数目</span><br><span class="line">                currentIndex +&#x3D; moveCount;</span><br><span class="line">                if (currentIndex &lt;&#x3D;1)</span><br><span class="line">                &#123;</span><br><span class="line">                    currentIndex &#x3D; 1;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F;当次需要移动的比例:上一次已经存在的单元格位置</span><br><span class="line">                &#x2F;&#x2F;的比例加上这一次需要去移动的比例</span><br><span class="line">                lastProportion +&#x3D; oneItemProportion * moveCount;</span><br><span class="line">                if (lastProportion &lt;&#x3D; lowerLimit)</span><br><span class="line">                &#123;</span><br><span class="line">                    lastProportion &#x3D; 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pageText!&#x3D;null)</span><br><span class="line">            &#123;</span><br><span class="line">                pageText.text &#x3D; currentIndex.ToString() + &quot;&#x2F;&quot; + totalItemNum;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DOTween.To(() &#x3D;&gt; scrollRect.horizontalNormalizedPosition, lerpValue &#x3D;&gt; scrollRect.horizontalNormalizedPosition &#x3D; lerpValue, lastProportion, 0.5f).SetEase(Ease.OutQuint);</span><br><span class="line">        GameManager.Instance.audioSourceManager.PlayPagingAudioClip();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void OnBeginDrag(PointerEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        beginMousePostionX &#x3D; Input.mousePosition.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-7-UI实例化"><a href="#6-7-UI实例化" class="headerlink" title="6.7 UI实例化"></a>6.7 UI实例化</h2><p>游戏中需要不断地将不同的UIPanel实例化到<code>Canvas</code>下进行显示。但是由于使用工厂模式，<em>在实例化时会遇到UIPanel先实例化到Hierarchy中再设置其父对象。此时UIPanel的锚点就不是以Canvas的大小为准。</em></p><p><strong>解决这个问题可以通过将锚点由原来的“包裹父对象”更改为“居中显示”，并在实例化时在设置其父对象为Canvas后将对应Panel的Pos改为0，Scale改为1即可解决。</strong></p><p>UIPanel通过添加到UI管理字典，实例化当前场景所有面板，并存入字典。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;实例化当前场景所有面板，并存入字典</span><br><span class="line">public void InitDict()</span><br><span class="line">&#123;</span><br><span class="line">    foreach (var item in mUIManager.currentScenePanelDict)</span><br><span class="line">    &#123;</span><br><span class="line">        item.Value.transform.SetParent(canvasTransform);</span><br><span class="line">        item.Value.transform.localPosition &#x3D; Vector3.zero;</span><br><span class="line">        item.Value.transform.localScale &#x3D; Vector3.one;</span><br><span class="line">        IBasePanel basePanel &#x3D; item.Value.GetComponent&lt;IBasePanel&gt;();</span><br><span class="line">        if (basePanel &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(&quot;获取面板上IBasePanel脚本失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        basePanel.InitPanel();</span><br><span class="line">        &#x2F;&#x2F;Debug.Log(item.Key);</span><br><span class="line">        currentScenePanelDict.Add(item.Key, basePanel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;清空UIPanel字典</span><br><span class="line">public void ClearDict()</span><br><span class="line">&#123;</span><br><span class="line">    currentScenePanelDict.Clear();</span><br><span class="line">    mUIManager.ClearDict();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;添加UIPanel到UIManager字典</span><br><span class="line">public void AddPanelToDict(string uiPanelName)</span><br><span class="line">&#123;</span><br><span class="line">    mUIManager.currentScenePanelDict.Add(uiPanelName, GetGameObjectResource(FactoryType.UIPanelFactory, uiPanelName));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-8-克隆体名称问题与字符串截取"><a href="#6-8-克隆体名称问题与字符串截取" class="headerlink" title="6.8 克隆体名称问题与字符串截取"></a>6.8 克隆体名称问题与字符串截取</h2><p>游戏中实例化对象时，Instance方法会使用Perfabs的克隆体。因此实例化的对象会有(Clone)的后缀，在将对象放回对象池时会产生报空操作。解决这个问题的方法只需要对对象的名称进行截取，使用Substring()函数即可解决。</p><p>Substring的使用方法有两种：</p><ul><li>一是<strong>Substring(int startIndex)</strong> ，子字符串从指定的字符位置（第startIndex个字符）开始，一直到此字符串末尾。</li><li>二是<strong>Substring(int startIndex, int length)</strong>，子字符串从指定的字符位置第startIndex个字符）开始，且具有指定的长度（子字符串的长度length）。</li></ul><h2 id="6-9-控制渲染顺序"><a href="#6-9-控制渲染顺序" class="headerlink" title="6.9 控制渲染顺序"></a>6.9 控制渲染顺序</h2><p>游戏中直接通过工厂实例化的对象的渲染顺序会出现错误的遮挡关系，可以通过Transform.SetSiblingIndex(i)来控制渲染顺序。<strong>I越大则对象越后渲染。</strong></p><h2 id="6-10-主面板的左右移动动画"><a href="#6-10-主面板的左右移动动画" class="headerlink" title="6.10 主面板的左右移动动画"></a>6.10 主面板的左右移动动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using DG.Tweening;</span><br><span class="line"></span><br><span class="line">public class MainPanel : BasePanel &#123;</span><br><span class="line">    </span><br><span class="line">    private Tween[] mainPanelTween;&#x2F;&#x2F;0.右，1.左</span><br><span class="line">    private Tween ExitTween;&#x2F;&#x2F;离开主页运行的动画</span><br><span class="line"></span><br><span class="line">    protected override void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        base.Awake();</span><br><span class="line">        &#x2F;&#x2F;获取成员变量</span><br><span class="line">        transform.SetSiblingIndex(8);</span><br><span class="line"></span><br><span class="line">        mainPanelTween &#x3D; new Tween[2];</span><br><span class="line">        mainPanelTween[0] &#x3D; transform.DOLocalMoveX(1920, 0.5f);</span><br><span class="line">        mainPanelTween[0].SetAutoKill(false);</span><br><span class="line">        mainPanelTween[0].Pause();</span><br><span class="line">        mainPanelTween[1] &#x3D; transform.DOLocalMoveX(-1920, 0.5f);</span><br><span class="line">        mainPanelTween[1].SetAutoKill(false);</span><br><span class="line">        mainPanelTween[1].Pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void EnterPanel()</span><br><span class="line">    &#123;</span><br><span class="line">        transform.SetSiblingIndex(8);</span><br><span class="line">        if (ExitTween !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            ExitTween.PlayBackwards();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void ExitPanel()</span><br><span class="line">    &#123;</span><br><span class="line">        ExitTween.PlayForward();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void MoveToRight()</span><br><span class="line">    &#123;</span><br><span class="line">        mUIFacade.PlayButtonAudioClip();</span><br><span class="line">        ExitTween &#x3D; mainPanelTween[0];</span><br><span class="line">        mUIFacade.currentScenePanelDict[StringManager.SetPanel].EnterPanel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void MoveToLeft()</span><br><span class="line">    &#123;</span><br><span class="line">        mUIFacade.PlayButtonAudioClip();</span><br><span class="line">        ExitTween &#x3D; mainPanelTween[1];</span><br><span class="line">        mUIFacade.currentScenePanelDict[StringManager.HelpPanel].EnterPanel();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F;&#x2F;场景状态切换的方法</span><br><span class="line"></span><br><span class="line">    public void ToNormalModelScene()</span><br><span class="line">    &#123;</span><br><span class="line">        mUIFacade.PlayButtonAudioClip();</span><br><span class="line">        mUIFacade.currentScenePanelDict[StringManager.GameLoadPanel].EnterPanel();</span><br><span class="line">        mUIFacade.ChangeSceneState(new NormalGameOptionSceneState(mUIFacade));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-11-帮助面板的页面切换"><a href="#6-11-帮助面板的页面切换" class="headerlink" title="6.11 帮助面板的页面切换"></a>6.11 帮助面板的页面切换</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">using System.Collections;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using UnityEngine;</span><br><span class="line">using DG.Tweening;</span><br><span class="line">using UnityEngine.SceneManagement;</span><br><span class="line"></span><br><span class="line">public class HelpPanel : BasePanel &#123;</span><br><span class="line"></span><br><span class="line">    private GameObject helpPageGo;</span><br><span class="line">    private GameObject covidPageGo;</span><br><span class="line">    private GameObject defendPageGo;</span><br><span class="line">    private SlideScrollView slideScrollView;</span><br><span class="line">    private Tween helpPanelTween;</span><br><span class="line">    protected override void Awake()</span><br><span class="line">    &#123;</span><br><span class="line">        base.Awake();</span><br><span class="line">        helpPageGo &#x3D; transform.Find(&quot;HelpPage&quot;).gameObject;</span><br><span class="line">        covidPageGo &#x3D; transform.Find(&quot;CovidPage&quot;).gameObject;</span><br><span class="line">        defendPageGo &#x3D; transform.Find(&quot;DefendPage&quot;).gameObject;</span><br><span class="line">        slideScrollView &#x3D; transform.Find(&quot;HelpPage&quot;).Find(&quot;Scroll View&quot;).GetComponent&lt;SlideScrollView&gt;();</span><br><span class="line">        helpPanelTween &#x3D; transform.DOLocalMoveX(0, 0.5f);</span><br><span class="line">        helpPanelTween.SetAutoKill(false);</span><br><span class="line">        helpPanelTween.Pause();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;显示页面的方法</span><br><span class="line">    public void ShowHelpPage()</span><br><span class="line">    &#123;</span><br><span class="line">        if (!helpPageGo.activeSelf)</span><br><span class="line">        &#123;</span><br><span class="line">            mUIFacade.PlayButtonAudioClip();</span><br><span class="line">            helpPageGo.SetActive(true);</span><br><span class="line">        &#125;</span><br><span class="line">        covidPageGo.SetActive(false);</span><br><span class="line">        defendPageGo.SetActive(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ShowCovidPage()</span><br><span class="line">    &#123;</span><br><span class="line">        mUIFacade.PlayButtonAudioClip();</span><br><span class="line">        helpPageGo.SetActive(false);</span><br><span class="line">        covidPageGo.SetActive(true);</span><br><span class="line">        defendPageGo.SetActive(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void ShowDefendPage()</span><br><span class="line">    &#123;</span><br><span class="line">        mUIFacade.PlayButtonAudioClip();</span><br><span class="line">        helpPageGo.SetActive(false);</span><br><span class="line">        covidPageGo.SetActive(false);</span><br><span class="line">        defendPageGo.SetActive(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;处理面板的方法</span><br><span class="line"></span><br><span class="line">    public override void InitPanel()</span><br><span class="line">    &#123;</span><br><span class="line">        base.InitPanel();</span><br><span class="line"></span><br><span class="line">        transform.SetSiblingIndex(5);</span><br><span class="line">        </span><br><span class="line">        slideScrollView.Init();</span><br><span class="line">        ShowHelpPage();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;其他处理</span><br><span class="line">        if (transform.localPosition &#x3D;&#x3D; Vector3.zero)</span><br><span class="line">        &#123;</span><br><span class="line">            gameObject.SetActive(false);</span><br><span class="line">            helpPanelTween.PlayBackwards();</span><br><span class="line">        &#125;</span><br><span class="line">        transform.localPosition &#x3D; new Vector3(1920, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void EnterPanel()</span><br><span class="line">    &#123;</span><br><span class="line">        base.EnterPanel();</span><br><span class="line">        gameObject.SetActive(true);</span><br><span class="line">        slideScrollView.Init();</span><br><span class="line">        MoveToCenter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override void ExitPanel()</span><br><span class="line">    &#123;</span><br><span class="line">        base.ExitPanel();</span><br><span class="line">        mUIFacade.PlayButtonAudioClip();</span><br><span class="line">        &#x2F;&#x2F;选择场景</span><br><span class="line">        if (mUIFacade.currentSceneState.GetType() &#x3D;&#x3D; typeof(NormalGameOptionSceneState))</span><br><span class="line">        &#123;</span><br><span class="line">            mUIFacade.ChangeSceneState(new MainSceneState(mUIFacade));</span><br><span class="line">            SceneManager.LoadScene(1);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#x2F;&#x2F;如果是在主场景</span><br><span class="line">        &#123;</span><br><span class="line">            helpPanelTween.PlayBackwards();</span><br><span class="line">            mUIFacade.currentScenePanelDict[StringManager.MainPanel].EnterPanel();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void MoveToCenter()</span><br><span class="line">    &#123;</span><br><span class="line">        helpPanelTween.PlayForward();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-制图工具的实现"><a href="#7-制图工具的实现" class="headerlink" title="7. 制图工具的实现"></a>7. 制图工具的实现</h1><p>为了能过在工程中更方便快捷的开发游戏关卡地图，自定义了一个制图工具并使用宏<code>（Tool）</code>来将工具代码和游戏<code>（Game）</code>代码进行区分。将游戏场景划为6行12列，并将绘制好的地图保存为json文件。</p><div align=center><p><img src="image-20200519182550972.png" alt="地图编辑"></p></div><p>单击地图中的格子将该位置设为不可建塔区域，按住P键单击地图中的格子将该位置设为病毒入侵路径（路径按照点击顺序，只需要在起始点和转角区域点击即可），按住I键单击地图中的格子将该位置设为道具位置，多次点击可以切换道具（道具1占据1格，道具2占据2格，道具3占据4格）。</p><div align=center><p><img src="image-20200519182614903.png" alt="地图编辑工具"></p></div><p>Level为当前编辑的地图关卡，可手动设置。Round Info List为病毒波次以及每波怪物的设置。编辑完当前关卡的地图后可点击“保存当前关卡数据”将关卡数据保存为json文件，保存后的关卡数据可以再次读取编辑。</p><h1 id="8-游戏主逻辑"><a href="#8-游戏主逻辑" class="headerlink" title="8. 游戏主逻辑"></a>8. 游戏主逻辑</h1><h2 id="8-1-产怪逻辑"><a href="#8-1-产怪逻辑" class="headerlink" title="8.1 产怪逻辑"></a>8.1 产怪逻辑</h2><ol><li>Level对象控制round责任链的执行。</li><li>具体产怪的逻辑是通过round去执行的，round里存有本回合需要产生的怪物数量与ID，之后会把这些内容传入GameController去调用Invoke方法延时。</li><li>循环产生病毒。(把产怪方法封装在CameContoller里，而不是直接在round里去完成这个方法的原因:①需要延时循坏调用方法InvokeRepeating，它是Mono里的方法。②很多游戏逻辑类与信息存贮在了GameController里，所以我们必须这样去设计)。</li><li>但在生成病毒的时候，会出现玩家暂停产生病毒去建塔的情况，所以需要通过调用GameController的停止方法去停止延时调用。并且需要随时去打开。因此将暂停开关的监听放在Update方法里。</li><li>每次调用产怪方法的时候都需要去判断一下当前产怪是否完成当次回合的产怪总数，完成则停止。否则让产怪索引去累加。</li><li>即时监听玩家的杀怪数量。如果杀怪数量一旦等于当次回合怪物的总数，便调用level里的有关方法、把当前任务交给责任链的下一环，即进入下一个回合。每次调用Level有关方法的时候会判断责任链是否到达最后一环，如果到达，则显示最后一波有关逻辑，如果超过，则游戏胜利。</li></ol><h2 id="8-2-炮塔搜索目标的有关逻辑"><a href="#8-2-炮塔搜索目标的有关逻辑" class="headerlink" title="8.2 炮塔搜索目标的有关逻辑"></a>8.2 炮塔搜索目标的有关逻辑</h2><div align=center><img src="炮塔攻击逻辑.svg" alt="炮塔攻击逻辑" style="zoom:80%;" /></div><h2 id="8-3-建塔列表的优化"><a href="#8-3-建塔列表的优化" class="headerlink" title="8.3 建塔列表的优化"></a>8.3 建塔列表的优化</h2><p>游戏中建塔列表如下图。如果不对其进行优化列表在<code>左边缘、右边缘和上边缘</code>都不能完整显示。同理，销售与升级按钮也有这样的问题。因此需要对建塔列表与塔操作UI进行纠正。</p><div align=center><p><img src="image-20200519182831560.png" alt="建塔列表"></p></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;纠正建塔列表的位置</span><br><span class="line">private Vector3 CorrectTowerListGoPosition()</span><br><span class="line">&#123;</span><br><span class="line">    Vector3 correctPosition &#x3D; Vector3.zero;</span><br><span class="line">    if (gridIndex.xIndex &lt;&#x3D; 3 &amp;&amp; gridIndex.xIndex &gt;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        correctPosition +&#x3D; new Vector3(gameController.mapMaker.gridWidth, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (gridIndex.xIndex &lt;&#x3D; 11 &amp;&amp; gridIndex.xIndex &gt;&#x3D; 8)</span><br><span class="line">    &#123;</span><br><span class="line">        correctPosition -&#x3D; new Vector3(gameController.mapMaker.gridWidth, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    if (gridIndex.yIndex &lt;&#x3D; 2 &amp;&amp; gridIndex.yIndex &gt;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        correctPosition +&#x3D; new Vector3(0, gameController.mapMaker.gridHeight, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (gridIndex.yIndex &lt;&#x3D; 5 &amp;&amp; gridIndex.yIndex &gt;&#x3D; 3)</span><br><span class="line">    &#123;</span><br><span class="line">        correctPosition -&#x3D; new Vector3(0, gameController.mapMaker.gridHeight, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    correctPosition +&#x3D; transform.position;</span><br><span class="line">    return correctPosition;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;纠正操作塔UI画布的方法(纠正按钮位置的方法)</span><br><span class="line">private void CorrectHandleTowerCanvasGoPosition()</span><br><span class="line">&#123;</span><br><span class="line">    upLevelButtonTrans.localPosition &#x3D; Vector3.zero;</span><br><span class="line">    sellTowerButtonTrans.localPosition &#x3D; Vector3.zero;</span><br><span class="line">    if (gridIndex.yIndex &lt;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (gridIndex.xIndex &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            sellTowerButtonTrans.position +&#x3D; new Vector3(GameController.Instance.mapMaker.gridWidth * 3 &#x2F; 4, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            sellTowerButtonTrans.position -&#x3D; new Vector3(GameController.Instance.mapMaker.gridWidth * 3 &#x2F; 4, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        upLevelButtonTrans.localPosition &#x3D; upLevelButtonInitPos;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (gridIndex.yIndex &gt;&#x3D; 4)</span><br><span class="line">    &#123;</span><br><span class="line">        if (gridIndex.xIndex &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            upLevelButtonTrans.position +&#x3D; new Vector3(GameController.Instance.mapMaker.gridWidth * 3 &#x2F; 4, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            upLevelButtonTrans.position -&#x3D; new Vector3(GameController.Instance.mapMaker.gridWidth * 3 &#x2F; 4, 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        sellTowerButtonTrans.localPosition &#x3D; sellTowerButtonInitPos;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        upLevelButtonTrans.localPosition &#x3D; upLevelButtonInitPos;</span><br><span class="line">        sellTowerButtonTrans.localPosition &#x3D; sellTowerButtonInitPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-4-防御塔跟随目标朝向"><a href="#8-4-防御塔跟随目标朝向" class="headerlink" title="8.4 防御塔跟随目标朝向"></a>8.4 防御塔跟随目标朝向</h2><p>游戏中防御塔会跟随攻击目标旋转，这里使用的是Transform.LookAt()，但该函数在使用时会出现一个问题：<strong>由于塔与怪物不在同一层级上（深度不同），因此使用LookAt()函数会出现三维坐标上的旋转问题，投射到二维摄像机则会出现对象变形的情况。</strong>通过判定条件设置其x与y轴坐标即可修复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;旋转</span><br><span class="line">        &#x2F;&#x2F;transform.LookAt(targetTrans);</span><br><span class="line">        if (targetTrans.gameObject.tag &#x3D;&#x3D; &quot;Item&quot;)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.LookAt(targetTrans.position + new Vector3(0, 0, 3));</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            transform.LookAt(targetTrans.position);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (transform.eulerAngles.y &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            transform.eulerAngles +&#x3D; new Vector3(0, 90, 0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h1><p>游戏目前仍有一些不足点，例如：</p><ol><li>关卡少，还未设计其他关卡；</li><li>防御塔目前虽然有5种，但其攻击形式只有2种；</li><li>未实现游戏数据的存储功能；</li><li>未适配移动端的全面屏；</li><li>游戏的数值设计还不够科学。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;利用Unity独立开发的一个塔防类的小游戏~</summary>
    
    
    
    <category term="Unity" scheme="http://www.zanple.top/categories/Unity/"/>
    
    
    <category term="游戏" scheme="http://www.zanple.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity实时渲染-赛博朋克风格场景</title>
    <link href="http://www.zanple.top/2020/04/27/unity-realtime-cyberpunk/"/>
    <id>http://www.zanple.top/2020/04/27/unity-realtime-cyberpunk/</id>
    <published>2020-04-27T15:27:03.000Z</published>
    <updated>2020-09-05T15:51:18.194Z</updated>
    
    <content type="html"><![CDATA[<p>一个利用Unity完成的赛博朋克风格场景。</p><blockquote><p>在赛博世界，人类生活每一个细节都是受计算机网络控制的黑暗地带，由于商业巨头的过度膨胀，导致经济高过了政治，成为驱动世界前进的动力，于是我们看到庞大的跨国公司取代政府成为权力的中心。这种高强度的压抑氛围也导致部分的人性的泯灭，其中的许多人物都要靠一些高强度的刺激以激发人们对于一些事物的感知，所以在这个世界的很多角落里通常都会充斥各种暴力、毒品等过分裸露的事物，而那些雨夜与霓虹灯搭配起来的强烈视觉表现元素更好地阐述了日益发达的科技与日益淡薄的人性的这对尖锐的矛盾冲突。就如同希腊神话中用蜡烛翅膀奋力高飞的伊卡洛斯一样，在离太阳最近的时候，绽放了最美的瞬间，但翅膀的融化注定了陨落的命运。</p><p>——南宫萧宸，《从蒸汽时代到后启示录：幻想未来世界旅行不完全指南》</p></blockquote><a id="more"></a><div class="cusvideo"><iframe src="CyberPunk.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><blockquote><p>当提起赛博朋克这个词时，或许每个人在脑海中第一时间闪过的东西都不一样——“街道氤氲湿冷在霓虹灯下熙熙攘攘的场景” 、“‘高科技，低生活’的理念信条”、“沉溺虚拟世界最终幻灭的体验”、“配有《赛博朋克2077》LOGO的土味图’”……每一个都可以被叫做一个模因，它们都能看成赛博文化在进化中的 DNA。</p><p>——暴君，<a href="https://www.gcores.com/articles/112494">《当我们说起赛博朋克的时候，我们喜欢的究竟是什么？》</a></p></blockquote><p>赛博朋克在CDPR的<strong>《Cyberpunk2077》</strong>（2020最期待的游戏！没有之一！）面世后就引来了许多人的关注。因此想到利用Unity来完成一个赛博朋克场景的建立。</p><p>利用Unity实现的赛博朋克短片和场景有很多，比较有名的有<a href="https://assetstore.unity.com/publishers/5229">beffio</a>的《The Hunt》和<a href="https://assetstore.unity.com/publishers/585"><br>Manufactura K4</a>的Dark City2。此外还有UE4大神<a href="https://www.zhihu.com/people/zi-wu-xin">紫无心</a>的《霓虹中国》。</p><p><img src="TheHunt.jpg" alt="The Hunt"></p><p><img src="DarkCity2.jpg" alt="Dark City2"></p><p><img src="ziwuxin.jpg" alt="霓虹中国"></p><p>受《杀出重围》系列游戏（赛博朋克风格比较不错的游戏，值得一玩）的影响，我更倾向于霓虹元素稍微少的Low Life的低生活场景。因此使用了《Dark City2》的部分素材和一些其他模型来完成这个场景。</p><h1 id="2-灯光"><a href="#2-灯光" class="headerlink" title="2. 灯光"></a>2. 灯光</h1><p>灯光基本上都是用的点光源和自发光材质，部分使用了聚光灯（如建筑物的照灯）。</p><p><img src="image-20200428165606621.jpg" alt="灯光"></p><p>点光源主要是作为氛围光使用，平衡自发光的亮度。因此点光源的阴影就没那么重要，直接使用低分辨率的硬阴影并使用实时模式即可。</p><p>场景中还用了比较多的反射探针，反射探针的原理和光照探针类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把从这些邻近探针存储的反射结果传递给物体使用的反射纹理。</p><p><img src="image-20200428172155835.jpg" alt="场景中的反射探针"></p><p>场景中的反射探针基本上放在路面上来确保路面的反射效果，为减少对帧速率的影响，在Time Slicing（时间切片）中设置为All faces at once（每9帧更新一次）或Individual faces（每14帧更新一次）。</p><p>为增强地面的反射效果，再添加与Skybox相符的平行光。</p><div align=center><p><img src="image-20200428173321878.png" alt="左图为使用平行光的地面反射，右图为未使用平行光的地面反射"></p></div><h1 id="3-粒子效果"><a href="#3-粒子效果" class="headerlink" title="3. 粒子效果"></a>3. 粒子效果</h1><p>场景中运用到粒子效果的有三处：下水道的水汽、雨、电火花。</p><p><img src="image-20200428174846228.jpg" alt="下水道水汽效果"></p><p><img src="image-20200428174755713.jpg" alt="雨滴效果"></p><p><img src="image-20200428174946612.jpg" alt="电火花效果"></p><p>其中，街道地面的水花自然不是粒子器的效果，而是通过shader来实现（下次写一下这个效果的实现）。</p><div align=center><p><img src="image-20200428174712473.png" alt="地面的水花效果"></p></div><h1 id="4-LOD优化"><a href="#4-LOD优化" class="headerlink" title="4. LOD优化"></a>4. LOD优化</h1><p>一开始场景中直接使用的LOD0的模型，在运行时帧率较低。在进行LOD优化后帧率得到明显提升。</p><p>LOD是Level Of Details的缩写即多层次细节。在计算机图形学中，LOD就是为了支持当物体远离观察者或者物体的重要程度不同，位置不同，速度不同或者视角相关的参数不同需要减少渲染3D模型的复杂度。</p><p><img src="image-20200428180012231.jpg" alt="image-20200428180012231"></p><p>例如，同样的模型处在远处时，所占屏幕像素数会比较小，反正也是看不清楚了，这时候再渲染超多顶点的高精度的模型就会浪费计算性能。这时候如果在远处的能用更低精度的模型渲染，那么在不太影响渲染质量的情况下可以提高效率。上图则为同一物体的不同精细度模型。</p><div align=center><p><img src="image-20200428183151689.png" alt="LOD Group"></p></div><p>在Unity中为物体添加LOD Group组件并设置相应比例对应的模型即可。不过因为LOD使用了多个模型，所以会造成整个项目体积的增大，算是拿空间换性能的一种优化方法吧。</p><h1 id="5-后处理"><a href="#5-后处理" class="headerlink" title="5. 后处理"></a>5. 后处理</h1><h2 id="5-1-抗锯齿"><a href="#5-1-抗锯齿" class="headerlink" title="5.1 抗锯齿"></a>5.1 抗锯齿</h2><p>接着是使用Post-process进行后处理。首先在Post-process中通过开启SMAA抗锯齿来降低画面走样现象。SMAA是一种在FXAA的基础上改进的更高质量的抗锯齿方案。</p><p><img src="image-20200428184359923.jpg" alt="不同抗锯齿方案"></p><p>既然提到了抗锯齿，这里就简单的介绍一下常见的抗锯齿的方法：</p><ul><li><p><strong>SSAA （Supersample Anti-Aliasing）</strong><br>超采样抗锯齿就是最简单粗暴的也是最有效的抗锯齿方法，缺点就是性能太差。任何类型的走样归根结底都是因为欠采样，那么我们只需要增加采样数，就可以减轻走样现象。以4x为例，4xSSAA对于每个像素（Pixel）计算4个子像素，将4个子像素的颜色求平均值，便能获得抗锯齿后的颜色。</p><div align=center><p><img src="v2-940e167efe0b74854cf56082d084fbeb_r.jpg" alt="SSAA的原理"></p></div></li><li><p><strong>MSAA（Multisample Anti-Aliasing）</strong><br>SSAA中每个像素需要多次计算着色，这对实时渲染的开销是巨大的。因此在SSAA的基础上发展出了MSAA。MSAA其实和SSAA一样，也是基于硬件的实现，只是在增加采样点和平均的时候用了一些 Trick，大幅优化了 SSAA 的效率，当然代价就是对特定的锯齿完全没有优化效果。<br>和 SSAA 不同，MSAA 其实是 Per-Pixel Shading。GPU 打开 MSAA 后，会在光栅化阶段根据图元边缘的计算出其覆盖的像素，和对该像素内每一个 Sample 的覆盖关系（coverage mask），在执行 PixelShader 后写入颜色时，会根据覆盖关系把 PS 输出的颜色和 BackBuffer 颜色进行平均后作为最终结果。<br>由于MSAA拥有硬件支持，相对开销比较小，又能很好地解决几何走样问题，在游戏中应用非常广泛。</p><div align=center><p><img src="MultisamplingAnti-Aliasing.jpg" alt="MSAA的原理"></p></div><p>提到了MSAA，想起前几天知乎上<a href="https://www.zhihu.com/people/carcat">寒霜之爪</a>写的<a href="https://zhuanlan.zhihu.com/p/135444145">《延迟渲染与MSAA的那些事》</a>中提到的在延迟渲染中使用MSAA（这个在很多参考资料上都注明了延迟渲染不支持硬件抗锯齿）。</p></li><li><p><strong>FXAA （Fast Approximate Anti-Aliasing）</strong><br>FXAA 是由 NVDIA 发明的高效后处理抗锯齿方案，也是目前所有后处理抗锯齿方案里面同等设置下效率最高的抗锯齿算法。FXAA 的边缘提取是根据 SceneColor 的 Luma 值进行检测的，所以可以提取到高光、阴影，几何边缘，半透明物体。</p></li><li><p><strong>SMAA（增强型亚像素形态抗锯齿）</strong><br>SMAA 是由 CryEngine 开发的更注重效果的后处理抗锯齿方案，当然其效率在大多数移动平台上也是很难被接受的。它和FXAA的最大区别是会更具边缘的形状选择不同的周围像素进行模糊，尽量还原出合理的SubPixels。</p></li><li><p><strong>Temporal AA（Temporal Anti-Aliasing）</strong></p><p>严格来说TAA并不能算一个具体的算法，而是更像一个统一的算法框架。和SSAA一样，TAA也能够同时减轻几何走样和着色走样的问题。总体来说TAA也分为采样（sampling）和合成（resolve）两个过程，不同的TAA的具体实现也是围绕这两个部分有所变化。</p></li></ul><h2 id="5-2-Bloom"><a href="#5-2-Bloom" class="headerlink" title="5.2 Bloom"></a>5.2 Bloom</h2><p>Bloom特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。</p><p><img src="image-20200428214919470.jpg" alt="左图为原效果 右图为Bloom处理后的效果"></p><p>Bloom的实现原理很简单：我们首先根据一个阈值提取出图像中较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的结果。</p><p><code>HDR</code>是<code>High Dynamic Range</code>的缩写，即高动态范围，与之对应的是低动态范围（<code>Low Dynamic Range</code>，<code>LDR</code>）。常用HDR图片储存格式有hdr/tif/exr/raw等。我们身边的电子图片，几乎都是LDR。常用LDR图片储存格式有jpg/png等。</p><p>LDR只能算是对现实颜色进行压缩，并呈现出来。看似丰富，但真和现实中的颜色比，还是局限了许多，一旦需要进行调色等后续加工，便会因为颜色不够而难以进行。这便诞生了HDR。单通道位数超过8位，便可称为HDR，常见有12位和16位。</p><p>总的来说，利用HDR渲染<strong>让亮的物体可以真的非常亮，暗的物体可以真的非常暗，同时又可以看到两者之间的细节。</strong>而把HDR用ToneMapping压缩成LDR，再用Bloom表现高光溢出的效果。这是引擎内对画面的处理方式。</p><h1 id="6-渲染结果-4K"><a href="#6-渲染结果-4K" class="headerlink" title="6. 渲染结果(4K)"></a>6. 渲染结果(4K)</h1><p><img src="image_0884.jpg" alt="最终测试1"></p><p><img src="image_2001.jpg" alt="最终测试2"></p><blockquote><p>我们对赛博朋克的爱，并非从2077开始，也不会因此而结束。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;一个利用Unity完成的赛博朋克风格场景。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在赛博世界，人类生活每一个细节都是受计算机网络控制的黑暗地带，由于商业巨头的过度膨胀，导致经济高过了政治，成为驱动世界前进的动力，于是我们看到庞大的跨国公司取代政府成为权力的中心。这种高强度的压抑氛围也导致部分的人性的泯灭，其中的许多人物都要靠一些高强度的刺激以激发人们对于一些事物的感知，所以在这个世界的很多角落里通常都会充斥各种暴力、毒品等过分裸露的事物，而那些雨夜与霓虹灯搭配起来的强烈视觉表现元素更好地阐述了日益发达的科技与日益淡薄的人性的这对尖锐的矛盾冲突。就如同希腊神话中用蜡烛翅膀奋力高飞的伊卡洛斯一样，在离太阳最近的时候，绽放了最美的瞬间，但翅膀的融化注定了陨落的命运。&lt;/p&gt;
&lt;p&gt;——南宫萧宸，《从蒸汽时代到后启示录：幻想未来世界旅行不完全指南》&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Unity" scheme="http://www.zanple.top/categories/Unity/"/>
    
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="短片" scheme="http://www.zanple.top/tags/%E7%9F%AD%E7%89%87/"/>
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>Unity-扫描及透视效果的实现</title>
    <link href="http://www.zanple.top/2020/04/27/unity-scaneffect/"/>
    <id>http://www.zanple.top/2020/04/27/unity-scaneffect/</id>
    <published>2020-04-27T15:24:14.000Z</published>
    <updated>2020-09-05T08:17:18.159Z</updated>
    
    <content type="html"><![CDATA[<p>扫描效果在科幻游戏中比较常见，如APEX英雄、命运2、杀出重围、全境封锁2等中都有体现。大致的效果为光线扫描全场景，并高亮显示敌方（可透过障碍物）。<a id="more"></a>这里我选取了APEX英雄中“寻血猎犬”的“上帝之眼”技能为参考，按下“<strong>Q</strong>”后在短时间内扫描场景并显示范围内的敌人。</p><p><img src="APEX-Scan.gif" alt="APEX中“寻血猎犬”的扫描技能"></p><h1 id="1-效果分析"><a href="#1-效果分析" class="headerlink" title="1. 效果分析"></a>1. 效果分析</h1><p>扫描效果从当前视角蔓延，并根据扫描的位置显示对应的敌方，需要计算当前位置到扫描位置的距离。如果对场景中所有的对象进行计算，再将颜色叠加到物体上的效率显然较低。因此使用类似全局雾效基于屏幕后处理的实现方法，则不需要更改场景内渲染物体所使用的Shader代码，而仅仅依靠一次屏幕的后处理的步骤即可。</p><h1 id="2-直接使用深度值"><a href="#2-直接使用深度值" class="headerlink" title="2. 直接使用深度值"></a>2. 直接使用深度值</h1><p>扫描效果直接从相机位置发出，因此尝试直接使用相机获得的场景深度信息进行处理。</p><p>在脚本中，获得到深度信息后我们就可以得到场景中物体与相机的深度关系。利用<code>Unity Time类</code>中的<code>deltaTime</code>来影响扫描效果的移动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.dis +&#x3D; Time.deltaTime * this.velocity;</span><br></pre></td></tr></table></figure><p>然后通过<code>OnRenderImage()</code>函数抓取render texture，再通过<code>Graphics.Blit()</code>函数传递给虚拟材质中的Shader进行后处理。</p><p>在Shader中获取每个像素的深度信息，与扫描网所在位置比较进行颜色的叠加即可。</p><div align=center><p><img src="image-20200427234307373.png" alt="直接使用深度值的效果"></p></div><p>通过直接使用深度值信息进行叠加我们可以获得如上图的效果，但是这样的效果不够理想。首先是扫描网由摄像机所在位置发出，即从近裁剪平面发出，如果是用在固定视角的第一人称游戏不会有太大问题，<strong>但是应用在第三人称视角游戏的效果则不够理想，并且在移动过程中会影响后续的敌人高亮显示问题。</strong></p><h1 id="3-使用深度缓冲重构世界空间坐标"><a href="#3-使用深度缓冲重构世界空间坐标" class="headerlink" title="3. 使用深度缓冲重构世界空间坐标"></a>3. 使用深度缓冲重构世界空间坐标</h1><p>在上面的方法中是从摄像机发出扫描网的，但是我们想在角色所在位置发出，并且我们在游戏中可以看到的效果都是圆的而不是平面推出的方式。因此使用全局雾效里的使用深度缓冲来重构世界空间坐标。</p><div align=center><p><img src="image-20200427234427915.png" alt="重构空间坐标"></p></div><p>通过对图形空间下的视锥体的四个顶点进行插值，然后通过采样当前像素的深度值，将这个线性深度值与插值后的结果相乘便能得到世界空间中相机到远裁剪平面的向量，其大小等于到采样像素的距离。最后再加上相机的世界空间坐标，我们就可以得到每个像素的世界空间坐标了。</p><p>当然，也可以通过深度和像素在屏幕上的坐标以及CVV到屏幕矩阵的逆投影矩阵逆摄像机矩阵计算出像素的世界空间坐标，然后和在世界空间中定义的扫描平面计算距离。但这样的做法需要涉及到矩阵的计算。</p><h1 id="4-扫描网效果"><a href="#4-扫描网效果" class="headerlink" title="4. 扫描网效果"></a>4. 扫描网效果</h1><p>扫描网的效果上我选取的还是APEX英雄中“寻血猎犬”的技能为例：</p><p><img src="ScanEffect.mp4_20200419_125601.183.png" alt="APEX英雄扫描特效"></p><p>扫描网的移动上，为了避免扫描网的无限延伸（到天空盒），对扫描网的距离进行判断。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (juli &lt; _ScanDistance &amp;&amp; juli &gt; _ScanDistance - _ScanWidth &amp;&amp; linearDepth &lt; 1)</span><br></pre></td></tr></table></figure><p>同时，另扫描网的移动速度随着时间增加（实现扫描网逐渐加速的效果）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScanDistance +&#x3D; Time.deltaTime * 50;</span><br></pre></td></tr></table></figure><p>扫描网的视觉效果由4个变量来控制，分别为边缘清晰度、边缘颜色、中部颜色、尾迹颜色。并使用水平线填充扫描网。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">_HeadTough(&quot;边缘清晰度&quot;, float) &#x3D; 10</span><br><span class="line">_HeadColor(&quot;边缘颜色&quot;, Color) &#x3D; (1, 1, 1, 0)</span><br><span class="line">_MidColor(&quot;中部颜色&quot;, Color) &#x3D; (1, 1, 1, 0)</span><br><span class="line">_LastColor(&quot;尾迹颜色&quot;, Color) &#x3D; (1, 1, 1, 0)</span><br><span class="line">_LineColor(&quot;水平线颜色&quot;, Color) &#x3D; (0.5, 0.5, 0.5, 0)</span><br><span class="line">……</span><br><span class="line">if (juli &lt; _ScanDistance &amp;&amp; juli &gt; _ScanDistance - _ScanWidth &amp;&amp; linearDepth &lt; 1)</span><br><span class="line">&#123;</span><br><span class="line">float chazhi &#x3D; 1 - (_ScanDistance - juli) &#x2F; (_ScanWidth); &#x2F;&#x2F;给定距离减去像素距离再除去给定的宽度，使得结果在0到1之间变化，再用1减去归一化的这个值</span><br><span class="line">half4 edge &#x3D; lerp(_MidColor, _HeadColor, pow(chazhi, _HeadTough));&#x2F;&#x2F;用幂函数来提高边缘颜色的权重</span><br><span class="line">scanColor &#x3D; lerp(_LastColor, edge, chazhi) + lineEffect(i.uv) * _LineColor;&#x2F;&#x2F;把条纹乘上一个颜色</span><br><span class="line">scanColor *&#x3D; chazhi;&#x2F;&#x2F;以上三行用于混合三个颜色 使用了不同的值作为插值函数的权重</span><br><span class="line">&#125;</span><br><span class="line">return col + scanColor;&#x2F;&#x2F;叠加到扫描颜色中</span><br></pre></td></tr></table></figure><h1 id="5-敌人高亮显示"><a href="#5-敌人高亮显示" class="headerlink" title="5. 敌人高亮显示"></a>5. 敌人高亮显示</h1><p>在APEX英雄中“寻血猎犬”的技能中，被扫描到的敌人会进行描边处理，并且这个描边是可以透过障碍物看到的。</p><p><img src="ScanEffect.mp4_20200419_125601.183.png" alt="APEX英雄扫描特效"></p><p>实现这样的效果只需要利用两个Pass分别对被遮住和未被遮住的物体进行处理即可。然后根据观察方向和目标多边形的法线方向的夹角来判断目标的边缘，从而实现描边效果。</p><div align=center><p><img src="image-20200427234655611.png" alt="视线与法线"></p></div><p>敌人的高亮描边效果应该在扫描网扫描目标敌方后才出现，并且这个效果应该只会保持一定的时间然后恢复正常。因此添加一个<code>BeenScan</code>脚本来控制目标敌方的不同显示效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void Highlight() &#123;</span><br><span class="line">        Material material &#x3D; Resources.Load(&quot;Material&#x2F;Browm-bear 1&quot;, typeof(Material)) as Material;</span><br><span class="line">        GetComponent&lt;Renderer&gt;().material &#x3D; material;</span><br><span class="line">        numCal++;</span><br><span class="line">        if(numCal &gt; 180)</span><br><span class="line">        &#123;</span><br><span class="line">            Material material2 &#x3D; Resources.Load(&quot;Material&#x2F;Browm-bear&quot;, typeof(Material)) as Material;</span><br><span class="line">            GetComponent&lt;Renderer&gt;().material &#x3D; material2;</span><br><span class="line">        &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，在<code>ScanEffect</code>中判断扫描网是否扫描到了目标敌方来调用<code>BeenScan</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foreach (BeerBeenScan s in _beenscanB)</span><br><span class="line">            &#123;</span><br><span class="line">                if (Vector3.Distance(ScanOrigin.position, Bear.transform.position) &lt;&#x3D; ScanDistance)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.Highlight();</span><br><span class="line">                    if (_crossingB)</span><br><span class="line">                    &#123;</span><br><span class="line">                        s.numCal &#x3D; 0;</span><br><span class="line">                        _crossingB &#x3D; false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><h1 id="6-最终效果"><a href="#6-最终效果" class="headerlink" title="6. 最终效果"></a>6. 最终效果</h1><p><img src="ScanEffect.gif" alt="效果展示"></p><hr><p>[1] <a href="https://blogs.unity3d.com/cn/2011/09/08/special-effects-with-depth-talk-at-siggraph/">“Special Effects with Depth” talk at SIGGRAPH - Kuba Cupisz</a></p><p>[2] <a href="https://www.youtube.com/watch?v=OKoNp2RqE9A">Shaders Case Study - No Man’s Sky: Topographic Scanner</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;扫描效果在科幻游戏中比较常见，如APEX英雄、命运2、杀出重围、全境封锁2等中都有体现。大致的效果为光线扫描全场景，并高亮显示敌方（可透过障碍物）。</summary>
    
    
    
    <category term="Shader" scheme="http://www.zanple.top/categories/Shader/"/>
    
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
    <category term="Shader" scheme="http://www.zanple.top/tags/Shader/"/>
    
    <category term="Game" scheme="http://www.zanple.top/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>Unity中DoTween插件的缓动函数</title>
    <link href="http://www.zanple.top/2020/04/13/unity-dotween-ease/"/>
    <id>http://www.zanple.top/2020/04/13/unity-dotween-ease/</id>
    <published>2020-04-13T15:45:56.000Z</published>
    <updated>2020-04-14T08:26:12.729Z</updated>
    
    <content type="html"><![CDATA[<p>最近在Unity中使用 DOTween插件来配置UI动画，了解到了几种常见的缓动函数。</p><p><strong>缓动函数</strong>指定动画效果在执行时的速度，用于控制动画从初始值运动到最终值的速率。如摄像机的运动、灯光的渐弱、汽车的启动等，这些速度的变化都不是线性的。所以适当的使用动画能让用户得到更舒适的观感，使其看起来更加真实。<a id="more"></a></p><h1 id="1-缓动函数"><a href="#1-缓动函数" class="headerlink" title="1. 缓动函数"></a>1. 缓动函数</h1><p>目前已经有一些常用的缓动函数曲线了，特殊情况需要图素进行复杂复合动作，需要严丝合缝的控制函数变化的时间点的话才使用自定义曲线来解决。</p><p>缓动函数的效果一般都分为三个缓动方式，分别是：</p><ul><li><strong>ease-in</strong>：表示缓入动画，动画的速度先慢后快，为从0开始加速的缓动。缓入动画会在速度最快时停止，这会让动画结束得很突然，因为自然界中的运动总是慢慢减速后才停止的。</li><li><strong>ease-out</strong> ：表示缓出动画，与缓入动画正好相反，缓出动画的速度先快后慢，为减速到0的缓动。</li><li><strong>ease-in-out</strong>： 表示缓入缓出动画，它的速度由慢变快，最后再变慢，前半段从0开始加速，后半段减速到0的缓动。</li></ul><p>其中<strong>Linear</strong>为线性动画，动画从开始到结束一直是同样的速度，没有缓动效果。</p><h1 id="2-缓动函数速查表"><a href="#2-缓动函数速查表" class="headerlink" title="2. 缓动函数速查表"></a>2. 缓动函数速查表</h1><iframe   src="https://www.xuanfengge.com/easeing/easeing/" width="100%" height="1300px"   frameborder="0"  name="缓动函数速查表"     scrolling="no" sandbox="allow-scripts">   </iframe><hr><p><em>*缓动函数速查表:<a href="http://www.xuanfengge.com/easeing/easeing/">http://www.xuanfengge.com/easeing/easeing/</a></em></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在Unity中使用 DOTween插件来配置UI动画，了解到了几种常见的缓动函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓动函数&lt;/strong&gt;指定动画效果在执行时的速度，用于控制动画从初始值运动到最终值的速率。如摄像机的运动、灯光的渐弱、汽车的启动等，这些速度的变化都不是线性的。所以适当的使用动画能让用户得到更舒适的观感，使其看起来更加真实。</summary>
    
    
    
    <category term="Unity" scheme="http://www.zanple.top/categories/Unity/"/>
    
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
  </entry>
  
  <entry>
    <title>计算机图形学-Unity中矩阵变换、坐标空间的回顾</title>
    <link href="http://www.zanple.top/2020/04/07/cg-unity-matrix/"/>
    <id>http://www.zanple.top/2020/04/07/cg-unity-matrix/</id>
    <published>2020-04-07T13:35:22.000Z</published>
    <updated>2020-04-08T15:21:18.474Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这几天重新回顾了一下图形学在Unity中的应用。主要是针对矩阵变换、坐标空间和法线变换的内容。<a id="more"></a></p></blockquote><h1 id="1-矩阵与矩阵变换"><a href="#1-矩阵与矩阵变换" class="headerlink" title="1. 矩阵与矩阵变换"></a>1. 矩阵与矩阵变换</h1><h2 id="1-1-矩阵"><a href="#1-1-矩阵" class="headerlink" title="1.1 矩阵"></a>1.1 矩阵</h2><p>向量的矩阵表示：设已知向量</p><p>$$<br>\vec{R}=a \vec{\imath}+b \cdot \vec{\jmath}+c \cdot \vec{k}<br>$$</p><p>则可用矩阵表示为</p><p>$$\vec{R}=\left[\begin{array}{lll}a & b & c\end{array}\right] \cdot\left[\begin{array}{c}\vec{i} \\\vec{j} \\\vec{k}\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><h2 id="1-2-齐次坐标表示法"><a href="#1-2-齐次坐标表示法" class="headerlink" title="1.2 齐次坐标表示法"></a>1.2 齐次坐标表示法</h2><p>由n+1维向量表示一个n维向量。如n维向量(P1,P2, … ,Pn)表示为(hP1,hP2,…,hPn,h) ，其中h称为哑坐标。其作用为：</p><ol><li>将各种变换用阶数统一的矩阵来表示。提供了用矩阵运算把二维、三维甚至高维空间上的一个点从一个坐标系变换到另一坐标系的有效方法。</li><li>便于表示无穷远点：例如：（x<em>x</em>h, y<em>x</em>h, h) ，令h等于0。</li><li>齐次坐标变换矩阵形式把直线变换成直线段，平面变换成平面，多边形变换成多边形，多面体变换成多面体。（图形拓扑关系保持不变)</li><li>变换具有统一表示形式的优点：便于变换合成，便于硬件实现。</li></ol><h2 id="1-3-行矩阵还是列矩阵"><a href="#1-3-行矩阵还是列矩阵" class="headerlink" title="1.3 行矩阵还是列矩阵"></a>1.3 行矩阵还是列矩阵</h2><p>在Unity中，常规做法是把矢量放在矩阵的<code>右侧</code>，即把矢量转换为列矩阵来进行运算。这意味着，在Unity中的矩阵乘法通常都是<code>右乘</code>，例如：</p><p>$$<br>\mathbf{C B A v}=(\mathbf{C}(\mathbf{B}(\mathbf{A v})))<br>$$</p><p>使用列矩阵意味着我们对上式的阅读顺序为从右到左，即先对<strong><em>v</em></strong>使用<strong><em>A</em></strong>进行变换，再使用<strong><em>B</em></strong>进行变换，最后使用<strong><em>C</em></strong>进行变换。</p><h1 id="2-矩阵变换"><a href="#2-矩阵变换" class="headerlink" title="2. 矩阵变换"></a>2. 矩阵变换</h1><h2 id="2-1-二维变换矩阵"><a href="#2-1-二维变换矩阵" class="headerlink" title="2.1 二维变换矩阵"></a>2.1 二维变换矩阵</h2><p>由于我们在Unity中基本上使用的都是三维矩阵的变换，所以在这里就不过多讨论二维矩阵的变换，只给出二维变换矩阵的统一表达式：</p><p>$$ \begin{bmatrix}   a & b & p \\   c & d & q \\   m & n & s  \end{bmatrix}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><div align=center><img src="image-20200407231704728.png" alt="二维变换" style="zoom:60%;" /><img src="image-20200407231725775.png" alt="二维变换中的基本操作" style="zoom:60%;" /></div><h2 id="2-2-三维变换矩阵"><a href="#2-2-三维变换矩阵" class="headerlink" title="2.2 三维变换矩阵"></a>2.2 三维变换矩阵</h2><p>线性变换指哪些可以保留<code>矢量加</code>和<code>标量乘</code>的变换。对于所有线性变换来说，如果我们要对一个三维的矢量进行变换，那么仅仅使用3X3的矩阵就可以表示所有的<code>线性变换</code>。但是3X3矩阵不能表示<code>平移操作</code>，因此将其扩展为4X4矩阵（齐次坐标）。</p><h3 id="2-2-1-基本操作"><a href="#2-2-1-基本操作" class="headerlink" title="2.2.1 基本操作"></a>2.2.1 基本操作</h3><p>平移矩阵：</p><p>$$ \begin{bmatrix}   1 & 0 & 0 & t_{x} \\   0 & 1 & 0 & t_{y} \\   0 & 0 & 1 & t_{z} \\   0 & 0 & 0 & 1  \end{bmatrix}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>缩放矩阵：</p><p>$$ \begin{bmatrix}   k_{x} & 0 & 0 & 0 \\   0 & k_{y} & 0 & 0 \\   0 & 0 & k_{z} & 0 \\   0 & 0 & 0 & 1  \end{bmatrix}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>旋转矩阵：</p><p>$$\mathbf{R}_{x}(\theta)=\left[\begin{array}{cccc}1 & 0 & 0 & 0 \\0 & \cos \theta & -\sin \theta & 0 \\0 & \sin \theta & \cos \theta & 0 \\0 & 0 & 0 & 1\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>$$\mathbf{R}_{y}(\theta)=\left[\begin{array}{cccc}\cos \theta & 0 & \sin \theta & 0 \\0 & 1 & 0 & 0 \\-\sin \theta & 0 & \cos \theta & 0 \\0 & 0 & 0 & 1\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>$$\mathbf{R}_{z}(\theta)=\left[\begin{array}{cccc}\cos \theta & -\sin \theta & 0 & 0 \\\sin \theta & \cos \theta & 0 & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>对矢量的变换则利用该矢量的列矩阵与上述矩阵点乘即可。</p><p>$$ \begin{bmatrix}   x \\   y \\   z \\   1  \end{bmatrix}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><h3 id="2-2-2-复合变换"><a href="#2-2-2-复合变换" class="headerlink" title="2.2.2 复合变换"></a>2.2.2 复合变换</h3><p>复合变换可通过矩阵的串联来实现，可以使用下面的公式来计算：</p><p>$$<br>\mathbf{p_{new}}=\mathbf{M_{tramslation}}\mathbf{M_{rotation}}\mathbf{M_{scale}}\mathbf{p_{old}}<br>$$<br>由于我们使用的是列矩阵，因此阅读顺序是<code>从右到左</code>，即先进行缩放变换，再进行旋转变换，最后进行平移变换。</p><blockquote><p>在绝大多数情况下，我们约定变换的顺序是先<code>缩放</code>，再<code>旋转</code>，最后<code>平移</code>。</p></blockquote><p>还有个要注意的是旋转的变换顺序。如果要同时绕三个轴进行旋转，在Unity中旋转的顺序是<code>zxy</code>，这意味着组合旋转变换矩阵是：</p><p>$$M_{r o t a t a _Z} M_{r o t a t a _X} M_{r o t a t a _Y}=\left[\begin{array}{cccc}\cos \theta _{Z} & -\sin \theta _{Z} & 0 & 0 \\\sin \theta _{Z} & \cos \theta _{Z} & 0 & 0 \\0 & 0 & 1 & 0 \\0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{cccc}1 & 0 & 0 & 0 \\0 & \cos \theta _{X} & -\sin \theta _{X} & 0 \\0 & \sin \theta _{X} & \cos \theta _{X} & 0 \\0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{cccc}\cos \theta _{Y} & 0 & \sin \theta _{Y} & 0 \\0 & 1 & 0 & 0 \\-\sin \theta _{Y} & 0 & \cos \theta _{Y} & 0 \\0 & 0 & 0 & 1\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>由于Unity文档中说明的旋转顺序是在旋转过程中<strong>保持坐标轴不变</strong>的（不是那种旋转一个轴后由于自身方向的改变再按新的坐标轴的旋转的顺序），所以在这里按<code>zxy</code>顺序旋转和<strong>带坐标轴旋转</strong>的<code>yxz</code>顺序旋转是一样的。</p><h1 id="3-坐标空间"><a href="#3-坐标空间" class="headerlink" title="3. 坐标空间"></a>3. 坐标空间</h1><h2 id="3-1-坐标空间变换"><a href="#3-1-坐标空间变换" class="headerlink" title="3.1 坐标空间变换"></a>3.1 坐标空间变换</h2><p>$$\mathbf{M}_{c\rightarrow p}=\left[\begin{array}{cccc}| & | & | & | \\\mathbf x_{c} & \mathbf y_{c} & \mathbf z_{c} & \mathbf O_{c} \\| & | & | & | \\0 & 0 & 0 & 1\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>其中，<br>$$<br>\mathbf{M}_{c\rightarrow p}<br>$$<br>表示的是从<strong>子坐标空间变换到父坐标空间</strong>变换的变换矩阵，其逆矩阵这位从<strong>父坐标空间变换到子坐标空间变换</strong>的变换矩阵。</p><p>我们知道，矢量是没有位置的，因此坐标空间的原点变换是可以忽略的。也就是说，我们仅仅平移坐标系的原点是不会对矢量造成任何影响的。那么，对矢量的坐标空间变换就可以使用3X3的矩阵来表示，因为我们不需要表示平移变换。那么变换矩阵就是：</p><p>$$\mathbf{M}_{c\rightarrow p} =\left[\begin{array}{cccc}| & | & | \\\mathbf x_{c} & \mathbf y_{c} & \mathbf z_{c} \\| & | & | \end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>其逆矩阵则为：</p><p>$$\mathbf{M}_{c\rightarrow p} =\left[\begin{array}{cccc}- & \mathbf x_{B} & - \\- & \mathbf y_{B} & - \\- & \mathbf z_{B} & - \end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>在Shader中，我们常常会看到截取变换矩阵的<strong>前3行和前3列</strong>来对<code>法线方向</code>、<code>光照方向</code>来进行空间变换，这正是原因所在。</p><hr><p>例如我们想把一个矢量从坐标空间$ \mathbf A $变换到坐标空间$ \mathbf B $，而且我们已经知道坐标空间$ \mathbf B $的x轴、y轴、z轴在空间$ \mathbf A $下的表示，即$\mathbf x_{B} $、$ \mathbf y_{B} $和$ \mathbf z_{B} $。那么想要得到从$ \mathbf A $到$ \mathbf B $的变换矩阵$ \mathbf{M}_{c\rightarrow p} $，我们可以用$ \mathbf{M}_{c\rightarrow p} $来变换$\mathbf  x_{B} $，那么得到的结果应该是(1,0,0)，那么我们按行来摆放就有：$$\mathbf{M}_{A\rightarrow B} \mathbf x_{B} =\left[\begin{array}{cccc}- & \mathbf x_{B} & - \\- & \mathbf y_{B} & - \\- & \mathbf z_{B} & - \end{array}\right]\mathbf x_{B} =\left[\begin{array}{cccc}\mathbf x_{B} \cdot \mathbf x_{B} \\\mathbf y_{B} \cdot \mathbf y_{B} \\\mathbf z_{B} \cdot \mathbf z_{B} \end{array}\right]=\left[\begin{array}{cccc}1 \\0 \\0 \end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><hr><h2 id="3-2-模型空间"><a href="#3-2-模型空间" class="headerlink" title="3.2 模型空间"></a>3.2 模型空间</h2><p>下面我们要说说，在渲染流水线中，顶点在各个空间的变换过程。</p><h3 id="3-2-1-模型空间"><a href="#3-2-1-模型空间" class="headerlink" title="3.2.1 模型空间"></a>3.2.1 模型空间</h3><p><strong>模型空间（model space）</strong>也叫对象空间（object space）或局部空间（local space）。每个模型都有自己独立的坐标空间，当它移动或旋转时，模型空间也会跟着移动和旋转。</p><h3 id="3-2-2-世界空间"><a href="#3-2-2-世界空间" class="headerlink" title="3.2.2 世界空间"></a>3.2.2 世界空间</h3><p><strong>世界空间（world space）</strong>相对于模型空间，世界空间是模型所在的最外层的父空间。Unity中，世界空间同样是左手坐标系，原点是游戏空间的中心，x、y、z轴固定不变。</p><h3 id="3-2-3-观察空间"><a href="#3-2-3-观察空间" class="headerlink" title="3.2.3 观察空间"></a>3.2.3 观察空间</h3><p><strong>观察空间（view space）</strong>观察空间也被称为摄像机空间，在观察空间中，摄像机位于原点，它决定了我们渲染游戏所使用的视角，观察空间采用的是右手坐标系，所以+z轴指的是摄像机后方。</p><p>为了得到顶点在观察空间的位置，我们可以有两种方法。</p><ol><li><p>一是计算观察空间的三个坐标轴在世界空间的表示，然后算出观察空间到世界空间的变换矩阵，再求逆得住世界空间到观察空间的变换矩阵。</p></li><li><p>二是平移整个观察空间，让摄像机原点位于世界空间原点，坐标轴与世界空间坐标轴重合。两种方法得到的变换矩阵是一样的。</p></li></ol><p>这里我们用第二种方法，有一点很重要，我们上面说过世界空间的变换顺序公式是<code>先缩放，再旋转，再平移</code>，而这里我们为了把摄像机移回世界坐标原点，我们需要<strong>逆向变换</strong>，所以是<code>先平移，再旋转，再缩放</code>。<br>$$<br>\mathbf{M_{view}}=\mathbf{M_{scale}}\mathbf{M_{rotation}}\mathbf{M_{tramslation}}<br>$$<br>因为观察空间是右手坐标系，与世界空间的左手坐标系z轴相反，所以<code>z分量</code>要<strong>取反</strong>操作：</p><h3 id="3-2-4-裁剪空间-透视投影"><a href="#3-2-4-裁剪空间-透视投影" class="headerlink" title="3.2.4 裁剪空间-透视投影"></a>3.2.4 裁剪空间-透视投影</h3><p>我们先看看透视投影的6个裁剪平面怎么决定的。在Unity中，它们由Camera组件中的参数和Game视图的<strong>纵横比</strong>共同决定。如图所示：</p><div align=center><img src="projection_frustum.png" alt="透视摄像机的参数对透视投影视锥体的影响" style="zoom:80%;" /></div><p>上图中Camera的<code>Field of View(FOV)</code>决定视锥体竖直方向的张开角度，<code>Clipping Planes</code>中的<code>Near</code>和<code>Far</code>决定视锥体的近裁剪平面和远裁剪平面距离摄像机的远近，这样就可以求出近和远裁剪平面的高度：</p><p>$$\begin{aligned}&\text {nearClipPlaneHeight}=2 \cdot \text {Near} \cdot \tan \frac{F O V}{2}\\&\text {farClipPlaneHeight}=2 \cdot \text {Far} \cdot \tan \frac{F O V}{2}\end{aligned}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>而横向信息由摄像机的纵横比决定。这个纵横比由Game视图的纵横比和Viewport Rect中的W和H属性共同决定（Unity中可以通过Camera.aspect获得）。假设纵横比为<strong>Aspect</strong>，则：</p><p>$$\begin{aligned}\text {Aspect} &=\frac{\text {nearClipPlaneWidth}}{\text {nearClipPlaneHeight}} \\\text {Aspect} &=\frac{\text {farClipPlaneWidth}}{\text {farClipPlaneHeight}}\end{aligned}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>这样可以确定透视投影的投影矩阵：</p><p>$$\mathbf{M}_{\text {frustum}}=\left[\begin{array}{cccc}\frac{\cot \frac{F O V}{2}}{A s p e c t} & 0 & 0 & 0 \\0 & \cot \frac{F O V}{2} & 0 & 0 \\0 & 0 & -\frac{F a r+N e a r}{F a r-N e a r} & -\frac{2 \cdot N e a r \cdot F a r}{F a r-N e a r} \\0 & 0 & -1 & 0\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>这个投影矩阵是建立在<code>Unity坐标系</code>上，观察空间是<code>右手坐标系</code>，使用列矩阵<strong>右乘</strong>，且变换后z分量在[-w, w]之间。但在<code>DirectX</code>中，z分量在[0, w]之间，上面的透视矩阵就要更改了。</p><p>用上一步观察空间得到的坐标和投影矩阵相乘，就可以变换到裁剪空间中：</p><p>$$\mathbf p_{clip}=\mathbf M_{frustum}\mathbf P_{view}=\left[\begin{array}{cccc}\frac{\cot \frac{F O V}{2}}{A s p e c t} & 0 & 0 & 0 \\0 & \cot \frac{F O V}{2} & 0 & 0 \\0 & 0 & -\frac{F a r+N e a r}{F a r-N e a r} & -\frac{2 \cdot N e a r \cdot F a r}{F a r-N e a r} \\0 & 0 & -1 & 0\end{array}\right]\left[\begin{array}{l}x \\y \\z \\1\end{array}\right]=\left[\begin{array}{c}x\frac{\cot \frac{F O V}{2}}{A s p e c t}  \\y \cot \frac{F O V}{2} \\-z \frac{F a r+N e a r}{F a r-N e a r}-\frac{2 \cdot N e a r \cdot F a r}{F a r-N e a r} \\-z\end{array}\right]$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>本质就是对x、y、z做了不同的缩放（z还有个平移）。w也不再是1，而是z取反。最后通过x、y、z是否在[-w, w]中判断是否位于视锥体内。不在其内的会被剔除或裁剪，这样通过投影矩阵后，视锥体变化如下：</p><p><img src="projection_matrix0.png" alt="在透视投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量的范围发生的变化"></p><h3 id="3-2-5-裁剪空间-正交投影"><a href="#3-2-5-裁剪空间-正交投影" class="headerlink" title="3.2.5 裁剪空间-正交投影"></a>3.2.5 裁剪空间-正交投影</h3><div align=center><img src="orthographic_frustum.png" alt="正交摄像机的参数对正交投影视锥体的影响" style="zoom:80%;" /></div><p>视锥体是个长方体，因此不需要FOV了，用Size代替了，Size是高度的一半,Aspect是横纵比。因此，我们得到公式：<br>$$<br>nearClipPlaneHeight =2 \cdot Size<br>$$<br>$$<br>farClipPlaneHeight = nearclipPlaneHeight<br>$$<br>$$<br>nearclipPlaneWidth = Aspect \cdot nearClipPlaneHeight<br>$$<br>$$<br>farClipPlaneWidth = nearClipPlaneWidth<br>$$</p><p>这样，可以得到正交投影的裁剪矩阵：</p><p>$$\begin{aligned}\mathbf p_{cip}=\mathbf M_{ortho} \mathbf P_{view} &=\left[\begin{array}{ccc}\frac{1}{\text {Aspect} \cdot \text {Size}} & 0 & 0 & 0 \\0 & \frac{1}{\text {Size}} & 0 & 0 \\0 & 0 & -\frac{2}{\text {Far}-\text {Near}} & -\frac{\text {Far}+\text {Near}}{\text {Far}-\text {Near}} \\0 & 0 & 0 & 1\end{array}\right]\left[\begin{array}{l}x \\y \\z \\1\end{array}\right]=\left[\begin{array}{l}\frac{x}{\text {Aspect} \cdot \text {Size}}\\\frac{y}{\text {Size}} \\-\frac{2 z}{\text {Far}-\text {Near}}-\frac{\text {Far}+\text {Near}}{\text {Far}-\text {Near}} \\1\end{array}\right]\end{aligned}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>然后观察空间的顶点与矩阵相乘：<br>\frac{x}{\text {Aspect} \cdot \text {Size}}</p><p>可以看出，w分量依然为1。判断是否位于裁剪空间内与透视投影一样，x、y、z是否在[-w, w]之间。通过投影矩阵后，视锥体变化如下：</p><p><img src="orthographic_matrix0.png" alt="在正交投影中，投影矩阵对顶点进行了缩放。图中标注了4个关键点经过投影矩阵变换后的结果。从这些结果可以看出x、y、z和w分量范围发生的变化"></p><p>可以看出，变换后空间从长方体变成正方体了，范围是[-1, 1]。</p><h2 id="3-3-屏幕空间"><a href="#3-3-屏幕空间" class="headerlink" title="3.3 屏幕空间"></a>3.3 屏幕空间</h2><p>经过投影矩阵变换后，我们完成了裁剪工作，开始正式投影了，把视锥体投影到屏幕空间。屏幕空间是个二维空间，投影的过程分为两步：</p><p>首先，要进行齐次除法，也被称为透视除法。就是用x、y、z分量除以w分量。在OpenGL中，这一步得到的坐标叫<strong>归一化的设备坐标</strong>（<strong>NDC</strong>,Normalized Device Coordinates）。经过这一步，我们把坐标从齐次裁剪空间转换到NDC中，这样会使透视投影的类似金字塔形状的空间变成正方体，并且和正交投影的一样：</p><p><img src="projection_matrix1.png" alt="经过齐次除法后，透视投影的裁剪空间会变换到一个立方体"></p><p><img src="orthographic_matrix1.png" alt="经过齐次除法后，正交投影的裁剪空间会变换到一个立方体"></p><p>透视投影坐标经裁剪矩阵变换后<code>w</code>是<code>-z</code>，所以坐标x、y、z都除以<code>-z</code>就得到了右边的样子。而正交投影变换后<code>w</code>是<code>1</code>，所以除以1没变化，这样两种投影方式就都是一样的正方体了。</p><p>现在，我们开始屏幕映射了。Unity左下角坐标是（0, 0），右上角是（pixelWidth, pixelHeight），现在经过齐次除法后x、y的范围是[-1, 1]，所以这个过程就是个缩放的过程。</p><blockquote><p>首先把x、y变到[0, 1]，比如x = (x+1) / 2，然后再乘以pixelWidth就是映射后的x了，当然这里的x，y都是裁剪空间的坐标除以w。</p></blockquote><p>齐次除法和屏幕映射的过程可以使用下面的公式来总结：</p><p>$$\begin{array}{l}\text {screen}_{x}=\frac{\operatorname{clip}_{x} \cdot \text {pixelWidth}}{2 \cdot \operatorname{clip}_{w}}+\frac{\text {pixelWidth}}{2} \\\text {screen}_{y}=\frac{\text {clip}_{y} \cdot \text {pixelHeight}}{2 \cdot \operatorname{clip}_{w}}+\frac{\text {pixelHeight}}{2}\end{array}$$</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3.0.0/es5/tex-chtml.js"></script><script type="text/x-mathjax-config">  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script><p>在上式中，x、y被用作投影了，z分量会被用于深度缓冲，传统方式是z/w直接存进深度缓冲，但这不是必须的，驱动生产商会根据硬件来选择最好的存储格式。</p><h1 id="4-法线变换"><a href="#4-法线变换" class="headerlink" title="4. 法线变换"></a>4. 法线变换</h1><p>在游戏中，模型的顶点携带的信息中，法线就是其中一种。我们变换一个模型，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理（如片元着色器）中计算光照等。</p><p>但在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性。</p><p><img src="transform_normal.png" alt="进行非统一缩放时，如果使用和变换顶点相同的变换矩阵来变换法线，就会得到错误的结果，即变换后的法线方向与平面不再垂直"></p><p>因此，在法线的变换过程中，我们使用原变换矩阵的<code>逆转置矩阵</code>来变换法线就可以得到正确的结果。</p><p>因为逆矩阵的计算比较麻烦，所以我们可以根据变换类型尽可能的避免逆矩阵的计算过程：</p><ul><li>变换只包括旋转变换，那么这个变换矩阵就是正交矩阵（正交矩阵的转置矩阵与逆矩阵相同）；</li><li>变换只包括旋转和统一缩放，则可以利用统一缩放指数<em>k</em>来得到变换矩阵的逆转置矩阵；</li><li>变换包括了非统一变换，则必须求解逆转置矩阵。</li></ul><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。而在片元着色器中，我们通常也可以得到该片元在屏幕空间的像素位置。</p><p>通常在变换顶点时，我们都是使用<code>右乘</code>的方式来按<code>列矩阵</code>进行乘法。这是因为Unity提供的内置矩阵（如UNITY_MATRIX_MVP<code>(模型观察投影矩阵)</code>等）都是按照列存储的。</p><div align=center><p><img src="vertex_conversion.png" alt="渲染流水线中顶点的空间变换过程"></p></div><p>在Unity中，坐标系的旋向性也随着变换发生了转变。下图总结了Unity中各个空间使用的坐标系旋向性。</p><div align=center><p><img src="space_handness.png" alt="Unity中各个坐标空间的旋向性"></p></div>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;这几天重新回顾了一下图形学在Unity中的应用。主要是针对矩阵变换、坐标空间和法线变换的内容。</summary>
    
    
    
    <category term="计算机图形学" scheme="http://www.zanple.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="计算机图形学" scheme="http://www.zanple.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="Unity" scheme="http://www.zanple.top/tags/Unity/"/>
    
    <category term="Shader" scheme="http://www.zanple.top/tags/Shader/"/>
    
  </entry>
  
  <entry>
    <title>C4D短片-归来</title>
    <link href="http://www.zanple.top/2020/01/07/c4d-guilai/"/>
    <id>http://www.zanple.top/2020/01/07/c4d-guilai/</id>
    <published>2020-01-07T10:59:31.000Z</published>
    <updated>2020-09-05T08:16:45.909Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>三维动画实训的课设，和另一个同学合作的作品。<a id="more"></a></p></blockquote><div class="bilibili"><iframe src="//player.bilibili.com/player.html?aid=625033347&bvid=BV1zt4y1m7TC&cid=172051108&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><hr><h1 id="1-主题"><a href="#1-主题" class="headerlink" title="1. 主题"></a>1. 主题</h1><p>“作为联合国秘书长，一个拥有147个成员国，代表了几乎所有地球居民的组织，我向你们送去全人类的问候……”。1977年，人类发射了旅行者一号探测器携带者一张金唱片，旨在向“外星人”表达人类的问候。多年以后，在太空漂流了很多年的旅行者飞回了地球。然而，由于人类对地球资源的过度开发及严重污染，加上科技的发展，人类已抛弃地球前往太空寻找新家园了。</p><h1 id="2-镜头"><a href="#2-镜头" class="headerlink" title="2. 镜头"></a>2. 镜头</h1><ul><li>太空中的旅行者飞行；</li><li>旅行者坠落；</li><li>旅行者内部、金唱片；</li><li>破败的地球城市；</li><li>收音机响起：“人工智能时代已经来临！只需一个机器人，你的生活质量就能无限提高！嗞嗞…… “旅行者”号已经成功发射！它将代表我们人类去寻找宇宙中的“朋友们”！嗞嗞……环境日益恶化，地球将不再适合生存！“人类移民计划”启动！嗞嗞…..”</li></ul><h1 id="3-设定参考"><a href="#3-设定参考" class="headerlink" title="3. 设定参考"></a>3. 设定参考</h1><p>设定参考主要来自《银翼杀手2049》、《机器人总动员》。</p><p><img src="1585657763310.jpg" alt="设定参考1"></p><p><img src="1585657765225.jpg" alt="设定参考2"></p><p><img src="1585657766532.jpg" alt="设定参考3"></p><p>短片中破败的地球城市一开始的镜头就是参考的这张图，浓厚的烟雾，空荡的道路天桥，远处宏大模糊的建筑物。</p><p><img src="1585657767781.jpg" alt="设定参考4"></p><p><img src="Snipaste_2019-10-21_16-35-11-1585656959178.png" alt="设定参考5"></p><p>这张是来自《机器总动员》，主要也是参照了上面的建筑物废墟。</p><h1 id="4-场景"><a href="#4-场景" class="headerlink" title="4. 场景"></a>4. 场景</h1><h2 id="4-1-外太空"><a href="#4-1-外太空" class="headerlink" title="4.1 外太空"></a>4.1 外太空</h2><p>这个场景一开始打算直接用C4D自带的渲染器渲染的，但是考虑到外太空镜头中的旅行者号有一个点火移动的特效要利用TurbulenceFD构建，所以地球部分是直接在C4D自带的渲染器渲染，然后采取同样的方式对旅行者号进行打光，利用octane渲染为alpha图层。最后在Pr合成这个场景。</p><div align=center><p><img src="image-20200331201829240.png" alt="外太空地球的模型"></p><p><img src="image-20200331201836400.png" alt="外太空地球的效果图"></p><p><img src="image-20200331201850853.png" alt="地球表面材质"></p><p><img src="image-20200331201900856.png" alt="地球云层材质"></p><p><img src="image-20200331201906936.png" alt="地球大气层材质"></p></div><ul><li>地球模型由表面球体、云层、大气层构成；</li></ul><div align=center><p>  <img src="image-20200331201934353.png" alt="地球表面材质"></p><p>  <img src="image-20200331201947771.png" alt="地球云层材质"></p>  </div><ul><li>背景星空由天空贴图与噪波贴图组成。</li></ul><h2 id="4-2-外太空的旅行者号（oc渲染）"><a href="#4-2-外太空的旅行者号（oc渲染）" class="headerlink" title="4.2 外太空的旅行者号（oc渲染）"></a>4.2 外太空的旅行者号（oc渲染）</h2><div align=center><p><img src="image-20200331202040073.png" alt="外太空旅行者的模型"></p><p><img src="image-20200331202045406.png" alt="外太空旅行者的效果图"></p><p><img src="image-20200331202101466.png" alt="流体模拟的火焰效果图"></p><p>因为这是一个外太空场景，所以通常的火焰效果在这里不适用（有燃烧后的烟），反复模拟后最终实现一个太空飞船的尾焰的效果。</p><p><img src="image-20200331202119658.png" alt="TurbulenceFD粒子插件部分参数"></p></div><ul><li>旅行者的喷射效果使用TurbulenceFD粒子插件构建，并使用【发射器】完成粒子的发射效果。</li></ul><h2 id="4-3-废弃的城市"><a href="#4-3-废弃的城市" class="headerlink" title="4.3 废弃的城市"></a>4.3 废弃的城市</h2><p>这个场景花了比较长的时间去完成，在一开始使用<code>烟雾</code>觉得不够真实，在看了一个教程后转用<code>物理天空</code>进行模拟。为了实现厚重的烟雾效果，在场景的左上方进行补光。</p><div align=center><p><img src="image-20200331202146462.png" alt="废弃的城市的模型"></p><p><img src="image-20200331202151320.png" alt="废弃的城市的效果图"></p><p><img src="image-20200331202212603.png" alt="废弃的城市的模型"></p><p><img src="image-20200331202215912.png" alt="废弃的城市的效果图"></p><p><img src="image-20200331202219016.png" alt="废弃的城市的模型"></p><p><img src="image-20200331202225552.png" alt="废弃的城市的效果图"></p><p>参考了《银翼杀手2049》，将一些大型乌托邦风格建筑放在光线的前方，形成若隐若现的感觉。</p><p><img src="image-20200331202242207.png" alt="废弃的城市建筑群"></p></div><ul><li>废弃的城市场景比较庞大，部分建筑模型来自模型库；将不同的建筑组合到一起，并构建了路面、高架桥、废弃汽车、路标等完成场景的搭建；</li></ul><div align=center><p><img src="image-20200331202300935.png" alt="路面材质及凹凸效果"></p><p><img src="image-20200331202307535.png" alt="路面材质及凹凸效果"></p></div><ul><li>人行道和公路一开始为了渲染的工作量就用了纹理贴图，但纹理贴图在镜头拉近时地面就会显得不够真实，于是加了法线贴图来制造凹凸不平的地面；</li></ul><div align=center><p><img src="image-20200331202321993.png" alt="路面贴图"></p><p><img src="image-20200331202328500.png" alt="广告牌贴图"></p><p><img src="image-20200331202334957.png" alt="路标贴图"></p></div><ul><li>路面、广告牌及路标使用颜色纹理贴图；</li></ul><div align=center><p><img src="image-20200331202348201.png" alt="物理天空烟雾参数"></p><p><img src="image-20200331202359392.png" alt="聚光灯补光"></p></div><ul><li>利用Cinema4D的物理天空打造沙尘暴效果，提高摄像机焦距并另外使用聚光灯使烟雾效果更明显；</li></ul><h2 id="4-4-旅行者坠落（oc渲染）"><a href="#4-4-旅行者坠落（oc渲染）" class="headerlink" title="4.4 旅行者坠落（oc渲染）"></a>4.4 旅行者坠落（oc渲染）</h2><div align=center><p><img src="image-20200331202445489.png" alt="旅行者坠落的模型"></p><p><img src="image-20200331202450047.png" alt="旅行者坠落的效果图"></p></div><h2 id="4-5-旅行者内部-oc渲染"><a href="#4-5-旅行者内部-oc渲染" class="headerlink" title="4.5 旅行者内部(oc渲染)"></a>4.5 旅行者内部(oc渲染)</h2><p>这个场景的另一个同学做的，也是用了oc渲染。</p><div align=center><p><img src="image-20200331202530197.png" alt="旅行者内部模型"></p><p><img src="image-20200331202534588.png" alt="旅行者内部效果图"></p><p><img src="image-20200331202546270.png" alt="金唱片模型"></p><p><img src="image-20200331202551385.png" alt="金唱片效果图"></p></div><h2 id="4-6-荒废城市外"><a href="#4-6-荒废城市外" class="headerlink" title="4.6 荒废城市外"></a>4.6 荒废城市外</h2><p>这个放在片尾，当作是一个彩蛋对短片的设定进行补充。</p><div align=center><p><img src="image-20200331202704109.png" alt="荒废城市外模型"></p><p><img src="image-20200331202621559.png" alt="荒废城市外效果图"></p><p>一开始的预想是放一台收音机，在实践后感觉收音机与场景的匹配度不高，所以换成了一台电报机。</p><p><img src="image-20200331203117150.png" alt="电报机贴图"></p></div><h1 id="5-后期处理"><a href="#5-后期处理" class="headerlink" title="5. 后期处理"></a>5. 后期处理</h1><p>后期基本上都是在Pr完成的，在风格的处理上用到了几个滤镜：</p><ul><li>SL CLEAN FUJI A NDR</li><li>SL CLEAN FUJI A HDR</li><li>SL CLEAN KODAK A HDR</li><li>SL CLEAN KODAK B ULTRASOFT</li></ul><p>字幕制作强推Arctime！人性化的操作，比Pr的字幕制作好用多了。</p><h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>整个短片从一开始到最后的完成还是有一些不足的地方。</p><ul><li>废弃的城市最后渲染出来发现了阴影的问题，最后检查是因为补光的灯光没有关闭阴影，所以与物理天空中的阳光的阴影产生了冲突。（但是因为没有时间再重新渲染一遍了(T_T)）</li><li>荒废成实外的电报机场景烟雾存在问题，烟雾中的波状涡流，高度和动画速率都没有调好，导致渲染出来烟雾比较奇怪。</li><li>由于渲染时间要花比较久（主要是配置不行），自带的渲染器渲染中都没有打开全局光照和环境光屏蔽，Octane渲染的采样率就开了400，所以效果也不是很好。例如废弃的城市就出现了黑的地方太黑，旅行者坠落场景出现了噪点。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;三维动画实训的课设，和另一个同学合作的作品。</summary>
    
    
    
    <category term="C4D" scheme="http://www.zanple.top/categories/C4D/"/>
    
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="建模" scheme="http://www.zanple.top/tags/%E5%BB%BA%E6%A8%A1/"/>
    
    <category term="3ds Max" scheme="http://www.zanple.top/tags/3ds-Max/"/>
    
    <category term="C4D" scheme="http://www.zanple.top/tags/C4D/"/>
    
    <category term="短片" scheme="http://www.zanple.top/tags/%E7%9F%AD%E7%89%87/"/>
    
    <category term="Octane" scheme="http://www.zanple.top/tags/Octane/"/>
    
  </entry>
  
  <entry>
    <title>灯塔网</title>
    <link href="http://www.zanple.top/2020/01/02/beacon-web/"/>
    <id>http://www.zanple.top/2020/01/02/beacon-web/</id>
    <published>2020-01-02T08:09:32.000Z</published>
    <updated>2020-09-05T08:17:48.528Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>算是一个比较完整的项目，作为交互设计的课设本身，前期做了大量关于用户调研的工作，然后进行原型设计、UI设计，最后实现整个网站的前端和后端。<a id="more"></a></p></blockquote><p><img src="%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%872.JPG" alt=" "></p><h1 id="1-团队介绍"><a href="#1-团队介绍" class="headerlink" title="1. 团队介绍"></a>1. 团队介绍</h1><p><img src="%E5%B9%BB%E7%81%AF%E7%89%873.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%874.JPG" alt=" "></p><h1 id="2-产品介绍"><a href="#2-产品介绍" class="headerlink" title="2. 产品介绍"></a>2. 产品介绍</h1><p><img src="%E5%B9%BB%E7%81%AF%E7%89%875.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%876.JPG" alt=" "></p><h1 id="3-领域调研"><a href="#3-领域调研" class="headerlink" title="3. 领域调研"></a>3. 领域调研</h1><p><img src="%E5%B9%BB%E7%81%AF%E7%89%877.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%878.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%879.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8710.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8711.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8712.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8713.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8714.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8715.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8716.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8717.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8718.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8719.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8720.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8721.JPG" alt=" "></p><h1 id="4-用户研究"><a href="#4-用户研究" class="headerlink" title="4. 用户研究"></a>4. 用户研究</h1><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8722.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8723.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8724.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8725.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8726.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8727.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8728.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8729.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8730.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8731.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8732.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8733.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8734.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8735.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8736.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8737.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8738.JPG" alt=" "></p><h1 id="5-交互设计"><a href="#5-交互设计" class="headerlink" title="5. 交互设计"></a>5. 交互设计</h1><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8739.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8740.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8741.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8742.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8743.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8744.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8745.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8746.JPG" alt=" "></p><h1 id="6-视觉设计"><a href="#6-视觉设计" class="headerlink" title="6. 视觉设计"></a>6. 视觉设计</h1><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8747.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8748.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8749.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8750.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8751.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8752.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8753.JPG" alt=" "></p><p><img src="%E5%B9%BB%E7%81%AF%E7%89%8754.JPG" alt=" "></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;算是一个比较完整的项目，作为交互设计的课设本身，前期做了大量关于用户调研的工作，然后进行原型设计、UI设计，最后实现整个网站的前端和后端。</summary>
    
    
    
    <category term="交互设计" scheme="http://www.zanple.top/categories/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
    
    <category term="works" scheme="http://www.zanple.top/tags/works/"/>
    
    <category term="UI" scheme="http://www.zanple.top/tags/UI/"/>
    
    <category term="Web" scheme="http://www.zanple.top/tags/Web/"/>
    
    <category term="交互设计" scheme="http://www.zanple.top/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="JSP" scheme="http://www.zanple.top/tags/JSP/"/>
    
    <category term="原型设计" scheme="http://www.zanple.top/tags/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
