{"pages":[{"title":"urlname","text":"","link":"/urlname/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"3dsMax-正反向制作","text":"正、反向运动制作过程及参数的设定 1.打开图解视图 2. 将图层关系进行链接 3. 躯体链接 4. 建立路径动画选中飞机，点击运动-运动路径-转化自，点击路径曲线: 对飞机在不同位置的姿态进行调整:","link":"/2019/04/28/3dsmax-zhenffang/"},{"title":"3dsMax-材质贴图与灯光","text":"使用位图创建简单的材质； 使用程序贴图和位图创建复杂的材质； 在材质编辑器中修改位图； 使用和修改程序贴图； 应用UVW贴图坐标和使用动画材质； 理解不同类型的灯光以及其参数； 创建和使用灯光； 高级灯光的使用。 1. 镜像表面 效果如下： 2. 卡通材质Ink’n paint 将漫反射颜色拷贝至绘制控制-亮区中： 对另外五个材质进行同样的操作： 效果如下： 3. 贴图坐标控制 进入编辑-UVM Map修改器，将贴图-柱形改为贴图-球形： 效果如下： 4. 具有反射和真实灰尘效果的金色蜡烛台创建材质1： 设置材质1的凹凸贴图： 设置蜡台和手柄的贴图坐标： 设置手柄的UVW贴图为平面： 设置蜡台的UVW贴图为柱形： 设置黄金的反射效果，颜色1的贴图为光线追踪： 设置颜色2贴图： 颜色2的贴图环境为球形环境： 设置混合贴图的混合量：20： 设置反射数量为80： 设置混合材质2： 烛台效果： 创建与图像匹配的地面，用几何体/平面（PLANE）创建300X500（长：200段；宽：100段），设置反射高光：级别：80；光泽度：31，漫反射颜色NONE/sto011.jpg： 用Displace（置换）创建凹凸表面： 进行适当调整： 最终效果如下： 5. 创建彩色玻璃窗创建目标聚光灯，调整其大小和位置： 在目标聚光灯-常规参数中开启光线追踪阴影： 在目标聚光灯-阴影参数中开启灯光影响阴影颜色： 效果如下：","link":"/2019/04/13/3dsmax-material/"},{"title":"C++五子棋的实现","text":"用文档视图结构开发一个五子棋游戏程序。实现如下功能： 两人对战。黑方用箭头键和回车键操作下子。白方用WASD四个键和空格键控制下子。 窗口大小改变时，图形应保持原比例画在客户区； 可用菜单开始游戏和退出程序； 有统计黑白方胜局数及其比例的功能； 人机对战功能（实现在人下了子后机器自动下子）； 机机对战（程序对抗）。~ 1. 实现效果 2.游戏流程设计 3. 游戏类图 4. 人机对战思路 5. 游戏程序设计5.1 初始化函数12345678910int Gobang::Clean() //初始化函数{ int i1, i2; for(i1=0; i1&lt;16; i1++) { for(i2=0; i2&lt;16; i2++) m_aGrid[i1][i2]=0; //将棋局二维数组初始化为0 } return 0;} 5.2 查看当前谁下子123456789int Gobang::GetFlag() //查看当前谁下子{ int i; for(i = 1; i &lt; LuoNum; i++) { m_nFlag = (-1) * m_nFlag; //使m_nFlag的值为1或-1 } return m_nFlag;} 5.3 查看该行列的落子状况1234567891011121314151617181920int Gobang::Get(int RowPos, int ColPos) //查看该行列的落子状况{ return m_aGrid[RowPos][ColPos];}int Gobang::Get(int RowPos, int ColPos) //查看该行列的落子状况{ return m_aGrid[RowPos][ColPos];}bool Gobang::Set(int color, int RowPos, int ColPos) //下子{ if(Get(RowPos, ColPos) == 0) { m_aGrid[RowPos][ColPos] = color; //储存该位置的颜色 LuoNum++; //落子次数+1 return true; } else return false;} 5.4 判断输赢1234567891011121314151617181920212223242526272829303132333435363738394041424344int Gobang::Judge(int RowPos, int ColPos) //判断输赢{if(RowPos &gt;= 2 &amp;&amp; ColPos &gt;= 2 &amp;&amp; RowPos &lt;= 12 &amp;&amp; ColPos &lt;= 12) //第3行第3列到第13行 { if (Get(RowPos, ColPos) != 0) { if( Get(RowPos, ColPos) == Get(RowPos, ColPos-1) &amp;&amp; Get(RowPos, ColPos)== Get(RowPos, ColPos-2) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos, ColPos+1) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos, ColPos+2) || Get(RowPos, ColPos) == Get(RowPos-1, ColPos) &amp;&amp; Get(RowPos, ColPos)== Get(RowPos-2, ColPos) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+1, ColPos) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+2, ColPos) || Get(RowPos, ColPos) == Get(RowPos-1, ColPos-1) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos-2, ColPos-2) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+1, ColPos+1) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+2, ColPos+2) || Get(RowPos, ColPos) == Get(RowPos-1, ColPos+1) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos-2, ColPos+2) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+1, ColPos-1) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+2, ColPos-2) ) return Get(RowPos, ColPos); else return 0; } else return 0; }else if(RowPos &gt;= 2 &amp;&amp; RowPos &lt;= 12) //第3行第1、2、14、15. { if (Get(RowPos, ColPos) != 0) { if( Get(RowPos, ColPos) == Get(RowPos-1, ColPos) &amp;&amp; Get(RowPos, ColPos)== Get(RowPos-2, ColPos) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+1, ColPos) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos+2, ColPos) ) return Get(RowPos, ColPos); else return 0; } else return 0; }else if(ColPos &gt;= 2 &amp;&amp; ColPos &lt;= 12) //第3列第1、2、14、15. { if (Get(RowPos, ColPos) != 0) { if( Get(RowPos, ColPos) == Get(RowPos, ColPos-1) &amp;&amp; Get(RowPos, ColPos)== Get(RowPos, ColPos-2) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos, ColPos+1) &amp;&amp; Get(RowPos, ColPos) == Get(RowPos, ColPos+2)) return Get(RowPos, ColPos); else return 0; } else return 0; }else return 0;} 5.5 界面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125void CLJP003View::OnDraw(CDC* pDC) //界面{ CLJP003Doc* pDoc = GetDocument(); ASSERT_VALID(pDoc); // TODO: add draw code for native data here static int i = 0; if(i == 0) { m_chessboard.LoadBitmap(IDB_QIPAN); m_select.LoadBitmap(IDB_SELECT); m_blackhe.LoadBitmap(IDB_BLACKHE); m_whitehe.LoadBitmap(IDB_WHITEHE); m_black.LoadBitmap(IDB_BLACK); m_white.LoadBitmap(IDB_WHITE); m_rule.LoadBitmap(IDB_RULE); Chessboard.CreateCompatibleDC(pDC); Select.CreateCompatibleDC(pDC); Blackhe.CreateCompatibleDC(pDC); Whitehe.CreateCompatibleDC(pDC); Black.CreateCompatibleDC(pDC); White.CreateCompatibleDC(pDC); Rule.CreateCompatibleDC(pDC); Chessboard.SelectObject(m_chessboard); Select.SelectObject(m_select); Blackhe.SelectObject(m_blackhe); Whitehe.SelectObject(m_whitehe); Black.SelectObject(m_black); White.SelectObject(m_white); Rule.SelectObject(m_rule); i=1; } pDC-&gt;BitBlt(2,2,510,510,&amp;Chessboard,0,0,SRCCOPY); pDC-&gt;BitBlt(500,25,95,100,&amp;Blackhe,0,0,SRCCOPY); pDC-&gt;BitBlt(600,25,95,100,&amp;Whitehe,0,0,SRCCOPY); pDC-&gt;BitBlt(500,280,200,206,&amp;Rule,0,0,SRCCOPY); if(mode != 0) pDC-&gt;BitBlt(gbx,gby,30,30,&amp;Select,0,0,SRCCOPY); for(k1 = 0; k1 &lt;= 15; k1++) { for(k2 = 0; k2 &lt;= 15; k2++) { if(blanum[k2][k1] == 1) { pDC-&gt;BitBlt(k1*30,k2*30,30,30,&amp;Black,0,0,SRCCOPY); } } } for(k1 = 0; k1 &lt;= 15; k1++) { for(k2 = 0; k2 &lt;= 15; k2++) { if(whinum[k2][k1] == -1) { pDC-&gt;BitBlt(k1*30,k2*30,30,30,&amp;White,0,0,SRCCOPY); } } } CFont font; font.CreatePointFont(500,\"黑体\",NULL); pDC-&gt;SelectObject(&amp;font); pDC-&gt;SetTextColor(RGB(100,100,100)); CString str; str.Format(\"%d\", Glo_BWin); pDC-&gt;TextOut(530,130,str); CString str2; str2 = \":\"; pDC-&gt;TextOut(580,125,str2); CString str3; str3.Format(\"%d\", Glo_WWin); pDC-&gt;TextOut(630,130,str3); CFont font2; font2.CreatePointFont(100,\"黑体\",NULL); pDC-&gt;SelectObject(&amp;font2); pDC-&gt;SetTextColor(RGB(100,100,100)); BRate = Glo_BWin; WRate = Glo_WWin; CString str4; if(Glo_BWin != 0 || Glo_WWin != 0) str4.Format(\"胜率:%.f%%\",BRate/(BRate+WRate)*100); else str4 = \"胜率: 0%\"; pDC-&gt;TextOut(520,200,str4); CString str5; if(Glo_BWin != 0 || Glo_WWin != 0) str5.Format(\"胜率:%.f%%\",WRate/(BRate+WRate)*100); else str5 = \"胜率: 0%\"; pDC-&gt;TextOut(620,200,str5);if(mode != 0) //光标的样式 if(gobang.Get(m_nR-1,m_nC-1) == 1) { pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SBlack,0,0,SRCCOPY); } else if(gobang.Get(m_nR-1,m_nC-1) == -1) { pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SWhite,0,0,SRCCOPY); } else if(gobang.Get(m_nR-1,m_nC-1) == 0 &amp;&amp; m_nR == 4 &amp;&amp; m_nC == 4) pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SPoint,0,0,SRCCOPY); else if(gobang.Get(m_nR-1,m_nC-1) == 0 &amp;&amp; m_nR == 8 &amp;&amp; m_nC == 8) pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SPoint,0,0,SRCCOPY); else if(gobang.Get(m_nR-1,m_nC-1) == 0 &amp;&amp; m_nR == 4 &amp;&amp; m_nC == 12) pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SPoint,0,0,SRCCOPY); else if(gobang.Get(m_nR-1,m_nC-1) == 0 &amp;&amp; m_nR == 12 &amp;&amp; m_nC == 4) pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SPoint,0,0,SRCCOPY); else if(gobang.Get(m_nR-1,m_nC-1) == 0 &amp;&amp; m_nR == 12 &amp;&amp; m_nC == 12) pDC-&gt;BitBlt(gbx,gby,30,30,&amp;SPoint,0,0,SRCCOPY); else pDC-&gt;BitBlt(gbx,gby,30,30,&amp;Select,0,0,SRCCOPY);} 5.6 关键代码部分123456789101112131415161718192021222324252627282930313233void CLJP003View::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) //关键代码部分if(m_nC == 16) m_nC = 1; if(m_nC == 0) m_nC = 15; if(m_nR == 16) m_nR = 1; if(m_nR == 0) m_nR = 15; //解决光标超出棋盘范围 int j1, j2; for(j1 = 0; j1 &lt;= 14; j1++) { for(j2 = 0; j2 &lt;= 14; j2++) { if(gobang.Judge(j1,j2) == 1) { mode = 0; ke = 3; Glo_BWin++; gobang.Clean(); MessageBox(\"黑棋获胜！\",\"游戏结束\"); } else if(gobang.Judge(j1,j2) == -1) { mode = 0; ke = 3; Glo_WWin++; gobang.Clean(); MessageBox(\"白旗获胜！\",\"游戏结束\"); } } } 5.7 电脑思考并下子1234567891011121314else if(ke == 2) { //电脑思考并下子 int p1, p2; if(gobang.ComputerThink(m_nR-1,m_nC-1,p1,p2)) { m_nR = p1+1; m_nC = p2+1; if(gobang.Set(-1,m_nR-1,m_nC-1) ) { whinum[m_nR][m_nC] = -1; } ke = 1; } } 5.8 简单人机对战123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263bool Gobang::ComputerThink (int Row, int Col, int &amp;ResultRow, int &amp;ResultCol){//简单人机对战部分代码 int x, y, num;do{ srand((int)time(0)); num = rand()%8; switch(num) { case 0: { x = Row-1; y = Col-1; break; } case 1: { x = Row-1; y = Col; break; } } }while(Get(x, y) != 0); ResultRow = x; ResultCol = y; return true; }if(u2&lt;=10 &amp;&amp; Get(u1,u2)==1 &amp;&amp; Get(u1,u2+1)==1 &amp;&amp; Get(u1,u2+2)==1 &amp;&amp; Get(u1,u2+3)==1 ) //横向连成4子 人机对战部分代码 { if(Get(u1,u2-1) == 0) { x = u1; y = u2-1; goto here; } else if(Get(u1,u2-1) != 0 &amp;&amp; Get(u1,u2+4) == 0) { x = u1; y = u2+4; goto here; } } else if(u1&lt;=10 &amp;&amp; Get(u1,u2)==1 &amp;&amp; Get(u1+1,u2)==1 &amp;&amp; Get(u1+2,u2)==1 &amp;&amp; Get(u1+3,u2)==1 ) //纵向连成4子 { if(Get(u1-1,u2) == 0) { x = u1-1; y = u2; goto here; } else if(Get(u1-1,u2) != 0 &amp;&amp; Get(u1+4,u2) == 0) { x = u1+4; y = u2; goto here; } } 5.9 机机对战12345678910111213141516171819202122232425262728293031323334353637383940414243if(mode == 4) //机机对战{ if(ke == 1) { int p1, p2;//µçÄÔË¼¿¼²¢ÏÂ×Ó if(gobang.ComputerThink(m_nR-1,m_nC-1,p1,p2)) { m_nR = p1+1; m_nC = p2+1; if(gobang.Set(1,m_nR-1,m_nC-1) ) { blanum[m_nR][m_nC] = 1; } ke = 2; } switch(nChar) { case VK_SPACE: { if(gobang.Set(1,m_nR-1,m_nC-1)) blanum[m_nR][m_nC] = 1; ke = 2; if(gobang.ComputerThink2(m_nR-1,m_nC-1,p1,p2)) { m_nR = p1+1; m_nC = p2+1; if(gobang.Set(-1,m_nR-1,m_nC-1) ) { whinum[m_nR][m_nC] = -1; } ke = 1; } break; } } }} 6. 总结 通过编写这个程序，我对C++的面向对象程序设计有了进一步的理解，明白断点调试在程序设计中的重要作用，还深切体会到了系统架构和设计模式的重要性。 在编写程序的过程中，我遇到了很多问题，在一遍遍的调试与指导老师的帮助下成功解决了这些问题。首先在是界面如何布局问题，为了避免找到的棋盘素材与棋子不符合或是棋盘行列间距不规范问题，我对棋盘及棋子进行绘制，保证了每行列的间距均为40以便程序中棋子准确的落在线上；然后是光标移动的问题，光标移动会超棋盘范围，为解决这个问题，我将棋局的显示数组进行扩大，每当光标的位置到达棋盘边缘时将其数值改为对边的数值，确保光标的移动始终在棋盘内；还有便是双方棋子的显示问题，由于光标每移动到一个位置后会进行刷形处理，导致下过的棋子会被光标覆盖替代，我分别新建了黑棋与白棋的二维数组，光标每移动一次进行一次黑白棋数组的遍历以保证下过的棋子能够正常的显示在棋盘上。 在输赢判断中，一开始只想到从第3行第3列开始到第13行第13列进行十字与交叉的判断可以避免边缘判断较为麻烦问题，后面导致在第1、2、14、15行列中的一些棋局情况无法判断。 在对棋局类Gobang的调用中，一开始用的是全局指针，出现了在运行时崩溃的问题，通过求助罗老师将指针改为对象访问，解决了崩溃问题；此外还有一些语法上的问题，例如在判断输赢时错误的使用多个==判断符号连在一起导致游戏无法正确进行输赢的判断，在计算胜率的时候由于定义的黑棋白棋双方的获胜次数是整数类型，对其进行除法运算的时候会丢弃小数点后的数字导致胜率显示为0%，这一类的问题都通过断点调试排查解决了。 在解决人机对战的时候，为了解决机器下之后还要再按一下键的问题，发现只需要把机器下子部分加到玩家按空格的响应函数里面便可解决。 在高级人机对战的嵌套循环中，由于break只能退出当前循环，通过上网搜索解决方法后改用goto，解决了break只能退出当前循环的问题。 此外，由于时间关系，人机对战部分还存在不完善的地方。 7. 附件程序下载：链接: https://pan.baidu.com/s/1S6EaB5imidYpzP3LyeKiJg 提取码: g2is","link":"/2019/01/08/cpp-gobang/"},{"title":"C4D动画-广州印像","text":"三维动画的课设，和另一个同学合作的作品。 1. 概述我们生活在广州，那么广州给我们带来的映像是什么呢？结合三维建模的特性，我们决定通过描述广州特有的建筑来阐述广州带给我们的记忆。视频主要是将广州最有名的建筑运用小动画串联起来，将广州微缩成一个个小小的建筑，展现我们主题的同时，增加了视频的趣味性，也表达了我们对广州的爱。 2. 脚本 建筑 镜头 入画方式 出画方式 中信大厦 固定全景 掉落入画 快速旋转 广州塔 固定全景+摇 高速旋转构造 拆分挤压 中山纪念堂 固定全景+摇 挤压构造 拆分变成小球 体育中心 摇+推进 碎块重组 化成水融化 圆大厦 固定全景 缩放构造升起 移动 琶洲展馆 固定全景+摇 直接入画 直接出画 珠江啤酒博物馆 摇+固定全景 啤酒罐掉落 变形 广东省博物馆 固定全景 正方体变形 旋转破碎 五羊石像 固定全景 破碎后出现 破碎 3. 设计 我们场景中每个建筑的颜色都是根据画面上的颜色做参考来进行配比的。 4. 灯光与场景 灯光使用GSG Light Kit的Softbox，选用三盏灯分别从三个方向进行打光，参数进行如下设置： 场景使用一个L形曲面，避免面与面之间的棱角过于锋利: 5. 建模为了展现广州的建筑特色，我们选取了9个比较有代表性的广州建筑，利用网上找到的图片，在3dsmax里面进行建模，细化，导出FBX，再将模型导入到c4d中进行材质编辑与渲染。 其中五羊石像为了更好的导入C4D进行后续的动画编辑在ZBrush进行了减面操作以优化动画编辑处理，将模型由九十万多个面减少为十八万个面。 6. 动画特效每一栋建筑与建筑之间我们都会用一些动效和多面体将他们联系起来，尽量展现了更多样的形式还有奇思妙想。 特效动画部分是在c4d里完成，经过在3dMax与C4D效果的对比与我们的再三考虑，我们发现，利用c4d的效果去完成我们的作品，在渲染的画面以及基调上会更加适合，从而使我们的作品更加完善。 6.1 预处理 在对模型进行动画编辑前首先对需要进行分裂与泰森分裂的模型进行连接（焊接）处理，并将平滑着色模式选为最高。 6.2 中信大厦 由于对中信大厦进行模拟动力学处理无法达到预期动画效果，因此对中信大厦进行模拟动力学轨迹关键帧，实现轨迹动画。在变化为广州塔的过程首先使用普通关键帧动画，在关键变化过程使用分裂、推散、简易与延迟效果器实现复合效果。 6.3 广州塔 广州塔的动画与变换为中山纪念堂的过程同样使用了多个效果器进行复合效果处理，其中利用时间效果器的特征实现独立旋转效果。 6.4 中山纪念堂 在变为小球后启用小球的刚体动力学属性，并设置y向初速度实现小球向上抛的效果，在小球第二次落地后启用小球的泰森分裂效果，并另外设置刚性小球与该小球产生碰撞使小球破碎落地。 在泰森分裂中优化并关闭空洞，使小球破碎后的具有实心效果，同时设置其为空心对象以减少计算量。打开小球分裂的内表面与外表面选集并使用不同材质，增强小球破碎的真实感。 6.5 广州体育中心对小球碎片进行适当剪辑处理实现碎片汇聚效果，碎片变换为体育中心同样采用多个效果器的复合效果。 使用大小不同的两个小球实现类似流体分离的效果，提高融球的细分程度以优化平滑效果。设置小球的动力学初速度，实现小球向上跳动的效果。 在小球再次下落融合后设置体育中心的涟漪效果，实现涟漪效果时首先尝试使用公式效果器，设置公式为Sin((u+t)*2.0*PI)*0.2，但是效果不是很好于是更换为简易效果器，在效果器的衰减选项中设置其形状为球体，并绘制如图所示样条曲线，将其样条动画速率设置为20%以达到涟漪动画效果。体育中心变换到圆大厦使用多个效果器复合与关键帧动画完成过度。 6.6 广州圆大厦 对圆大厦的旋转速度分别设置不同的变化速度以达到非线性变化旋转效果，更贴合物体的真实转动。 接着对圆大厦设置轨迹，实现圆大厦的出画。 6.7 琶洲展馆 利用轨迹实现金币（圆大厦）的移动，通过关键帧的形式“打开”琶洲展馆顶部，启用圆大厦的动力学标签实现自由落体效果。 6.8 珠江啤酒博物馆 创建基本几何体实现啤酒馆外圈的动力学属性，设置啤酒桶的动力学标签并对其进行烘培。 调整啤酒桶的轨迹使其更符合手拿起的动作。啤酒馆变换为立方体同样采用多个效果器复合。通过融球效果改变立方体的颜色。 6.9 广东省博物馆利用关键帧动画实现出现纹路，旋转效果。博物馆变化为立方体同样采用多个效果器复合实现。使用泰森分裂破碎立方体。 6.9 五羊石像设置多个关键帧动画实现石像活动效果。 对五羊石像进行泰森分裂，设置点数量为2000，同样进行封闭空洞与空心处理，设置内外表面选集以实现内外不同材质。 使用多个效果器实现石像炸开碎片上升构成五羊粒子群，并消失拼凑出标题的效果。其中简易效果器控制碎片的移动与大小，随机产生随机位移、旋转效果避免整体效果过于单一，时间效果器实现碎片顺时针上旋效果，推散效果器实现碎片炸开效果。 7. 后期剪辑剪辑部分是在pr里完成，将画面更加顺畅的拼接起来，加入bgm以及效果音。手部动作是通过绿幕以及微单拍摄，通过ae叠加进去的，使我们的画面更加有微缩感。","link":"/2019/06/07/c4d-guangzhou/"},{"title":"Graphic Debugger工具简单入门","text":"游戏制作学习过程中无论是对自己的游戏进行分析，还是学习其他游戏用到的先进的制作方法和工艺流程，进行渲染调试都必不可少。 1.PC游戏PC游戏可以选择的工具有工具有NSight，Intel GPA，RenderDoc。这里以Intel GPA的使用为例。 在Intel的官网上下载安装包安装完成后，会在桌面上看到4个图标。 其中Graphics Monitor是我们使用的主要工具。打开Graphics Monitor后，点击示例项目的播放按钮。 打开游戏窗口，可以点击右侧的Capture frame或按Ctrl+Shift+C键进行当前帧的抓取。 回到Graphics Monitor出口，在右侧可看到刚才抓的帧。双击打开这一帧。 在弹出的Graphics Frame Analyzer窗口中，选择需要打开的帧，点击左侧的Open打开分析界面。 进入帧分析界面后，点击Frame Statistics-DrawIndexed-Show All Resources可以看到这一帧下的全部资源，包括贴图、模型等。 如果想对其他游戏进行分析，在Graphics Monitor界面中的路径位置，更改为想要分析的游戏的位置，并打开右上角设置中的自动检测启动应用开关。 2. 移动端游戏移动端常用的工具有RenderDoc，或者各家GPU厂商自己推出的相应工具，比如高通系的Snapdragon Profiler。这里以Snapdragon Profiler为例。 在Qualcomm的官网上进行注册登录后，根据对应的平台下载安装Snapdragon Profiler。安装完成后会在桌面上看到Snapdragon Profiler的快捷方式。 打开Snapdragon Profiler，点击左侧的Connect to a Device。 手机打开USB调试并连接电脑，点击Connect按钮。 成功连接后左侧的New Trace Capture和New Snapshot Capture按钮变为可点击状态，点击New Snapshot Capture。 找到需要抓帧的进程，点击Take Snapshot。","link":"/2020/09/13/graphic-debugger-intro/"},{"title":"C4D短片-归来","text":"三维动画实训的课设，和另一个同学合作的作品。 1. 主题“作为联合国秘书长，一个拥有147个成员国，代表了几乎所有地球居民的组织，我向你们送去全人类的问候……”。1977年，人类发射了旅行者一号探测器携带者一张金唱片，旨在向“外星人”表达人类的问候。多年以后，在太空漂流了很多年的旅行者飞回了地球。然而，由于人类对地球资源的过度开发及严重污染，加上科技的发展，人类已抛弃地球前往太空寻找新家园了。 2. 镜头 太空中的旅行者飞行； 旅行者坠落； 旅行者内部、金唱片； 破败的地球城市； 收音机响起：“人工智能时代已经来临！只需一个机器人，你的生活质量就能无限提高！嗞嗞…… “旅行者”号已经成功发射！它将代表我们人类去寻找宇宙中的“朋友们”！嗞嗞……环境日益恶化，地球将不再适合生存！“人类移民计划”启动！嗞嗞…..” 3. 设定参考设定参考主要来自《银翼杀手2049》、《机器人总动员》。 短片中破败的地球城市一开始的镜头就是参考的这张图，浓厚的烟雾，空荡的道路天桥，远处宏大模糊的建筑物。 这张是来自《机器总动员》，主要也是参照了上面的建筑物废墟。 4. 场景4.1 外太空这个场景一开始打算直接用C4D自带的渲染器渲染的，但是考虑到外太空镜头中的旅行者号有一个点火移动的特效要利用TurbulenceFD构建，所以地球部分是直接在C4D自带的渲染器渲染，然后采取同样的方式对旅行者号进行打光，利用octane渲染为alpha图层。最后在Pr合成这个场景。 地球模型由表面球体、云层、大气层构成； 背景星空由天空贴图与噪波贴图组成。 4.2 外太空的旅行者号（oc渲染） 因为这是一个外太空场景，所以通常的火焰效果在这里不适用（有燃烧后的烟），反复模拟后最终实现一个太空飞船的尾焰的效果。 旅行者的喷射效果使用TurbulenceFD粒子插件构建，并使用【发射器】完成粒子的发射效果。 4.3 废弃的城市这个场景花了比较长的时间去完成，在一开始使用烟雾觉得不够真实，在看了一个教程后转用物理天空进行模拟。为了实现厚重的烟雾效果，在场景的左上方进行补光。 参考了《银翼杀手2049》，将一些大型乌托邦风格建筑放在光线的前方，形成若隐若现的感觉。 废弃的城市场景比较庞大，部分建筑模型来自模型库；将不同的建筑组合到一起，并构建了路面、高架桥、废弃汽车、路标等完成场景的搭建； 人行道和公路一开始为了渲染的工作量就用了纹理贴图，但纹理贴图在镜头拉近时地面就会显得不够真实，于是加了法线贴图来制造凹凸不平的地面； 路面、广告牌及路标使用颜色纹理贴图； 利用Cinema4D的物理天空打造沙尘暴效果，提高摄像机焦距并另外使用聚光灯使烟雾效果更明显； 4.4 旅行者坠落（oc渲染） 4.5 旅行者内部(oc渲染)这个场景的另一个同学做的，也是用了oc渲染。 4.6 荒废城市外这个放在片尾，当作是一个彩蛋对短片的设定进行补充。 一开始的预想是放一台收音机，在实践后感觉收音机与场景的匹配度不高，所以换成了一台电报机。 5. 后期处理后期基本上都是在Pr完成的，在风格的处理上用到了几个滤镜： SL CLEAN FUJI A NDR SL CLEAN FUJI A HDR SL CLEAN KODAK A HDR SL CLEAN KODAK B ULTRASOFT 字幕制作强推Arctime！人性化的操作，比Pr的字幕制作好用多了。 6. 总结整个短片从一开始到最后的完成还是有一些不足的地方。 废弃的城市最后渲染出来发现了阴影的问题，最后检查是因为补光的灯光没有关闭阴影，所以与物理天空中的阳光的阴影产生了冲突。（但是因为没有时间再重新渲染一遍了(T_T)） 荒废成实外的电报机场景烟雾存在问题，烟雾中的波状涡流，高度和动画速率都没有调好，导致渲染出来烟雾比较奇怪。 由于渲染时间要花比较久（主要是配置不行），自带的渲染器渲染中都没有打开全局光照和环境光屏蔽，Octane渲染的采样率就开了400，所以效果也不是很好。例如废弃的城市就出现了黑的地方太黑，旅行者坠落场景出现了噪点。","link":"/2020/01/07/c4d-guilai/"},{"title":"Java多线程的应用","text":"广州火车站下面有三个火车票代售点，假如说广州到北京的火车票总共是200张，利用程序来实现三个售票点同时卖票的功能。 1234567891011121314151617181920212223242526272829303132package newpackage;class SaleTicket1412 implements Runnable{ private int ticket = 200 ; // 假设一共有200张票 public void run(){ for(int i=0;i&lt;100;i++){ // 要对当前对象进行同步，表示某个时间只能有一个对象操作此代码块 synchronized(this){ if(ticket&gt;0){ // 还有票 try{ Thread.sleep(300) ; // 加入延迟 }catch(InterruptedException e){ e.printStackTrace() ; } System.out.println(Thread.currentThread().getName()+\"售出第\" + (201-ticket--) + \"张票\"); } } } }};public class Train { public static void main(String[] args) { System.out.println(\"销售广州往北京的火车票\"); SaleTicket1412 mt = new SaleTicket1412() ; // 定义线程对象 Thread t1 = new Thread(mt,\"售票点1\") ; // 定义Thread对象 Thread t2 = new Thread(mt,\"售票点2\") ; // 定义Thread对象 Thread t3 = new Thread(mt,\"售票点3\") ; // 定义Thread对象 t1.start() ; t2.start() ; t3.start() ; }}","link":"/2019/06/13/java-runable/"},{"title":"Java横板小游戏","text":"一个类似超级马里奥兄弟的ACT游戏，通过Java实现。 下载试玩~ 1. 游戏设计1.1 游戏规则玩家初始的生命值为5，生命值耗尽则游戏结束。游戏为单向走动，无法后退，消灭敌人达到500分即可通关。其中，踩死敌人+100分，射击击杀敌人+50分。若玩家角色在游戏过程中跌入悬崖，则消耗所有生命值。玩家角色在游戏中通过各类道具可获得特殊功能：红心增加1个生命值，守护天使给予玩家5秒的无敌时间，跳跳靴提高玩家的跳跃高度。 1.2 游戏程序流程图 1.3 类设计 1.4 模块设计 1.4.1 游戏精灵模块此模块可以分为玩家角色、电脑角色和道具。玩家角色可进行行走、跳跃、踩死敌人、射击敌人的操作，并有生命值的显示；电脑角色可以在一定的范围内追逐玩家；道具则分为增加生命值、增加跳跃高度、无敌状态的道具。 1.4.2 地图模块地图模块分为卷轴模块和砖块模块，卷轴模块将图片的循环单向填充到游戏窗口；砖块模块根据游戏地图将对应的砖块绘制到游戏窗口。 1.4.3 音乐音效模块游戏背景音乐由音乐模块完成，音效音乐由音效模块完成。 2. 详细设计2.1 卷轴图像2.1.1卷轴的滚动显示定义一个变量xImHead用来指示图像左边缘与窗口左边缘的相对位置，初值为零，当该值大于零时表示图像左边缘在窗口右侧，小于零时则表示在窗口左侧。根据图像是否滚动填充游戏窗口。 12345678910111213141516171819public void draw(Graphics g) { //绘制卷轴型图像 if (xImHead == 0) { //情形1 drawRibbon(g, bim, 0, pWidth, 0, pWidth); } else if ((xImHead &gt; 0) &amp;&amp; (xImHead &lt; pWidth)) { //情形2 drawRibbon(g, bim, 0, xImHead, width - xImHead, width); drawRibbon(g, bim, xImHead, pWidth, 0, pWidth - xImHead); } else if (xImHead &gt;= pWidth) { //情形3 drawRibbon(g, bim, 0, pWidth, width - xImHead, width - xImHead + pWidth); } else if ((xImHead &lt; 0) &amp;&amp; (xImHead &gt;= pWidth - width)) { //情形4 drawRibbon(g, bim, 0, pWidth, -xImHead, pWidth - xImHead); } else if (xImHead &lt; pWidth - width) { //情形5 drawRibbon(g, bim, 0, width + xImHead, -xImHead, width); drawRibbon(g, bim, width + xImHead, pWidth, 0, pWidth - width - xImHead); }} 2.1.2卷轴的单向滚动让游戏场景只能从左到右单向滚动（类似超级玛丽）,在玩家向左运动时停止卷轴背景的滚动，并保证玩家角色不会走出左边屏幕边缘。 123456789case RUNLT: //考虑玩家向左运动的情况//若玩家向左移动到屏幕的最左端if (gameWorld.getOffsetX() &lt;= gameWorld.getOffsetX() || (locX &gt; GamePanel.WIDTH / 2)) { if(locX&gt;0) { //在屏幕范围内 setDX(5); locX -= dx; //减少玩家的横坐标值 gameWorld.canScroll = false;//停止卷轴背景滚动 }} 2.1.3载入地图定义TileMap类用来表示游戏中所有砖块型图像的集合，并统一地对其进行坐标更新和图像绘制。同时定义一个二维的BufferedImage类型数组tiles[][]用来存放各个砖块型图像，该数组的大小由砖块地图文件中字符的行数和列数确定。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//读取砖块地图文件信息并生成TileMap对象 public TileMap loadTileMap(String filename) { ArrayList lines = new ArrayList(); //存放tileMap中每一行的字符信息 int width = 0; //tileMap的宽度 int height = 0; //tileMap的高度 //逐行地读取砖块地图中的内容 try { //用字符输入流对象reader来载入砖块地图中的全部 BufferedReader reader = new BufferedReader(new InputStreamReader(getClass().getResourceAsStream(filename))); while (true) { String line = reader.readLine(); //读取一行字符串 if (line == null) { reader.close(); break; } if (!line.startsWith(\"#\")) { lines.add(line); //将字符串对象Line加入数组列表中 width = Math.max(width, line.length()); //获取砖块地图的宽度 } } } catch (IOException e) { } height = lines.size(); //获取砖块地图的高度 TileMap newMap = new TileMap(width, height); //建立TileMap对象 for (int y = 0; y &lt; height; y++) { //循环地读取砖块地图文件中的所有字符，并分别进行处理 String line = (String) lines.get(y); //读取某行字符信息 for (int x = 0; x &lt; line.length(); x++) { char ch = line.charAt(x); //对不同字符类型进行判断 int tile = ch - 'A'; if (tile &gt;= 0 &amp;&amp; tile &lt; tiles.size()) { //若为字母，则载入相应的砖块型图像 newMap.setTile(x, y, (BufferedImage) tiles.get(tile)); } else if ((ch - '0') == 0) { //若读取数字字符则载入对应敌人 EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.ANPC ,\"npc0\", 4, this); sprites.add(eny); //加入数组列表 } else if ((ch - '1') == 0) { EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.ANPC ,\"npc1\", 4, this); sprites.add(eny); } else if ((ch - '2') == 0) { EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.ANPC ,\"npc2\", 6, this); sprites.add(eny); } else if ((ch - '3') == 0) { EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.ANPC ,\"npc3\", 6, this); sprites.add(eny); } else if ((ch - '!') == 0) { //若为字符，则载入对应道具 EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.SNPC ,\"heart\", this); sprites.add(eny); //加入数组列表 }else if ((ch - '*') == 0) { EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.SNPC ,\"star\",this); sprites.add(eny); //加入数组列表 }else if ((ch - '?') == 0) { EnemyProp eny = new EnemyProp(x * TILE_SIZE, y * TILE_SIZE, EnemyProp.SNPC ,\"power\",this); sprites.add(eny); //加入数组列表 } } } return newMap; } 2.1.4垂直滚动场景若玩家跳跃后站在了砖块上，同时其图像的底端超出了游戏窗口的上边缘，则开始向上滚动砖块地图；若玩家下落时掉出了游戏窗口下边缘（但没有掉出砖块地图），则开始向下滚动砖块地图。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283case UpScrollY: //考虑向上滚动砖块地图的情况 gameP.removeKeyListener(gameP); //移除键盘按键事件监听 if (scrollCount &gt; 0) { //若滚动计数值大于0，则停止背景的水平滚动和玩家的水平移动 gameWorld.canMoveLeft = false; gameWorld.canMoveRight = false; if (runningState == RUNRT) { runningState = STDRT; } else if (runningState == RUNLT) { runningState = STDLT; } scrollCount -= 5; //减少滚动计数值 offsetY -= 5; //减少垂直方向偏移值 locY += 5; //增加玩家纵坐标值 gameWorld.setOffsetY(offsetY); //更新游戏世界的垂直偏移值 } else { //若滚动计数值小于等于0，则 scrollCount = GamePanel.HEIGHT; //重置滚动计数值为窗口的高度 gameP.addKeyListener(gameP); //添加键盘按键事件监听 gameP.leftPressed = false; gameP.rightPressed = false; changeState(MOVE); //将玩家状态切换为移动状态 } break; case DownScrollY: //考虑向下滚动砖块地图的情况 gameP.removeKeyListener(gameP); //移除键盘按键事件监听 if (scrollCount &gt; 0) { //若滚动计数值大于0，则停止背景的水平滚动和玩家的水平移动 gameWorld.canMoveLeft = false; gameWorld.canMoveRight = false; if (runningState == RUNRT) { runningState = STDRT; } else if (runningState == RUNLT) { runningState = STDLT; } scrollCount -= 5; //减少滚动计数值 offsetY += 5; //增加垂直方向偏移值 locY -= 5; //减少玩家纵坐标值 gameWorld.setOffsetY(offsetY); //更新游戏世界的垂直偏移值 } else { //若滚动计数值小于等于0，则 scrollCount = GamePanel.HEIGHT; //重置滚动计数值为窗口的高度 gameP.addKeyListener(gameP); //添加键盘按键事件监听 gameP.leftPressed = false; gameP.rightPressed = false; changeState(MOVE); //将玩家状态切换到移动状态 } break;//垂直方向上的角色坐标更新 locY += dy; //水平方向上场景滚动，角色坐标不变 if (locY + gameWorld.getOffsetY() &gt; gameWorld.tMap.getHeight() * gameWorld.tMap.TILE_SIZE) //若玩家角色掉出了砖块地图的下边缘，则游戏结束 changeState(DISMISS); else if (locY &gt; GamePanel.HEIGHT) //否则，若玩家角色掉出了游戏窗口的下边缘，则开始向下滚动砖块地图 changeState(DownScrollY); //更新玩家角色移动的精灵动画图像 switch (runningState) { case RUNRT: animRight.updateImage(); break; case RUNLT: animLeft.updateImage(); break; } //玩家角色与砖块图像在垂直方向的碰撞检测 if (gameWorld.worldCollisionVertical(this, thisPosition(),nextPosition(), offsetY)) { if (dy &gt; 0) { //若玩家角色处于下落过程中发生碰撞，则停止下落 onGround = true; //玩家碰到地面 setDY(0); //停止继续下落 if (locY + this.getHeight() &lt; 0) { //若玩家角色图像的底端超过了游戏窗口的上边缘，则开始向上滚动砖块地图 changeState(UpScrollY); } } } else if (dy &lt; 0) { //若是玩家处于跳起过程中发生碰撞 isJumping = false; //角色开始转为下落 jumpSpeed = -INISPEED; //跳跃速度恢复到初始值 } 2.2 精灵2.2.1精灵图像的绘制首先将精灵图像文件保存至BufferedImage对象bim中，然后建立BufferedImage数组ims用来存放各个精灵图像，并在循环语句中通过调用drawImage()方法将bim中的图像分割为相同尺寸的精灵图像。 1234567891011121314public BufferedImage[] setAnimImagesFromOneFile(String fnm, int num) { BufferedImage bim = loadImage(fnm); //读取名为fnm的图像文件 BufferedImage[] ims = new BufferedImage[num]; //存放各个精灵图像 int imWidth = (int) bim.getWidth() / num; //精灵图像的宽度 int imHeight = bim.getHeight(); //精灵图像的高度 Graphics g; for (int i = 0; i &lt; num; i++) { ims[i]= new BufferedImage(imWidth,imHeight,BufferedImage.TYPE_INT_ARGB); g=ims[i].getGraphics(); g.drawImage(bim, 0, 0, imWidth, imHeight, i*imWidth,0,(i*imWidth)+imWidth,imHeight, null); g.dispose(); } return ims; } 2.3 角色与场景的交互2.3.1精灵图像的绘制玩家的起跳、下落、走到地图边缘或是屏幕边缘的移动变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//实现玩家角色在活动态下的行为 public void move() { //判定玩家角色是否进行跳跃，并进行相应的坐标值更新 if (!isJumping) { //非挑起阶段做自由落体运动 dy += GRAVITY; } else { //跳起阶段做减速直线运动 jumpSpeed += GRAVITY; setDY(jumpSpeed); onGround = false; if (jumpSpeed &gt;= 0) { //若是达到最高点 isJumping = false; jumpSpeed = -INISPEED; //跳跃速度的初始方向朝上 } } //垂直方向上的角色坐标更新 locY += dy; //水平方向上场景滚动，角色坐标不变 if (locY + gameWorld.getOffsetY() &gt; gameWorld.tMap.getHeight() * gameWorld.tMap.TILE_SIZE) //若玩家角色掉出了砖块地图的下边缘，则游戏结束 changeState(DISMISS); else if (locY &gt; GamePanel.HEIGHT) //否则，若玩家角色掉出了游戏窗口的下边缘，则开始向下滚动砖块地图 changeState(DownScrollY); //更新玩家角色移动的精灵动画图像 switch (runningState) { case RUNRT: animRight.updateImage(); break; case RUNLT: animLeft.updateImage(); break; } //玩家角色与砖块图像在垂直方向的碰撞检测 if (gameWorld.worldCollisionVertical(this, thisPosition(),nextPosition(), offsetY)) { if (dy &gt; 0) { //若玩家角色处于下落过程中发生碰撞，则停止下落 onGround = true; //玩家碰到地面 setDY(0); //停止继续下落 if (locY + this.getHeight() &lt; 0) { //若玩家角色图像的底端超过了游戏窗口的上边缘，则开始向上滚动砖块地图 changeState(UpScrollY); } } } else if (dy &lt; 0) { //若是玩家处于跳起过程中发生碰撞 isJumping = false; //角色开始转为下落 jumpSpeed = -INISPEED; //跳跃速度恢复到初始值 } //玩家角色与砖块图像在水平方向的碰撞检测 if (gameWorld.worldCollisionHorizontal(this, thisPosition(),nextPosition(), offsetX)) { gameWorld.canScroll = false; //若发生碰撞则停止滚动场景 } else { //若水平方向没有发生碰撞，则根据玩家角色当前运动方向进行判断 switch (runningState) { case RUNLT: //考虑玩家向左运动的情况 //若玩家向左移动到屏幕的最左端 if (gameWorld.getOffsetX() &lt;= gameWorld.getOffsetX() || (locX &gt; GamePanel.WIDTH / 2)) { if(locX&gt;0) { //在屏幕范围内 setDX(5); locX -= dx; //减少玩家的横坐标值 gameWorld.canScroll = false;//停止卷轴背景滚动 } } else //若玩家没有到达砖块地图的两端则让卷轴背景滚动起来 gameWorld.canScroll = true; break; case RUNRT: //考虑玩家向右运动的情况 //若玩家向右移动到砖块地图的最右端，或从砖块地图的最左端开始向右移动 if (locX &lt; GamePanel.WIDTH / 2 || (gameWorld.getOffsetX() &gt;= (gameWorld.tMap.getWidth() * gameWorld.tMap.TILE_SIZE - GamePanel.WIDTH))) { setDX(5); locX += dx; //增加玩家的横坐标值 gameWorld.canScroll = false;//停止卷轴背景滚动 } else //若玩家没有到达砖块地图的两端则让卷轴背景滚动起来 gameWorld.canScroll = true; break; } } } 2.3.2碰撞检测方法checkTileCollision()方法实际判断的是角色与砖块图像图标是否发生了重叠，若是则返回碰撞的砖块图像坐标。由于判断的是运动中的角色，因此需要知道角色的当前位置坐标和下一帧的坐标。 1234567891011121314151617181920212223242526//判断角色是否与砖块型图像发生碰撞 public Point checkTileCollision(Sprite sprite,int oldX, int oldY, int newX, int newY) { Point pointCache = new Point(0, 0); //划定参与碰撞检测的坐标范围 int fromX = Math.min(oldX, newX); //碰撞检测范围左上角的X坐标 int fromY = Math.min(oldY, newY); //碰撞检测范围左上角的Y坐标 int toX = Math.max(oldX, newX); //碰撞检测范围右下角的X坐标 int toY = Math.max(oldY, newY); //碰撞简称范围右下角的Y坐标 //将程序窗口坐标转换为砖块型图像数组的下标，以便划定参与碰撞检测的砖块型图像的范围 int fromTileX = tMap.pixelsToTiles(fromX); int fromTileY = tMap.pixelsToTiles(fromY); int toTileX = tMap.pixelsToTiles(toX + sprite.getWidth() - 1); int toTileY = tMap.pixelsToTiles(toY + sprite.getHeight() - 1); //对划定范围内的砖块型图像逐个地进行碰撞检测 for (int x = fromTileX; x &lt;= toTileX; x++) { for (int y = fromTileY; y &lt;=toTileY; y++) { if (x &lt; 0 || x &gt;= tMap.getWidth() || tMap.getTile(x, y) != null) { //若发生了碰撞，则返回该砖块型图像的下标 pointCache.setLocation(x, y); return pointCache; } } } //若没有检测到碰撞，则返回空值 return null; } 2.3.3水平方向的碰撞检测当调用checkTileCollision()方法判断发生碰撞后，检测角色对象中水平方向速度dx的值。若dx&lt;0，则表示角色向左运动时发生了碰撞；若dx&gt;0，则表示角色向右运动时发生了碰撞。发生碰撞后的处理是设置角色对象在水平方向上紧贴着砖块对象。 12345678910111213141516171819202122//进行水平方向的碰撞检测 public boolean worldCollisionHorizontal(Sprite sprite, Point thisPos, Point nextPos, int offSetX) { //划定碰撞检测范围 int dx = sprite.getDX(); int oldX = thisPos.x; int newX = nextPos.x; int oldY = thisPos.y; int newY = oldY; //获取发生了碰撞的砖块型图像的下标 Point tile = checkTileCollision(sprite, oldX, oldY, newX, newY); if (tile == null) { return false; } else { //调整角色横坐标值，使得角色在水平方向上紧贴着砖块型图像 if (dx &gt; 0) { //若角色朝右移动 sprite.setX(tMap.tilesToPixels(tile.x) - offSetX - sprite.getWidth()); } else if (dx &lt; 0) { //若角色朝左移动 sprite.setX(tMap.tilesToPixels(tile.x + 1) - offSetX); } return true; } } 2.3.4垂直方向的碰撞检测当调用checkTileCollision()方法判断发生碰撞后，检测角色对象中水平方向速度dy的值。若dy&lt;0，则表示角色下落过程中发生了碰撞；若dy&gt;0，则表示角色挑起过程中发生了碰撞。若发生了垂直方向的碰撞，则设置角色对象在垂直方向上紧贴着砖块型图像，当dy&lt;0时应该停止角色继续上升，并将其值设为0使其开始下落。 12345678910111213141516171819202122//进行垂直方向的碰撞检测 public boolean worldCollisionVertical(Sprite sprite, Point thisPos, Point nextPos, int offSetY) { //划定碰撞检测范围 int dy = sprite.getDY(); int oldY = thisPos.y; int newY = nextPos.y; int oldX = thisPos.x; int newX = oldX; //获取发生了碰撞的砖块型图像的下标 Point tile = checkTileCollision(sprite, oldX, oldY, newX, newY); if (tile == null) { return false; } else { //调整角色纵坐标值，使得角色在垂直方向上紧贴着砖块型图像 if (dy &gt; 0) { //若角色处于下落过程中 sprite.setY(tMap.tilesToPixels(tile.y) - offSetY - sprite.getHeight()); } else if (dy &lt; 0) { //若角色处于跳起过程中 sprite.setY(tMap.tilesToPixels(tile.y + 1) - offSetY); sprite.setDY(0); //角色停止继续上升 } return true; } 2.3.5精灵角色碰撞检测的方法碰撞检测的算法类似于《打砖块》游戏中判定小球和砖块是否发生碰撞的算法，都是通过判断碰撞双方的边界是否发生了重叠。 1234567891011121314151617181920212223//检测精灵角色间的碰撞 public boolean spriteCollision(Sprite s1, Sprite s2, boolean isPlayer) { // if the Sprites are the same, return false if (s1 == s2) { return false; } //获取参与检测双方的横坐标和纵坐标 int s1x, s1y, s2x, s2y; s1x = s1.getX(); s2x = s2.getX(); s1y = s1.getY(); s2y = s2.getY(); //若有玩家角色参与碰撞检测，则将其坐标转换为游戏世界坐标 if (isPlayer) { s1x += getOffsetX(); s1y += getOffsetY(); } //判定双方的边界是否发生重叠，并返回判定结果 return (s1x &lt; s2x + s2.getWidth() &amp;&amp; s2x &lt; s1x + s1.getWidth() &amp;&amp; s1y &lt; s2y + s2.getHeight() &amp;&amp; s2y &lt; s1y + s1.getHeight()); } 2.3.6玩家角色跳起来“踩”电脑角色在碰撞检测方面，需要判定玩家角色是否在跳起后下落的过程中与电脑角色发生了碰撞；在碰撞处理方面，需要让电脑角色被“踩”到后从屏幕上消失。为了体现游戏的真实性，还需要加入一个掉落的过程，即电脑角色被“踩”到后垂直地从程序窗口下方掉落，直至其图像超出窗口下边界后消失。 1234567891011121314151617181920if ((eny.npcType == EnemyProp.ANPC) &amp;&amp; (man.state != Player.UNATTACK)) {//若玩家碰到了敌人，则进行相应处理 sound.loadSound(\"Sounds/collision.wav\"); sound.playSound(); if ((man.dy &gt; 0) //若玩家角色处于掉落过程中，改变电脑角色的状态为掉落态 &amp;&amp; (man.locY &lt; (eny.locY - gameWorld.getOffsetY()))) { eny.changeState(Sprite.ISHITTED);// gameWorld.anpcNum--; score += 100; //玩家角色踩到电脑角色后加100分 } else { man.changeState(Sprite.ISHITTED); }//实现电脑角色在掉落态的行为 public void drop() { //若电脑角色超出了窗口下边界则改变其状态为消失态 if (locY - gameWorld.getOffsetY() &gt; GamePanel.HEIGHT) { changeState(DISMISS); } setDY(dy + GRAVITY); //增加垂直速度值 locY += dy; //增加垂直坐标值 } 2.3.7玩家角色发射子弹攻击电脑角色当游戏者按下“Ctrl”键时玩家角色发射子弹，并让子弹沿水平方向做匀速直线运动，当子弹超出程序窗口范围或击中电脑角色后消失。 1234567891011121314151617181920public void checkShooting() { //检测子弹对象与电脑角色的碰撞检测 // man.move() must be first operated! for (int i = 0; i &lt; bullets.size(); i++) { Bullet bul = (Bullet) bullets.get(i); for (int j = 0; j &lt; gameWorld.getSprites().size(); j++) { //将子弹对象与所有电脑角色逐个进行碰撞检测 EnemyProp eny = (EnemyProp) gameWorld.getSprites().get(j); if (gameWorld.spriteCollision(bul, eny, true) &amp;&amp; (eny.npcType == EnemyProp.ANPC) &amp;&amp; (eny.state != Sprite.ISHITTED) &amp;&amp; bul.isActive()) { sound.loadSound(\"Sounds/collision.wav\"); //载入子弹击中目标的音效 sound.playSound(); //播放音效 eny.changeState(Sprite.ISHITTED); //改变电脑角色的状态// gameWorld.anpcNum--; bul.changeState(Sprite.DISMISS); //改变子弹角色的状态 score += 50; //玩家角色发射子弹击中电脑角色加50分 } } bul.update(); //若无碰撞发生则更新子弹坐标值 } } 2.3.8电脑角色追逐玩家角色当电脑角色“发现”玩家角色后便朝着玩家角色的方向移动，而当玩家角色离开电脑角色的视野后停止追逐。 12345678910111213141516//判定电脑角色是否“发现”了玩家角色 if (hasFoundPlayer()) { //当电脑角色方向玩家角色后的追赶动作 if(Math.abs(locY - gameWorld.getOffsetY()- gameWorld.gameP.man.getY() ) &lt; GamePanel.HEIGHT/3) if (locX - gameWorld.getOffsetX() &gt; gameWorld.gameP.man.getX()) { dx = -Math.abs(dx); //若在玩家角色的右边则向左追逐 } else { dx = Math.abs(dx); //若在玩家角色的左边则向右追逐 } }public boolean hasFoundPlayer() { return (locX - gameWorld.getOffsetX() &gt; 0) &amp;&amp; (locX - gameWorld.getOffsetX() &lt; GamePanel.WIDTH &amp;&amp; locY - gameWorld.getOffsetY() &gt; 0 &amp;&amp; locY - gameWorld.getOffsetY() &lt; GamePanel.HEIGHT); } 2.3.9 NPC的碰撞检测实现NPC间的碰撞检测及处理，两个NPC碰到后相互按相反的方向移动。调用getSprites方法，判断两个NPC是否碰撞，若碰撞则更改两个NPC的dx值。 12345678for (int i = 0; i &lt; gameWorld.getSprites().size()-1; i++) { //NPC的碰撞检测 EnemyProp eny1 = (EnemyProp) gameWorld.getSprites().get(i); EnemyProp eny2 = (EnemyProp) gameWorld.getSprites().get(i+1); if ((gameWorld.spriteCollision(eny1, eny2, false))&amp;&amp;(eny1.npcType == EnemyProp.ANPC)&amp;&amp;(eny2.npcType == EnemyProp.ANPC)){ eny1.dx = -eny1.dx; eny2.dx = -eny2.dx; }} 2.4 玩家角色生命值与道具2.4.1玩家角色生命减少在玩家角色遭遇到攻击之后其生命值要减少一个单位，同时游戏会继续运行。为了避免玩家持续地遭到攻击，需要为玩家角色设定一个“无敌”时间，即从玩家角色被攻击时算起的一小段时间内玩家角色将不会再遭遇到攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public void draw(Graphics g) { //绘制精灵图像，并实现无敌状态的闪烁效果 drawHearts(g); if (state == UNATTACK &amp;&amp; (count % 5 == 0)) { //当玩家角色处于无敌态时，每隔5帧便停止绘制一次 //跳过绘制的步骤 } else { switch (runningState) { //选择玩家运动状态 case RUNRT: animRight.draw(g, locX, locY); break; case RUNLT: animLeft.draw(g, locX, locY); break; case STDRT: animRight.draw(g, locX, locY); break; case STDLT: animLeft.draw(g, locX, locY); break; } } }public void update() { //更新角色的坐标 switch (state) { //判定玩家角色的状态值 case ISHITTED: //若为被攻状态 lives--; //生命值减1 updateHearts(); if (lives &lt;= 0) { //对lives值进行判定以便进行相应的状态转换 changeState(DISMISS); //转为死亡态 } else { changeState(UNATTACK); //转为无敌态 } break; case UNATTACK: //若为无敌态 //通过count累加该段时间内游戏运行的总帧数，即游戏循环进行的总次数 count = (count + 1) % (GamePanel.FPS * 5); //当count的值等于5秒内游戏循环的总次数时改变电脑角色的状态值 if (count == 0) { changeState(MOVE); //转为活动态 } case MOVE: //若为活动态 move(); break; case DISMISS: //若为死亡态 break; 2.4.2道具在游戏中提供三种游戏道具：“守护”道具为玩家角色提供5秒的无敌效果；“红心”道具为玩家提供一个额外的生命值（在生命值没有到达上限的情况下）；“跳跳靴”道具为玩家提供更高的起跳速度从而跳得更高。 守护 红心 跳跳靴 123456789101112131415161718192021else if (eny.npcType == EnemyProp.SNPC) { //若玩家获取了道具 sound.loadSound(\"Sounds/eat.wav\"); //加载音效文件 sound.playSound(); //播放玩家获取道具的音效 if (eny.npcName.equals(\"star\")) { //若道具为“守护” eny.changeState(Sprite.DISMISS); //撤销道具 man.resetCount(); //将玩家设为无敌状态 man.changeState(Player.UNATTACK); //重置无敌时间 } if (eny.npcName.equals(\"heart\")) { //若道具为“红心” eny.changeState(Sprite.DISMISS); //撤销道具 if (man.lives &lt; Player.LFNUM) { //若玩家生命未达到上限 man.lives++; //生命值加1 } man.updateHearts(); //更新玩家生命值图像显示 } if (eny.npcName.equals(\"power\")) { //若道具为“跳跳靴\" eny.changeState(Sprite.DISMISS); //撤销道具 man.jumpSpeed -= 10; //增加玩家的起跳速度 }} 2.5 游戏UI2.5.1显示玩家生命在玩家角色遭遇到攻击之后其生命值要减少一个单位，同时游戏会继续运行。为了避免玩家持续地遭到攻击，需要为玩家角色设定一个“无敌”时间，即从玩家角色被攻击时算起的一小段时间内玩家角色将不会再遭遇到攻击。 1234567891011121314151617//绘制各个生命对象的图像public void drawHearts(Graphics g) { for (int i = 0; i &lt; hearts.size(); i++) { heart = (Life) hearts.get(i); //从数组列表中取出一个生命对象 heart.draw(g); //绘制该对象的图像 }}//更新各个生命对象的坐标值public void updateHearts() { hearts.clear(); //清空数组列表对象 //根据玩家角色的生命值，循环地建立各个生命对象 for (int i = 0; i &lt; lives; i++) { heart = new Life(); //生成新的生命对象 heart.setX(i * heart.getWidth()); //设置横坐标 hearts.add(heart); //加入数组列表 }} 2.5.2显示游戏分数值和剩余敌人在游戏中设定得分数，用来对玩家角色消灭敌人的行为表示奖励，并显示剩余敌人数量。游戏运行过程中需要不断地统计游戏分数值，并将其显示在游戏屏幕上。规定玩家角色跳起踩到电脑角色后加100分，而当其发生子弹击中电脑角色后只加50分。 若玩家生命值为0或是掉入悬崖，则游戏结束，显示“Game Over！”，若玩家成功通关，则显示“Finished”。 12345678910111213141516Font font = new Font(\"Tahoma\", Font.PLAIN, 20); //创建字体对象 dbg.setFont(font); //设置字体 if (level &gt;= 1 &amp;&amp; level &lt;= TOTALLEVEL) { dbg.drawString(\"Score:\" + score, 5, 60); //显示分数值 dbg.drawString(\"Enemy:\" + gameWorld.anpcNum, 5, 85); //显示剩余敌人 } if (state == GameOver) { font = new Font(\"Tahoma\", Font.PLAIN, 90); dbg.setFont(font); dbg.drawString(\"Game Over!\", 0, HEIGHT / 2); } else if (state == GameFinish) { font = new Font(\"Tahoma\", Font.PLAIN, 90); dbg.setFont(font); dbg.drawString(\" Finished!\", 0, HEIGHT / 2); } 3. 游戏的类3.1 Animation 12345678910111213141516171819private BufferedImage[] Images; //精灵图像private int numImages; //精灵图像的张数private boolean ticksStopped; //标记精灵图像更新private boolean isRepeating; //标记精灵动画播放循环private int animTime; //精灵动画播放时间private int animSpeed; //精灵动画播放速度private int animTotalTime; //精灵动画总播放时间private int showTime; //单幅精灵动画持续时间private int imPosition; //当前精灵图像public Animation(String fileName,int num,int speed,int totalTime,boolean repeat)public Animation(String prefixfileName,String postfixFileName ,int num,int speed,int totalTime,boolean repeat)public BufferedImage loadImage(String fnm):return(im)public BufferedImage[] setAnimImagesFromOneFile(String fnm, int num):return(ims)public BufferedImage[] setAnimImagesFromFiles(String prefixFileName,String postFileName, int num) return(ims)public void updateImage()public BufferedImage getCurrentImage():return Images[imPosition]public boolean isStopped():return ticksStoppedpublic void resume()public void draw(Graphics g,int x ,int y) 3.2 Bullet 1234private Player player;public Bullet(Player man)public void update()public void move() 3.3 EnemyProp 12345678910111213141516171819202122232425262728private final static int GRAVITY = 1; //重力加速度private final static int JUMPSPEED = 20; //跳跃速度private Animation animRight, animLeft; //电脑角色向右/左运动的精灵动画对象private int numImages;public boolean runningRight, runningLeft, standRight, standLeft; //标识电脑角色是否向右/左运动/站立private GameWorldManager gameWorld; //GameWorldManager对象private int offsetX, offsetY;private int jumpSpeed; //跳跃速度public boolean isJumping = false; //标记跳起状态public boolean canJump = false; //标记跳跃状态public boolean onGround = false; //标记是否位于地面private SoundPlayer sound; //SoundPlayer对象public String npcName; //定义NPC名称public int npcType; //定义NPC类型（敌人或道具）public static final int ANPC = 0; //该字符常量表示敌人public static final int SNPC = 1; //该字符常量表示道具public EnemyProp(int x, int y, int type, String name, int numImage, GameWorldManager gameW)public EnemyProp(int x, int y, int type, String name, GameWorldManager gameW)public void jump()public void jumpStopped()public void drop()public void update()public void move()public boolean hasFoundPlayer()public Point thisPosition():return new Point(thisX, thisY)public Point nextPosition():return new Point(nextX, nextY)public void draw(Graphics g)private void setJumpSpeed(int jumpS) 3.4 GameFrame 1public GameFrame() 3.5 GamePanel 12345678910111213141516171819202122232425262728293031323334353637383940414243public static final int FPS = 50; //游戏运行帧率public final static int WIDTH = 500; //游戏窗口宽度public final static int HEIGHT = 360; //游戏窗口高度private Image im;private Graphics dbg;private Thread gamethread;private boolean running = false;private boolean isPaused = false;private int state;private static final int GameRunning = 0;private static final int GameOver = 1;private static final int GamePaused = 2;private static final int GameFinish = 3;public Player man;private ArrayList enemy;private GameWorldManager gameWorld;private int score; //score变量用来表示游戏分数值public boolean isGameOver = false;public SoundPlayer sound;public MusicPlayer music;public boolean isMusicStopped = false;public Bullet bul; //子弹对象public ArrayList bullets; //数组列表用来保存所有子弹public boolean leftPressed = false;public boolean rightPressed = false;public static int level = 1; //记录当前关卡的编号private boolean levelUp = false; //表示当前关卡是否通过public static final int TOTALLEVEL = 1; //游戏的总关卡数public GamePanel()public void gameStart()public void changeState(int s)public void gameStop()public void checkCollision()public void gamePaint()public void checkGameOver()public void loadLevel()public void checkShooting()public void gameRender()public void gameUpdate()public void run()public void keyTyped(KeyEvent e)public void keyPressed(KeyEvent e)public void keyReleased(KeyEvent e) 3.6 GameWorldManager 12345678910111213141516171819202122232425262728293031public int imMoveSize;private int TILE_SIZE = 64;private BufferedImage im1, im2, im3; //分别保存3幅卷轴型图像private Ribbon bg1, bg2, bg3; //3个卷轴型图像对象private ArrayList tiles;public TileMap tMap; //砖块型图像对象private BufferedImage[] tileImage; //保存所有砖块型图像public boolean canMoveRight; //标识图像向右滚动public boolean canMoveLeft; //标识图像向左滚动public boolean canScroll = false;private ArrayList sprites;public int anpcNum;public Player player;public GamePanel gameP;public GameWorldManager(GamePanel gp)public void init()public void setMoveFlag()public void draw(Graphics g)public void update()public TileMap loadTileMap(String filename): return newMappublic BufferedImage loadImage(String fnm): return impublic Point checkTileCollision(Sprite sprite,int oldX, int oldY, int newX, int newY): return pointCachepublic boolean worldCollisionHorizontal(Sprite sprite, Point thisPos, Point nextPos, int offSetX): return true/falsepublic boolean worldCollisionVertical(Sprite sprite, Point thisPos, Point nextPos, int offSetY): return true/falsepublic boolean spriteCollision(Sprite s1, Sprite s2, boolean isPlayer)public int getOffsetY()public void setOffsetY(int a)public int getOffsetX()public ArrayList getSprites()public boolean isScrollLeft()public boolean isScrollRight() 3.7 Life 1public Life() 3.8 MusicPlayer 12345678private Sequence sequence;private Sequencer sequencer;private File file;public MusicPlayer()public void loadMusic(String fileName)public void playMusic()public void stopPlaying()public boolean isStopped() 3.9 Player 1234567891011121314151617181920212223242526272829303132333435private final static int GRAVITY = 1; //重力加速度值为1private final static int INISPEED = 20; //跳跃初速度为20private Animation animRight, animLeft; //向右/左行走的动画对象public boolean runningRight, runningLeft, standRight, standLeft; //标识是否向右/左运动，是否朝右/左站立不动private GameWorldManager gameWorld;private int offsetX, offsetY;public int jumpSpeed; //跳跃速度值public boolean isJumping = false; //标识是否处于跳起阶段public boolean canJump = false;public boolean onGround = false;public static final int UNATTACK = 3; //无敌态public static final int UpScrollY = 4;public static final int DownScrollY = 5;public int runningState = 2;public static final int RUNRT = 0;public static final int RUNLT = 1;public static final int STDRT = 2;public static final int STDLT = 3;public static final int LFNUM = 5;public int lives = LFNUM;private int count = 0;private ArrayList hearts; //创建数组列表对象private Life heart; //创建生命对象private GamePanel gameP;private int scrollCount = GamePanel.HEIGHT;public Player(GameWorldManager world, GamePanel gp)public void update()public void drawHearts(Graphics g)public void updateHearts()public void resetCount()public void move()public Point thisPosition():return new Point(thisX, thisY)public Point nextPosition():return new Point(thisX, thisY)public void draw(Graphics g)private void setJumpSpeed(int jumpS) 3.10 Ribbon 123456789101112public BufferedImage bim; //图像对象private int xImHead; //图像头指针private int pWidth; //窗口宽度private int pHeight; //窗口高度private int width; //图像宽度private int moveSize; //移动速度public boolean canMoveRight;//向右移动标志public boolean canMoveLeft; //向左移动标志public Ribbon(int movS, BufferedImage im)public void draw(Graphics g)private void drawRibbon(Graphics g, BufferedImage im, int dx1, int dx2, int sx1, int sx2)public void update() 3.11 SoundPlayer 1234567File file;AudioInputStream stream;AudioFormat format;DataLine.Info info;Clip clip;public void loadSound(String fileName)public void playSound() 3.12 Sprite 12345678910111213141516171819202122232425262728293031323334353637protected int locX; //精灵的横坐标protected int locY; //精灵的纵坐标protected int dx; //精灵的水平运动速度protected int dy; //精灵的垂直运动速度protected Animation animPlayer; //动画对象protected int numImages; //精灵图像的张数protected String imFileName; //精灵图像文件名protected BufferedImage image; //精灵图像对象protected int width, height; //精灵图像的宽度/高度private static final int SIZE = 12;protected boolean isLooping; //标识精灵动画是否播放private int pWidth, pHeight; //游戏Panel范围private boolean isActive = true; //标记精灵的活动状态protected int state;protected static final int MOVE = 0; //移动态protected static final int DISMISS = 1; //消失态protected static final int ISHITTED = 2; //掉落态public Sprite(int x, int y, String imfile, int num)public BufferedImage setImage(String fnm)public void loopImage(int animPeriod, int seqDurationpublic void stopLooping()public boolean isActive()public void setActive(boolean a)public void move()public void draw(Graphics g)public void setDX(int x) public void setDY(int y) public int getDX() :return dxpublic int getDY() :return dypublic void setX(int x) public void setY(int y) public int getX() :return locXpublic int getY() :return locYpublic int getHeight() :return heightpublic int getWidth() :return widthpublic void changeState(int s) public int getState() :return state 3.13 TileMap 123456789101112131415161718192021private BufferedImage[][] tiles; //存放各个砖块型图像private int xMapHead; //TileMap头指针public int TILE_SIZE = 64; //砖块型图像尺寸为64x64private int offsetX; //水平方向偏移值public int offsetY; //垂直方向偏移值private int pWidth; //程序窗口宽度private int pHeight; //程序窗口高度private int mapWidth; //TileMap的宽度private int mapMoveSize; //TileMap的滚动速度public boolean tMapMoveRight = false; //标识TileMap向右滚动public boolean tMapMoveLeft = false; //标识TileMap向左滚动public TileMap(int width, int height)public int getMapHead():return xMapHeadpublic int getWidth() :return tiles.length1public int getHeight() :return tiles[0].lengthpublic BufferedImage getTile(int x, int y): return tiles[x][y]public void setTile(int x, int y, BufferedImage tile)public int tilesToPixels(int numTiles): return pixelSizepublic int pixelsToTiles(int pixelCoord): return numTilespublic void update()public void draw(Graphics g) 4. 游戏测试","link":"/2019/12/24/java-2d-act/"},{"title":"Java自定义异常","text":"定义 Triangle 类用于表示三角形，其任意两个边的和必须大于第三条边。定义 IllegalTriangleException 用于声明任何违反以上规则的输入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;class Triangle{ int side1 = 0; int side2 = 0; int side3 = 0; public int tbool = 1; Triangle(int s1, int s2, int s3){ side1 = s1; side2 = s2; side3 = s3; if(side1+side2&lt;=side3 || side1+side3&lt;=side2 || side2+side3&lt;=side1) { tbool = 0; } } public void showBalance() { System.out.println(\"三角形建立成功\"); }}class IllegalTriangleException extends Exception { IllegalTriangleException(){ System.out.println(\"请重新检查输入的三条边：\"); }}public class TriangleTest{ public static void main(String[] args) throws IllegalTriangleException{ System.out.println(\"请输入三角形的三条边\"); Scanner sc1 = new Scanner(System.in); int s1 = sc1.nextInt(); Scanner sc2 = new Scanner(System.in); int s2 = sc2.nextInt(); Scanner sc3 = new Scanner(System.in); int s3 = sc3.nextInt(); Triangle tr = new Triangle(s1,s2,s3); if(tr.tbool==0){ IllegalTriangleException ite = new IllegalTriangleException(); throw(ite); } else tr.showBalance(); }}","link":"/2019/06/06/java-exception/"},{"title":"Java Swing图形用户界面","text":"通过图形用户界面（Graphics User Interface，GUI），用户和程序之间可以方便地进行交互。Java包含了许多来支持GUI设计的类，如：按钮、菜单、列表、文本框等组件类，同时它还包含窗口、面板等容器类。学习组件除了了解组件的属性和功能外，一个更重要的方面是学习怎样处理组件上发生的界面事件。在学习处理事件时，必须很好地掌握事件源、监视器、处理事件的接口这三个概念。 （1）事件源 能够产生事件的对象都可以成为事件源，如文本框、按钮、下拉式列表等。也就是说，事件源必须是一个对象，而且这个对象必须是Java认为能够发生事件的对象。 （2）监视器。 我们需要一个对象对事件源进行监视，以便对发生的事件作出处理。事件源通过调用相应的方法将某个对象作为自己的监视器。 （3）处理事件的接口。 监视器负责处理事件源发生的事件。Java语言使用了接口回调技术设计了它的处理事件模式。事件源增加监视的方法 addXXXListener(XXXListener listener) 中的参数是一个接口，listener可以引用任何实现了该接口的类所创建的对象，当事件源发生事件时，接口listener立刻回调被类实现的接口中的某个方法。 1. 算术测试编写一个算术测试小软件，用来训练小学生的算术能力。程序有3个类组成，其中Teacher对象充当监视器，负责给出算术题目，并判断回答者的答案是否正确。ComputerFrame对象负责为算术题目提供视图，比如用户可以通过ComputerFrame对象提供的GUI界面看到题目，并通过该GUI界面给出题目的答案；MailClass是软件的主类。 123456789MainClass.javapublic class MainClass { public static void main(String args[]) { ComputerFrame frame; frame=new ComputerFrame(); frame.setTitle(\"算术测试\"); frame.setBounds(100,100,650,180); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778ComputerFrame.javaimport java.awt.*;import java.awt.event.*;import javax.swing.*;public class ComputerFrame extends JFrame { JMenuBar menubar; JMenu choiceGrade; //选择级别的菜单 JMenuItem grade1,grade2; JTextField textOne,textTwo,textResult; JButton getProblem,giveAnwser; JLabel operatorLabel,message; Teacher teacherZhang; ComputerFrame() { teacherZhang=new Teacher(); teacherZhang.setMaxInteger(20); setLayout(new FlowLayout()); menubar = new JMenuBar(); choiceGrade = new JMenu(\"选择级别\"); grade1 = new JMenuItem(\"幼儿级别\"); grade2 = new JMenuItem(\"儿童级别\"); grade1.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { teacherZhang.setMaxInteger(10); } }); grade2.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { teacherZhang.setMaxInteger(50); } }); choiceGrade.add(grade1); choiceGrade.add(grade2); menubar.add(choiceGrade); setJMenuBar(menubar); textOne = new JTextField(5); //创建textOne,其可见字符长是5 textTwo=new JTextField(5); textResult=new JTextField(5); operatorLabel=new JLabel(\"+\"); operatorLabel.setFont(new Font(\"Arial\",Font.BOLD,20)); message=new JLabel(\"你还没有回答呢\"); getProblem=new JButton(\"获取题目\"); giveAnwser=new JButton(\"确认答案\"); add(getProblem); add(textOne); add(operatorLabel); add(textTwo); add(new JLabel(\"=\")); add(textResult); add(giveAnwser); add(message); textResult.requestFocus(); textOne.setEditable(false); textTwo.setEditable(false); getProblem.setActionCommand(\"getProblem\"); textResult.setActionCommand(\"answer\"); giveAnwser.setActionCommand(\"answer\"); teacherZhang.setJTextField(textOne,textTwo,textResult); teacherZhang.setJLabel(operatorLabel,message); getProblem.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { teacherZhang.actionPerformed(e); }}); giveAnwser.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { teacherZhang.actionPerformed(e); } }); textResult.addActionListener(new ActionListener() { public void actionPerformed(ActionEvent e) { teacherZhang.actionPerformed(e); } }); setVisible(true); validate(); setDefaultCloseOperation(DISPOSE_ON_CLOSE); }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Teacher.javaimport java.util.Random;import java.awt.event.*;import javax.swing.*;public class Teacher implements ActionListener { int numberOne,numberTwo; String operator=\"\"; boolean isRight; Random random; //用于给出随机数 int maxInteger; //题目中最大的整数 JTextField textOne,textTwo,textResult; JLabel operatorLabel,message; Teacher() { random = new Random(); } public void setMaxInteger(int n) { maxInteger=n; } public void actionPerformed(ActionEvent e) { String str = e.getActionCommand(); if(str.equals(\"getProblem\")) { numberOne = random.nextInt(maxInteger)+1;//1至maxInteger之间的随机数; numberTwo=random.nextInt(maxInteger)+1; double d=Math.random(); // 获取(0,1)之间的随机数 if(d&gt;=0.5) operator=\"+\"; else operator=\"-\"; textOne.setText(\"\"+numberOne); textTwo.setText(\"\"+numberTwo); operatorLabel.setText(operator); message.setText(\"请回答\"); textResult.setText(null); } else if(str.equals(\"answer\")) { String answer=textResult.getText(); try{ int result=Integer.parseInt(answer); if(operator.equals(\"+\")){ if(result==numberOne+numberTwo) message.setText(\"你回答正确\"); else message.setText(\"你回答错误\"); } else if(operator.equals(\"-\")){ if(result==numberOne-numberTwo) message.setText(\"你回答正确\"); else message.setText(\"你回答错误\"); } } catch(NumberFormatException ex) { message.setText(\"请输入数字字符\"); } } } public void setJTextField(JTextField ... t) { textOne=t[0]; textTwo=t[1]; textResult=t[2]; } public void setJLabel(JLabel ...label) { operatorLabel=label[0]; message=label[1]; }} 2. 华容道华容道是大家很熟悉的一个传统智力游戏。编写GUI程序，用户通过键盘和鼠标事件来实现曹操、关羽等人物的移动。 123456MainClass.javapublic class MainClass { public static void main(String args[]) { new Hua_Rong_Road(); }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115Hua_Rong_Road.java import java.awt.*;import javax.swing.*;import java.awt.event.*;public class Hua_Rong_Road extends JFrame implements MouseListener,KeyListener,ActionListener { Person person[]=new Person[10]; JButton left,right,above,below; JButton restart=new JButton(\"重新开始\"); public Hua_Rong_Road() { init(); setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE); setBounds(100,100,320,500); setVisible(true); validate(); } public void init() { setLayout(null); add(restart); restart.setBounds(100,320,120,35); restart.addActionListener(this); String name[]={\"曹操\",\"关羽\",\"张\",\"刘\",\"周\",\"黄\",\"兵\",\"兵\",\"兵\",\"兵\"}; for(int k=0;k&lt;name.length;k++) { person[k]=new Person(k,name[k]); person[k].addMouseListener(this); person[k].addKeyListener(this); add(person[k]); } person[0].setBounds(104,54,100,100); person[1].setBounds(104,154,100,50); person[2].setBounds(54, 154,50,100); person[3].setBounds(204,154,50,100); person[4].setBounds(54, 54, 50,100); person[5].setBounds(204, 54, 50,100); person[6].setBounds(54,254,50,50); person[7].setBounds(204,254,50,50); person[8].setBounds(104,204,50,50); person[9].setBounds(154,204,50,50); person[9].requestFocus(); left=new JButton(); right=new JButton(); above=new JButton(); below=new JButton(); add(left); add(right); add(above); add(below); left.setBounds(49,49,5,260); right.setBounds(254,49,5,260); above.setBounds(49,49,210,5); below.setBounds(49,304,210,5); validate(); } public void keyTyped(KeyEvent e){} public void keyReleased(KeyEvent e){} public void keyPressed(KeyEvent e) { Person man=(Person)e.getSource(); if(e.getKeyCode()==KeyEvent.VK_DOWN) go(man,below); if(e.getKeyCode()==KeyEvent.VK_UP) go(man,above); if(e.getKeyCode()==KeyEvent.VK_LEFT) go(man,left); if(e.getKeyCode()==KeyEvent.VK_RIGHT) go(man,right); } public void mousePressed(MouseEvent e) { Person man=(Person)e.getSource(); int x=-1,y=-1; x=e.getX(); y=e.getY(); int w=man.getBounds().width; int h=man.getBounds().height; if(y&gt;h/2) go(man,below); if(y&lt;h/2) go(man,above); if(x&lt;w/2) go(man,left); if(x&gt;w/2) go(man,right); } public void mouseReleased(MouseEvent e) {} public void mouseEntered(MouseEvent e) {} public void mouseExited(MouseEvent e) {} public void mouseClicked(MouseEvent e) {} public void go(Person man,JButton direction) { boolean move=true; Rectangle manRect=man.getBounds(); int x=man.getBounds().x; int y=man.getBounds().y; if(direction==below) y=y+50; else if(direction==above) y=y-50; else if(direction==left) x=x-50; else if(direction==right) x=x+50; manRect.setLocation(x,y); Rectangle directionRect=direction.getBounds(); for(int k=0;k&lt;10;k++) { Rectangle personRect=person[k].getBounds(); if((manRect.intersects(personRect))&amp;&amp;(man.number!=k)) move=false; } if(manRect.intersects(directionRect)) move=false; if(move==true) man.setLocation(x,y); } public void actionPerformed(ActionEvent e) { dispose(); new Hua_Rong_Road(); }} 1234567891011121314151617181920212223Person.java import javax.swing.*;import java.awt.*;import java.awt.event.*;public class Person extends JButton implements FocusListener { int number; Color c=new Color(255,245,170); Font font=new Font(\"宋体\",Font.BOLD,12); Person(int number,String s) { super(s); setBackground(c); setFont(font); this.number=number; c=getBackground(); addFocusListener(this); } public void focusGained(FocusEvent e) { setBackground(Color.red); } public void focusLost(FocusEvent e) { setBackground(c); }} 任何组件上都可以发生鼠标事件，如：鼠标进入组件、退出组件、在组件上方单击鼠标、拖动鼠标等都触发鼠标事件，即导致MouseEvent类自动创建一个事件对象。事件源注册监视器的方法是addMouseListener(MouseListener listener)。当某个组件处于激活状态时，如果用户敲击键盘上一个键就导致这个组件触发KeyEvent事件。使用KeyListener接口处理键盘事件。组件可以触发焦点事件。当组件具有焦点监视器后，如果组件从无输入焦点变成有输入焦点或从有输入焦点变成无输入焦点都会触发FocusEvent事件。使用FocusListener接口处理焦点事件。","link":"/2019/06/21/java-swing/"},{"title":"Maya建模练习(2019)","text":"两个Maya课程大作业练习。 1. M4A1模型1.1 参考图 1.2 模型图 2. 武器铺2.1 参考图 2.2 模型图 2.3 渲染图","link":"/2019/06/17/maya-ex-2019/"},{"title":"Substance Designer-刺绣效果","text":"利用Substance Designer制作的一个刺绣效果（参考了Pauline Boiteux的《Advanced Pattern &amp; Fabric Creation in Substance Designer》制作流程以及整体的制作思路）。 1. 效果图 2. 制作思路整体的制作分为刺绣纹理、基本图案的制作，主体纹理的组合，布料纹理的制作和细节的完善几个部分。 2.1 刺绣纹理刺绣纹理这块分为刺绣的边缘和刺绣内部填充的纹理制作。 边缘纹理的制作比较简单， 使用自带的Fibers平铺即可得到。 内部填充纹理可以通过Splatter Circular创建扭曲的绳结形状拼接平铺得到。 2.2 主题纹理的制作与组合基本图案的制作可以利用内部Shape进行变换得到，也可以在其他软件（如CorelDARW、Illustrator等软件）制作。再对基本图形进行组合得到（需要注意连续的问题）。 2.3 布料纹理的制作简单的布料纹理可以通过Weave Generator节点生成，再叠加划痕效果丰富其细节。 2.4 细节的完善 布料的刺绣很难避免褶皱的产生（如上图），要实现这样的效果需要对布料上刺绣相应的位置的法线信息进行修改。如下为使用褶皱效果的制作流程。 *将上图的模糊效果由Blur HQ Grayscale改为非均匀模糊可以得到更好的效果。 3. 其他刺绣方案本文制作的刺绣效果还有很多可以优化的地方。此外还有很多用SD制作刺绣效果的案例，如汪锦，Pauline Boiteux制作的一些刺绣效果。","link":"/2020/07/04/sd-embroidery/"},{"title":"Substance Designer-布料纹理","text":"利用Substance Designer制作的几个布料纹理。 1. 效果图","link":"/2020/09/05/sd-fabric/"},{"title":"UI设计汇总（持续更新）","text":"UI类的内容比较多，大致分个类。 页面实在太多了，就挑了一部分放出来。 1. 在JTCLOUD团队的一些设计稿1.1 OA系统项目 1.2 澳洲电商项目1.2.1 Web端 1.2.2 移动端 1.3 非洲电商项目1.3.1 Web端 1.3.2 移动端 1.4 纸巾机项目 2. 树媒自习室 3. 灯塔网","link":"/2018/12/26/design-UI/"},{"title":"Unity-扫描及透视效果的实现","text":"扫描效果在科幻游戏中比较常见，如APEX英雄、命运2、杀出重围、全境封锁2等中都有体现。大致的效果为光线扫描全场景，并高亮显示敌方（可透过障碍物）。这里我选取了APEX英雄中“寻血猎犬”的“上帝之眼”技能为参考，按下“Q”后在短时间内扫描场景并显示范围内的敌人。 1. 效果分析扫描效果从当前视角蔓延，并根据扫描的位置显示对应的敌方，需要计算当前位置到扫描位置的距离。如果对场景中所有的对象进行计算，再将颜色叠加到物体上的效率显然较低。因此使用类似全局雾效基于屏幕后处理的实现方法，则不需要更改场景内渲染物体所使用的Shader代码，而仅仅依靠一次屏幕的后处理的步骤即可。 2. 直接使用深度值扫描效果直接从相机位置发出，因此尝试直接使用相机获得的场景深度信息进行处理。 在脚本中，获得到深度信息后我们就可以得到场景中物体与相机的深度关系。利用Unity Time类中的deltaTime来影响扫描效果的移动 1this.dis += Time.deltaTime * this.velocity; 然后通过OnRenderImage()函数抓取render texture，再通过Graphics.Blit()函数传递给虚拟材质中的Shader进行后处理。 在Shader中获取每个像素的深度信息，与扫描网所在位置比较进行颜色的叠加即可。 通过直接使用深度值信息进行叠加我们可以获得如上图的效果，但是这样的效果不够理想。首先是扫描网由摄像机所在位置发出，即从近裁剪平面发出，如果是用在固定视角的第一人称游戏不会有太大问题，但是应用在第三人称视角游戏的效果则不够理想，并且在移动过程中会影响后续的敌人高亮显示问题。 3. 使用深度缓冲重构世界空间坐标在上面的方法中是从摄像机发出扫描网的，但是我们想在角色所在位置发出，并且我们在游戏中可以看到的效果都是圆的而不是平面推出的方式。因此使用全局雾效里的使用深度缓冲来重构世界空间坐标。 通过对图形空间下的视锥体的四个顶点进行插值，然后通过采样当前像素的深度值，将这个线性深度值与插值后的结果相乘便能得到世界空间中相机到远裁剪平面的向量，其大小等于到采样像素的距离。最后再加上相机的世界空间坐标，我们就可以得到每个像素的世界空间坐标了。 当然，也可以通过深度和像素在屏幕上的坐标以及CVV到屏幕矩阵的逆投影矩阵逆摄像机矩阵计算出像素的世界空间坐标，然后和在世界空间中定义的扫描平面计算距离。但这样的做法需要涉及到矩阵的计算。 4. 扫描网效果扫描网的效果上我选取的还是APEX英雄中“寻血猎犬”的技能为例： 扫描网的移动上，为了避免扫描网的无限延伸（到天空盒），对扫描网的距离进行判断。 1if (juli &lt; _ScanDistance &amp;&amp; juli &gt; _ScanDistance - _ScanWidth &amp;&amp; linearDepth &lt; 1) 同时，另扫描网的移动速度随着时间增加（实现扫描网逐渐加速的效果）。 1ScanDistance += Time.deltaTime * 50; 扫描网的视觉效果由4个变量来控制，分别为边缘清晰度、边缘颜色、中部颜色、尾迹颜色。并使用水平线填充扫描网。 1234567891011121314 _HeadTough(&quot;边缘清晰度&quot;, float) = 10 _HeadColor(&quot;边缘颜色&quot;, Color) = (1, 1, 1, 0) _MidColor(&quot;中部颜色&quot;, Color) = (1, 1, 1, 0) _LastColor(&quot;尾迹颜色&quot;, Color) = (1, 1, 1, 0) _LineColor(&quot;水平线颜色&quot;, Color) = (0.5, 0.5, 0.5, 0)……if (juli &lt; _ScanDistance &amp;&amp; juli &gt; _ScanDistance - _ScanWidth &amp;&amp; linearDepth &lt; 1){ float chazhi = 1 - (_ScanDistance - juli) / (_ScanWidth); //给定距离减去像素距离再除去给定的宽度，使得结果在0到1之间变化，再用1减去归一化的这个值 half4 edge = lerp(_MidColor, _HeadColor, pow(chazhi, _HeadTough)); //用幂函数来提高边缘颜色的权重 scanColor = lerp(_LastColor, edge, chazhi) + lineEffect(i.uv) * _LineColor; //把条纹乘上一个颜色 scanColor *= chazhi; //以上三行用于混合三个颜色 使用了不同的值作为插值函数的权重}return col + scanColor; //叠加到扫描颜色中 5. 敌人高亮显示在APEX英雄中“寻血猎犬”的技能中，被扫描到的敌人会进行描边处理，并且这个描边是可以透过障碍物看到的。 实现这样的效果只需要利用两个Pass分别对被遮住和未被遮住的物体进行处理即可。然后根据观察方向和目标多边形的法线方向的夹角来判断目标的边缘，从而实现描边效果。 敌人的高亮描边效果应该在扫描网扫描目标敌方后才出现，并且这个效果应该只会保持一定的时间然后恢复正常。因此添加一个BeenScan脚本来控制目标敌方的不同显示效果。 12345678910public void Highlight() { Material material = Resources.Load(&quot;Material/Browm-bear 1&quot;, typeof(Material)) as Material; GetComponent&lt;Renderer&gt;().material = material; numCal++; if(numCal &gt; 180) { Material material2 = Resources.Load(&quot;Material/Browm-bear&quot;, typeof(Material)) as Material; GetComponent&lt;Renderer&gt;().material = material2; } } 最后，在ScanEffect中判断扫描网是否扫描到了目标敌方来调用BeenScan。 123456789101112foreach (BeerBeenScan s in _beenscanB) { if (Vector3.Distance(ScanOrigin.position, Bear.transform.position) &lt;= ScanDistance) { s.Highlight(); if (_crossingB) { s.numCal = 0; _crossingB = false; } } } 6. 最终效果 [1] “Special Effects with Depth” talk at SIGGRAPH - Kuba Cupisz [2] Shaders Case Study - No Man’s Sky: Topographic Scanner","link":"/2020/04/27/unity-scaneffect/"},{"title":"Unity-新式数字博物馆","text":"一个基于Unity的虚拟现实大创项目。 1. 引言博物馆作为一个向公众展示产品文化，传承人类文明与社会历史文化的重要平台，在人们日益重视精神文化的生活中占据着重要地位，而博物馆的存在在于让观众对其展品能够有一定深度的了解。因此，运用各种展现方式来激发观众的展品的兴趣与求知欲便尤为重要。而传统博物馆与目前已有的数字虚拟化博物馆在人们普遍的逻辑思维里便只是一个“收藏文物和展示文物”的地方，形成这种思维的主要原因是传统博物馆与目前已有的数字虚拟化博物馆的展陈设计过于呆板无趣，且展品大多数锁在玻璃柜里。目前大多博物馆都还停留在模仿一些著名博物馆的展陈方式而没有结合自身展品的特征来进行展览，而数字虚拟博物馆局限于对现实博物馆的还原，缺乏对展品展陈方式的创新和与展品的互动，导致观众失去参观的兴趣和进一步了解的欲望，进一步制约着博物馆的发展。 随着科技的发展，虚拟现实（Virtual Reality/VR）技术也得到了飞快的进步，人们对VR技术的关注日渐升温，且VR技术的沉浸性这一基本特征可以帮助博物馆还原展品的发展状态与内在联系，突破二维展示的局限，最大化的还原场景的真实性，为展览呈现效果单一的缺陷带来显著改变。而VR技术的交互性和多感知性则可进一步拉近与观众的距离，增加展陈的趣味性，提升观众的兴趣，从而达到增强观众的参观体验。 2. 项目意义：2.1 对博物馆运维成本与文物保护上的作用在博物馆很多艺术品都是经历了很长的历史而保留下来的，有些文物已经出现剥落、脱色、脆化等情况，而且经过人工修复也无法长期展示和研究。使用虚拟技术有利于易损文物的保护，降低博物馆对文物的维修成本。另一方面，通过运用VR技术构建场景体验式博物馆，可以克服传统展示易受展厅空间限制的缺点，减少展品展柜和场景体验区的占用空间，降低搭建场景体验区的成本。 2.2 对博物馆藏品展示方式上的作用我国各种博物馆保存的文物达到了 100 多万件，而且因为展柜占用的空间，还有将文物存放在展柜中，更是影响观众的欣赏。而运用VR技术则可以让观众进行虚拟操作，与展品进行互动，拉近了观众与藏品的距离，而且也能加深人们对艺术品的理解力，提高人们观赏历史文物的兴趣。 当下数字虚拟博物馆大多还局限于对现实博物馆的还原，没有真正运用虚拟现实技术的优势。而场景体验式的特点，为观众提供身临其境的感觉，实现观众在博物馆这个限定空间内能够沉浸于多个场景的时空中，将延伸与拓展博物馆展示的更大价值和意义。当观众在博物馆内戴上VR 头盔或眼镜后，观看的场景与在馆内观看其他视频的环境截然不同。并且这样的虚拟场景不再局限于传统博物馆对单类展品发展的线性介绍，而可以同时对多类展品的发展有机地联系在一起，实现在同一空间不同时间的综合展览，让观众对不同展品的时间发展有更为深入的理解。这样非线性思维方式使得体验成为一种超越时间和空间的跳跃式行为，观众可以从任意一个展品感受历史的发展，又在历史的发展中与任意一个展品相遇。这种更接近于人类大脑信息记忆的随意性和跳跃性体验，恢复了观众亲近事件的自然状态，让每个人见证参与的历史化作场景回到我们身边。 2.3 对博物馆教育功能的意义利用虚拟现实和三维技术给人们提供一个真实的、直观的艺术展品与场景。利用VR这一新兴的体验方式，极大的提高了观众的参观兴趣，同时能够充分满足观众对展品观赏的需求。尤其对于青少年观众来说，他们更注重与展览的趣味性，VR技术对于他们的吸引性更强。 而场景体验式的博物馆，可以让观众同时了解到多种展品的历史发展状态，让观众对历史的发展有更为全面的认知。数字博物馆内的参观引导机制与博物馆文创周边的结合，增强观众尤其是青少年对展品及历史探索的主动性。 3. 实际应用3.1 应用于博物馆文物的展示利用计算机三维建模技术对特定历史时期的场景及相关文物进行建模，结合VR设备实现对特定历史时期的场景和文物的还原。使观众能在参观博物馆时能够“置身”于某个时空，冲任意角度真实地感受所处的历史背景，大大加深了观众对展品的了解与兴趣，丰富了参观博物馆的实际体验，降低馆方建造场景式体验区的成本。借助VR设备的手柄，观众可以在虚拟的场景中与展品进行一定的互动，能够将展品“拿在手中”，从多个角度零距离的观察展品。 而虚拟博物馆的场景式特点，可以在同一空间下对多种物品的发展同时进行展示，让观众对不同展品的发展历程有更为立体的认识，传统博物馆只能分别对展品发展历程展示的缺陷。 对场景中的探索过程进行一定的设计，结合博物馆的文创周边产品，能够让观众不再是被动盲目的接受知识，引导观众主动去探索展品。 对于面对青少年的特殊展厅，加入引导人的体验机制，让青少年在与展品进行互动和深入了解后进行答题，予以一定的奖励，进一步加深博物馆的教育功能。 3.2 应用于移动式博物馆利用VR设备的便携性，能够解决传统博物馆在地理空间上的分配不均问题，降低公众参观博物馆的门槛，拉近博物馆与公众的距离。利用这一特征，各大博物馆可以开设移动式新型博物馆，定期到各社区与学校开展相应的文化活动，满足公众的文化需求，而基于虚拟现实技术的场景体验式数字博物馆，可以避免移动式博物馆空间小，能够展示展品少的缺点；同时借助VR这一新兴技术，可以极大地刺激观众的兴趣，让更多人能够主动地到博物馆参展。 4. 研究内容在2017年3月由美国博物馆联盟所属未来博物馆中心发布的引导现代博物馆发展的报告中，提出了九大提升优化博物馆体验的设计方法。其中重点提到了虚拟现实技术在助力博物馆展示的突破点。虚拟现实（VR，Virtual Reality）是利用电脑模拟产生的三维空间，进而营造出虚拟世界的一种新媒体技术。使用者佩戴特制的头盔显示器、手柄以及身体部位跟踪器等设备，在虚拟场景中通过视觉、听觉和触觉等感官的模拟，获得如同身临其境的感受。随着 2016 年以来虚拟现实技术的迅猛发展，世界各地的博物馆也相继尝试将这样一种新兴技术作为特殊的叙事性设计加以应用。 本项目的主要研究内容是借助VR设备，利用计算机三维建模技术对场景和展品进行建模。选取八九十年代至今这一典型历史时期。将这一历史时期分为八九十年代、二十世纪末、2008年与当下时期这四个变化较大的时间段，通过对居民客厅的再现，还原改革开放以来民众家居生活用品及电子产品的发展历程，探索制定引导参观机制以提高观众探索的主动性，加强博物馆的教育功能。团队利用Cinema 4D对场景和展品的建模，Unity进行该应用的开发，最后借助HTC Vive将应用中的场景映射到观众眼前。 5. 关键问题5.1 拟真场景的搭建与展品的建模对不同时期的场景和展品需要进行一定的研究，确保搭建的符合该时期的历史事实。如场景的灯光与房间的材质的还原，展品材质的还原，都需要对大量该历史时期的记载进行参考，将展品与场景整合模拟出较为真实的历史场景。 5.2 借助VR设备实现观众与场景的交互观众需要利用手柄对虚拟场景进行交互，如行走，拿取，旋转等操作。如何利用手柄实现与虚拟博物馆的最佳交互方式，还原不同展品的真实交互方式，需要通过一定的实验与测试进行对比。 5.3 引导参观机制与观众体验的平衡通过设定引导参观机制来让观众主动探索博物馆，同时避免该机制过于繁杂导致观众的探索兴趣降低。例如对于青少年这一群体，如何通过设定一定的问题与奖励机制，鼓励青少年能够主动了解展品背后的历史知识，需要通过一定的实验与测试进行设定。 6. 实现建模部分基本在3ds Max和Cinema 4D完成，部分模型来自3D溜溜网。将模型导出为fbx格式（3ds Max文件直接用unity导入）。 制作不同时期家具的UI界面： 在Unity中绑定各个物品的触发事件，如电视的播放，风扇的旋转等。 为了增加每个时期的真实性，对每个时代的介绍故事进行策划，其中2010的故事撰写时我参考了很多资料如阎雷的《昨天的中国》等，并选取特定的时期并结合房间物品特色以日记的形式叙述故事： 12345678910111213141516171819202122232425261985年 11月7日 晴/雾今天窗外白茫茫一片，被太阳穿透的奶白色晨雾，让窗外的整个世界看上去像一幅雕刻作品，深蓝色的天空仿佛预示着冬天即将来临。傍晚从楼层管理员那里买到了一瓶酸奶。最近开了好多个体商店，买东西似乎变得越来越方便。家里的缝纫机最近不大顺滑，大抵是要买润滑油了吧。明天早起骑车到白天鹅宾馆看展览，顺便到新开的商店看看。1999年 12月20日 晴澳门回归了！昨晚看来澳门回归的交接仪式，五星红旗终于再次飘扬在澳门上，澳门再也不是“ma-cau”了！最近大家都在谈论12月31日世界末日的传言，哈哈哈哈要是真是世界末日我要和我的魂斗罗呆在一起。晚上和李明去PS厅打拳皇97，再到他家看看什么特丽龙彩电是怎样的。过了这个世纪我也要去买一台“NOKIA”。2010年 5月12日 雨今天是5月12日，汶川大地震两年了，逝者安息！但愿希望能更快地从悲壮中生长出来吧。上海世博会开幕了十几天了，不知不觉奥运会过了两年了，仿佛还是昨天的事，中国逐渐走向世界的大舞台了啊。连续下了几天的雨了，要是有个机器人能够帮我打理好家里的一切像扫地做饭多好啊，这样我就可以躺在床上什么事也不做了。昨天新买的手机发现居然不能放内存卡了！2018年 11月2日 阴今天第一次看到港珠澳大桥，天哪，这么浩大的工程是怎么完成的。柔宇科技的折叠手机有点炫酷，虽然边框还是有点大。毕竟这年头连显示器、电视都做到接近无边框了。小爱同学坏了今天修好寄回来了，无聊的时候还是有点意思的。晚上回家又塞车了…什么时候能有自动驾驶啊。明天就是LPL总决赛了，IG加油啊。","link":"/2019/08/23/unity-new-museum/"},{"title":"Unity中DoTween插件的缓动函数","text":"最近在Unity中使用 DOTween插件来配置UI动画，了解到了几种常见的缓动函数。 缓动函数指定动画效果在执行时的速度，用于控制动画从初始值运动到最终值的速率。如摄像机的运动、灯光的渐弱、汽车的启动等，这些速度的变化都不是线性的。所以适当的使用动画能让用户得到更舒适的观感，使其看起来更加真实。 1. 缓动函数目前已经有一些常用的缓动函数曲线了，特殊情况需要图素进行复杂复合动作，需要严丝合缝的控制函数变化的时间点的话才使用自定义曲线来解决。 缓动函数的效果一般都分为三个缓动方式，分别是： ease-in：表示缓入动画，动画的速度先慢后快，为从0开始加速的缓动。缓入动画会在速度最快时停止，这会让动画结束得很突然，因为自然界中的运动总是慢慢减速后才停止的。 ease-out ：表示缓出动画，与缓入动画正好相反，缓出动画的速度先快后慢，为减速到0的缓动。 ease-in-out： 表示缓入缓出动画，它的速度由慢变快，最后再变慢，前半段从0开始加速，后半段减速到0的缓动。 其中Linear为线性动画，动画从开始到结束一直是同样的速度，没有缓动效果。 2. 缓动函数速查表 *缓动函数速查表:http://www.xuanfengge.com/easeing/easeing/","link":"/2020/04/13/unity-dotween-ease/"},{"title":"Unity卡通地编-Hylia小岛(完善中)","text":"跟着猴子老师学习的一个Unity卡通地编的制作。使用Unity的LWRP轻量级渲染管线制作，通过Substance Designer，Zbrush，Maya，Photoshop来辅助完成模型贴图部分。材质部分涉及水和互动草的Shader制作，利用GPU的特性来快速实例像旷野之息一样的草坪。使用Houdini来制作树的叶子，给物件做LOD优化。 1. 地形系统地形系统的构建用到了Terrain Tools包，用于改善在Unity中创建地形的工作流程。 在Terrain Toolbox中设置创建的地形大小点击Create创建地形，可以通过导入外部Heightmap来创建地形。 在Edit-Shortcuts-Terrain中可以更改创建地形的快捷键，如Select Set Height Tool、Select Smooth Tool等。通过ASD调节笔刷的强度、大小和旋转角度。 使用Raise or Lower Terrain、Set Height、Smooth Height构建基本地形。 完成地形构建后，通过Create-Terrain Layer创建层，在地形-Paint Texture-Layer中添加图层。为地形绘制贴图。 2. 石头雕刻使用Zbrush对石头低模进行雕刻，其中用到了卡通风格的笔刷(提取码uaqi)。 3. 石头贴图利用Substance Designer制作石头的贴图。首先将高模和低模导入SD中，在SD中烘培AO、Normal(Tangent)、Normal(World)、Curvature、Position图。 3.1 Normal在高模烘培的法线贴图上叠加裂痕、磨损等细节效果。细节效果通过Creased节点得到，裂痕效果通过Cells节点得到，磨损坑洼效果可通过Tile Sampler节点得到。 石头上的横纹使用Light节点通过世界空间的法线贴图得到石块的遮罩，以此避免石块顶部也出现横纹。 Light节点：根据世界空间法线贴图进行伪照明，并返回黑白“光照图”蒙版。 3.2 Base Color颜色贴图用到了Gradient Map节点来得到表面的基本颜色，使用Dirt节点根据烘培的Curvature、AO、世界空间的法线贴图来生成石块缝隙的青苔效果。 Gradient Map节点：从灰度映射到自定义的颜色色带，颜色色带可以通过取色曲线得到。 Dirt节点：根据烘焙的Curvature、AO、Normal(World)和用户设置生成黑白蒙版，表示在被遮挡和凹陷的边缘和角落出现了污垢。 Edge Damage节点：根据烘焙的曲率和AO对凸起的凸边缘造成的损坏图和用户设置生成黑白蒙版。","link":"/2020/09/12/unity-hylia-island/"},{"title":"Unity实时渲染-赛博朋克风格场景","text":"一个利用Unity完成的赛博朋克风格场景。 在赛博世界，人类生活每一个细节都是受计算机网络控制的黑暗地带，由于商业巨头的过度膨胀，导致经济高过了政治，成为驱动世界前进的动力，于是我们看到庞大的跨国公司取代政府成为权力的中心。这种高强度的压抑氛围也导致部分的人性的泯灭，其中的许多人物都要靠一些高强度的刺激以激发人们对于一些事物的感知，所以在这个世界的很多角落里通常都会充斥各种暴力、毒品等过分裸露的事物，而那些雨夜与霓虹灯搭配起来的强烈视觉表现元素更好地阐述了日益发达的科技与日益淡薄的人性的这对尖锐的矛盾冲突。就如同希腊神话中用蜡烛翅膀奋力高飞的伊卡洛斯一样，在离太阳最近的时候，绽放了最美的瞬间，但翅膀的融化注定了陨落的命运。 ——南宫萧宸，《从蒸汽时代到后启示录：幻想未来世界旅行不完全指南》 1. 概述 当提起赛博朋克这个词时，或许每个人在脑海中第一时间闪过的东西都不一样——“街道氤氲湿冷在霓虹灯下熙熙攘攘的场景” 、“‘高科技，低生活’的理念信条”、“沉溺虚拟世界最终幻灭的体验”、“配有《赛博朋克2077》LOGO的土味图’”……每一个都可以被叫做一个模因，它们都能看成赛博文化在进化中的 DNA。 ——暴君，《当我们说起赛博朋克的时候，我们喜欢的究竟是什么？》 赛博朋克在CDPR的《Cyberpunk2077》（2020最期待的游戏！没有之一！）面世后就引来了许多人的关注。因此想到利用Unity来完成一个赛博朋克场景的建立。 利用Unity实现的赛博朋克短片和场景有很多，比较有名的有beffio的《The Hunt》和Manufactura K4的Dark City2。此外还有UE4大神紫无心的《霓虹中国》。 受《杀出重围》系列游戏（赛博朋克风格比较不错的游戏，值得一玩）的影响，我更倾向于霓虹元素稍微少的Low Life的低生活场景。因此使用了《Dark City2》的部分素材和一些其他模型来完成这个场景。 2. 灯光灯光基本上都是用的点光源和自发光材质，部分使用了聚光灯（如建筑物的照灯）。 点光源主要是作为氛围光使用，平衡自发光的亮度。因此点光源的阴影就没那么重要，直接使用低分辨率的硬阴影并使用实时模式即可。 场景中还用了比较多的反射探针，反射探针的原理和光照探针类似，它允许我们在场景中的特定位置上对整个场景的环境反射进行采样，并把采样结果存储在每个探针上。当游戏中包含反射效果的物体从这些探针附近经过时，Unity会把从这些邻近探针存储的反射结果传递给物体使用的反射纹理。 场景中的反射探针基本上放在路面上来确保路面的反射效果，为减少对帧速率的影响，在Time Slicing（时间切片）中设置为All faces at once（每9帧更新一次）或Individual faces（每14帧更新一次）。 为增强地面的反射效果，再添加与Skybox相符的平行光。 3. 粒子效果场景中运用到粒子效果的有三处：下水道的水汽、雨、电火花。 其中，街道地面的水花自然不是粒子器的效果，而是通过shader来实现（下次写一下这个效果的实现）。 4. LOD优化一开始场景中直接使用的LOD0的模型，在运行时帧率较低。在进行LOD优化后帧率得到明显提升。 LOD是Level Of Details的缩写即多层次细节。在计算机图形学中，LOD就是为了支持当物体远离观察者或者物体的重要程度不同，位置不同，速度不同或者视角相关的参数不同需要减少渲染3D模型的复杂度。 例如，同样的模型处在远处时，所占屏幕像素数会比较小，反正也是看不清楚了，这时候再渲染超多顶点的高精度的模型就会浪费计算性能。这时候如果在远处的能用更低精度的模型渲染，那么在不太影响渲染质量的情况下可以提高效率。上图则为同一物体的不同精细度模型。 在Unity中为物体添加LOD Group组件并设置相应比例对应的模型即可。不过因为LOD使用了多个模型，所以会造成整个项目体积的增大，算是拿空间换性能的一种优化方法吧。 5. 后处理5.1 抗锯齿接着是使用Post-process进行后处理。首先在Post-process中通过开启SMAA抗锯齿来降低画面走样现象。SMAA是一种在FXAA的基础上改进的更高质量的抗锯齿方案。 既然提到了抗锯齿，这里就简单的介绍一下常见的抗锯齿的方法： SSAA （Supersample Anti-Aliasing）超采样抗锯齿就是最简单粗暴的也是最有效的抗锯齿方法，缺点就是性能太差。任何类型的走样归根结底都是因为欠采样，那么我们只需要增加采样数，就可以减轻走样现象。以4x为例，4xSSAA对于每个像素（Pixel）计算4个子像素，将4个子像素的颜色求平均值，便能获得抗锯齿后的颜色。 MSAA（Multisample Anti-Aliasing）SSAA中每个像素需要多次计算着色，这对实时渲染的开销是巨大的。因此在SSAA的基础上发展出了MSAA。MSAA其实和SSAA一样，也是基于硬件的实现，只是在增加采样点和平均的时候用了一些 Trick，大幅优化了 SSAA 的效率，当然代价就是对特定的锯齿完全没有优化效果。和 SSAA 不同，MSAA 其实是 Per-Pixel Shading。GPU 打开 MSAA 后，会在光栅化阶段根据图元边缘的计算出其覆盖的像素，和对该像素内每一个 Sample 的覆盖关系（coverage mask），在执行 PixelShader 后写入颜色时，会根据覆盖关系把 PS 输出的颜色和 BackBuffer 颜色进行平均后作为最终结果。由于MSAA拥有硬件支持，相对开销比较小，又能很好地解决几何走样问题，在游戏中应用非常广泛。 提到了MSAA，想起前几天知乎上寒霜之爪写的《延迟渲染与MSAA的那些事》中提到的在延迟渲染中使用MSAA（这个在很多参考资料上都注明了延迟渲染不支持硬件抗锯齿）。 FXAA （Fast Approximate Anti-Aliasing）FXAA 是由 NVDIA 发明的高效后处理抗锯齿方案，也是目前所有后处理抗锯齿方案里面同等设置下效率最高的抗锯齿算法。FXAA 的边缘提取是根据 SceneColor 的 Luma 值进行检测的，所以可以提取到高光、阴影，几何边缘，半透明物体。 SMAA（增强型亚像素形态抗锯齿）SMAA 是由 CryEngine 开发的更注重效果的后处理抗锯齿方案，当然其效率在大多数移动平台上也是很难被接受的。它和FXAA的最大区别是会更具边缘的形状选择不同的周围像素进行模糊，尽量还原出合理的SubPixels。 Temporal AA（Temporal Anti-Aliasing） 严格来说TAA并不能算一个具体的算法，而是更像一个统一的算法框架。和SSAA一样，TAA也能够同时减轻几何走样和着色走样的问题。总体来说TAA也分为采样（sampling）和合成（resolve）两个过程，不同的TAA的具体实现也是围绕这两个部分有所变化。 5.2 BloomBloom特效是游戏中常见的一种屏幕效果。这种特效可以模拟真实摄像机的一种图像效果，它让画面中较亮的区域“扩散”到周围的区域中，造成一种朦胧的效果。 Bloom的实现原理很简单：我们首先根据一个阈值提取出图像中较亮区域，把它们存储在一张渲染纹理中，再利用高斯模糊对这张渲染纹理进行模糊处理，模拟光线扩散的效果，最后再将其和原图像进行混合，得到最终的结果。 HDR是High Dynamic Range的缩写，即高动态范围，与之对应的是低动态范围（Low Dynamic Range，LDR）。常用HDR图片储存格式有hdr/tif/exr/raw等。我们身边的电子图片，几乎都是LDR。常用LDR图片储存格式有jpg/png等。 LDR只能算是对现实颜色进行压缩，并呈现出来。看似丰富，但真和现实中的颜色比，还是局限了许多，一旦需要进行调色等后续加工，便会因为颜色不够而难以进行。这便诞生了HDR。单通道位数超过8位，便可称为HDR，常见有12位和16位。 总的来说，利用HDR渲染让亮的物体可以真的非常亮，暗的物体可以真的非常暗，同时又可以看到两者之间的细节。而把HDR用ToneMapping压缩成LDR，再用Bloom表现高光溢出的效果。这是引擎内对画面的处理方式。 6. 渲染结果(4K) 我们对赛博朋克的爱，并非从2077开始，也不会因此而结束。","link":"/2020/04/27/unity-realtime-cyberpunk/"},{"title":"Unity小游戏-新冠入侵","text":"利用Unity独立开发的一个塔防类的小游戏~ 1. 游戏简介《新冠入侵》是一个基于安卓平台开发的抗击新冠疫情的小游戏，使用了Unity2019.3.3f1进行游戏的开发、Adobe Photoshop CC 2019完成美术资源的设计。 游戏技术点包含常用设计模式辅助项目开发（单例，工厂，对象池，中介者，外观，状态，责任链等模式），DoTween插件的使用方法，使用JsonMapper去解析和存贮简单json与复杂json，json的使用注意事项与强制解析。编辑器拓展功能来制作地图工具（提高我们游戏开发效率，自己制作一个简单插件）。还有更多细碎知识诸如数值策划知识，游戏物体在Inspector的调整，2D开发中常遇到问题的展现与解决，面向接口编程的使用与体验，对象池技术，Unity的2D图集处理，并切割出一张张小图片。Unity中赋值顺序探索等等。 2. 游戏需求与流程 3. 美术资源设计3.1 按钮设计按钮与游戏标题保持风格一致性，大部分为手绘风格，并使用鲜明的颜色。由于本游戏是针对安卓平台开发的，因此按钮只需要常规与Press状态，Press状态大多使用阴影表现。 3.2 页面设计按页面整体均为卡通手绘风格，使游戏能够有较大的用户群体。 4. 游戏设计模式与玩法机制4.1 设计模式本游戏综合使用了多种游戏设计模式。包括单例模式、工厂模式、对象池模式、外观模式、中介者模式、建造者模式、责任链模式。 单例模式：单例模式是一种常见的设计模式，具有以下特点：单例类只能有一个实例、单例类必须自己创建自己的唯一实例、单例类必须给所有其他对象提供这一实例。单例模式为一个面向对象的应用程序提供了对象惟一的访问点，不管它实现何种功能，整个应用程序都会同享一个实例对象。 工厂模式：工厂模式主要是为创建对象提供过渡接口，以便将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的。 对象池模式：对象池技术在第一次创建的时候就将对象存储在一个池子中，当需要销毁的时候不直接销毁而是隐藏，当需要时在再次使用，就不需要再次实例化一个新的对象，直接把隐藏的对象显示并拿出来用。如果对象池中已经被隐藏的物体太久没有被重新使用，应该被真正的销毁。 外观模式：外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。 中介者模式：中介者模式是一种比较常用的模式,一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。 建造者模式**：**建造者模式是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 责任链模式：责任链模式使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系，将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理他为止。 4.2 玩法机制游戏初始状态下玩家拥有800枚金币，且有10点生命值。当玩家金币不足以建塔时玩家可以通过击杀病毒或打开场景中的道具来获得金币；病毒每个成功入侵玩家的生命值将会减少1点，生命值为0则游戏失败并结束。当玩家成功击退所有波次的病毒则获胜。 - 病毒等级数值： ID/等级 病毒 生命值 移动速度 击杀奖励 1 100 1 50 2 200 2 100 3 300 3 150 4 400 4 200 5 500 5 250 6 600 6 300 - 炮塔等级数值： 根据防疫物品的特征：口罩有阻挡新冠病毒传播的能力，而84消毒液、75%医用酒精、含酒精洗手液有杀死病毒的能力。按照这些特征来设定游戏中塔的能力。 ID 等级 建塔价格 卖出价格 攻击CD 攻击范围 攻击速度 攻击伤害 攻击Buff 1 1 100 50 1.5 2 2 50 0.12 2 150 75 1 4 3 60 0.48 3 225 113 0.8 6 4 80 1.08 2 1 120 60 1 2 3 50 0.12 2 180 90 0.8 4 4 60 0.48 3 270 135 0.6 6 5 100 1.08 3 1 140 70 2 2 5 50 - 2 150 75 1.5 4 6 60 - 3 225 136 1 4 7 80 - 4 1 160 80 1.5 2 6 70 - 2 240 120 1.1 4 7 80 - 3 360 180 0.9 6 7 100 - 5 1 160 80 1.2 7 2 70 - 2 240 120 1 8 3 80 - 3 360 180 0.8 9 4 90 - （buff为减速buff，表中的buff值由减速大小×减速时长的结果） - 道具：游戏中道具的血量为800，打开道具后可获得1000金币的奖励，并且原来被道具占据的位置也可进行建塔操作。 - 集火：玩家可选定集火目标，目标可以是病毒和道具。选定目标后在防御塔的攻击范围内的塔会对目标进行集火攻击。 - 自动攻击：防御塔会自动攻击并跟踪进入其攻击范围内的病毒，可以通过升级塔来扩大攻击范围等能力。 - 防御塔操作：玩家可以在规定区域内建塔，其中道具所在位置和怪物入侵道路不可建塔。点击需要建塔的位置将展开建塔列表，再次点击可以收起建塔列表。点击已建的防御塔可以查看该塔目前是否可以升级，同时也可以看到塔的攻击范围。此外，玩家可以点击暂停后进行建塔，建塔完成后再点击继续。 - 病毒入侵：每波病毒只会在上一波病毒以完全消灭/成功入侵后开始入侵。 5. UML图 6. UI部分技术总结因为整个游戏项目的代码比较多，所以就只总结一些复用性比较高的部分内容。 6.1 DoTween插件的缓动函数本游戏使用 DoTween插件来配置UI动画，缓动函数指定动画效果在执行时的速度，用于控制动画从初始值运动到最终值的速率。 DoTween的其他内容在上一篇文章已经总结过了，这里就不再赘述了。 6.2 Scroll Rect组件游戏中的帮助页面与选择关卡界面都使用了Scroll View 组件。在Scroll View中，当需要在小区域显示占用大量空间的内容时，可以使用Scroll Rect。滚动矩形提供了滚动浏览此内容的功能。 Content：这是对用户界面要滚动的元素，例如大图像。 Horizontal/ Vertical：启用水平/垂直滚动。 Movement Type：无限制，弹性或夹紧。使用“弹性”或“夹紧”可将内容强制保留在“滚动矩形”的范围内。弹性模式在到达滚动矩形的边缘时会反弹内容。 Elasticity：弹性模式下使用的弹跳量。 Inertia：设置惯性后，拖动鼠标后释放指针，内容将继续移动。如果未设置惯性，则内容仅在拖动时才会移动。当使用DoTween插件来配置滚动动画时会产生冲突，需要关闭该选项。 Deceleration Rate：设置惯性后，减速率将决定对象停止移动的速度。0将立即停止运动。值为1表示运动永远不会减速。 Scroll Sensitivity：对滚轮和触控板滚动事件的敏感性。 Viewport：引用作为内容Rect变换父级的视口Rect变换。 Scrollbar：对滚动条元素的可选引用，可以设置滚动条的隐藏属性和滚动条与视口的空间大小。 6.3 GridLayoutGroup组件游戏中的帮助页面与选择关卡界面都使用了Scroll View 组件。在Scroll View的Content中通常会使用GridLayoutGroup组件来使内容的填充更有序。 Cell Size：Content中每个单位的宽高； Spacing：每个单位的间隔； Start Corner：开始的位置，如Upper Left则为从左上角开始排列； Start Axis：排列形式，分为水平排列和垂直排列； Child Alignment：排列方式，如Upper Center则为居中靠上排列； Constraint：约束，可选择行约束、列约束和无约束； Padding：Content整体偏移量。 6.4 翻页效果的实现思路游戏中的帮助页面与选择关卡界面都需要实现翻页效果。是要翻一页或者多页，使用的方法是让ScrollView用它自身长度的单位化比例来实现。为实现这个需求我们首先需要： ①content的总长 ②玩家鼠标的开始位置与结束位置，并根据开始滑动与结束滑动的事件方式计算差值。若开始位置-结束位置&gt;0，则右滑；若开始位置-结束位置&lt;0，则左滑。通过差值来决定滑动几个单元格。 ③移动一个单元格玩家鼠标需要滑动的距离（一个单元格长度+左偏移量）。 ④移动多个单元格玩家鼠标需要滑动的距离。其中第一个是单元格长度+左偏移量，之后的每一个滑动都是单元格长度+间隔。 ⑤滑动一个单元格所占的比例，可通过一个单元格所在位置中点的长度/Content的总长度得到。其中上限值与下限值为防止超过我们的最小长度与最大长度。 最后，可以推算出Content宽度与单元格长度与数量的关系式： 宽度=原来的宽度+（每一个单元格长度+间隙）*（单元格数量-1） 6.5 单页效果的实现本游戏中，翻页效果的实现分为单页效果（每次只能滑动一个页面）和多页效果（一次可以滑动多个页面）。其中单页效果通过使用改变局部坐标的方法实现脚本的成员变量来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;using DG.Tweening;/// &lt;summary&gt;/// 单滑/// &lt;/summary&gt;public class SlideScrollView : MonoBehaviour,IBeginDragHandler,IEndDragHandler { private RectTransform contentTrans; private float beginMousePositionX; private float endMousePositionX; private ScrollRect scrollRect; public int cellLength; public int spacing; public int leftOffset; private float moveOneItemLength; private Vector3 currentContentLocalPos;//上一次的位置 private Vector3 contentInitPos;//Content初始位置 private Vector2 contentTransSize;//Content初始大小 public int totalItemNum; private int currentIndex; public Text pageText; public bool needSendMessage; private void Awake() { scrollRect = GetComponent&lt;ScrollRect&gt;(); contentTrans = scrollRect.content; moveOneItemLength = cellLength + spacing; currentContentLocalPos = contentTrans.localPosition; contentTransSize = contentTrans.sizeDelta; contentInitPos = contentTrans.localPosition; currentIndex = 1; if (pageText != null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } } public void Init() { currentIndex = 1; if (contentTrans!=null) { contentTrans.localPosition = contentInitPos; currentContentLocalPos = contentInitPos; if (pageText != null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } } } /// &lt;summary&gt; /// 通过拖拽与松开来达成翻页效果 /// &lt;/summary&gt; /// &lt;param name=&quot;eventData&quot;&gt;&lt;/param&gt; public void OnEndDrag(PointerEventData eventData) { endMousePositionX = Input.mousePosition.x; float offSetX = 0; float moveDistance = 0;//当次需要滑动的距离 offSetX = beginMousePositionX - endMousePositionX; if (offSetX&gt;0)//右滑 { if (currentIndex&gt;=totalItemNum) { return; } if (needSendMessage) { UpdatePanel(true); } moveDistance = -moveOneItemLength; currentIndex++; } else//左滑 { if (currentIndex&lt;=1) { return; } if (needSendMessage) { UpdatePanel(false); } moveDistance = moveOneItemLength; currentIndex--; } if (pageText != null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } DOTween.To(()=&gt;contentTrans.localPosition,lerpValue=&gt;contentTrans.localPosition=lerpValue,currentContentLocalPos+new Vector3(moveDistance,0,0),0.5f).SetEase(Ease.OutQuint); currentContentLocalPos += new Vector3(moveDistance, 0, 0); //只能存在于此项目 GameManager.Instance.audioSourceManager.PlayPagingAudioClip(); } /// &lt;summary&gt; /// 按钮来控制翻书效果 /// &lt;/summary&gt; public void ToNextPage() { float moveDistance = 0; if (currentIndex&gt;=totalItemNum) { return; } moveDistance = -moveOneItemLength; currentIndex++; if (pageText!=null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } if (needSendMessage) { UpdatePanel(true); } DOTween.To(() =&gt; contentTrans.localPosition, lerpValue =&gt; contentTrans.localPosition = lerpValue, currentContentLocalPos + new Vector3(moveDistance, 0, 0), 0.5f).SetEase(Ease.OutQuint); currentContentLocalPos += new Vector3(moveDistance, 0, 0); } public void ToLastPage() { float moveDistance = 0; if (currentIndex &lt;=1) { return; } moveDistance = moveOneItemLength; currentIndex--; if (pageText != null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } if (needSendMessage) { UpdatePanel(false); } DOTween.To(() =&gt; contentTrans.localPosition, lerpValue =&gt; contentTrans.localPosition = lerpValue, currentContentLocalPos + new Vector3(moveDistance, 0, 0), 0.5f).SetEase(Ease.OutQuint); currentContentLocalPos += new Vector3(moveDistance, 0, 0); } public void OnBeginDrag(PointerEventData eventData) { beginMousePositionX = Input.mousePosition.x; } //设置Content的大小 public void SetContentLength(int itemNum) { contentTrans.sizeDelta = new Vector2(contentTrans.sizeDelta.x+(cellLength+spacing)*(itemNum-1),contentTrans.sizeDelta.y); totalItemNum = itemNum; } //初始化Content的大小 public void InitScrollLength() { contentTrans.sizeDelta = contentTransSize; } //发送翻页信息的方法 public void UpdatePanel(bool toNext) { if (toNext) { gameObject.SendMessageUpwards(&quot;ToNextLevel&quot;); } else { gameObject.SendMessageUpwards(&quot;ToLastLevel&quot;); } }} 6.6 多页效果的实现本游戏中，翻页效果的实现分为单页效果（每次只能滑动一个页面）和多页效果（一次可以滑动多个页面）。其中多页效果通过使用比例方法来实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;using UnityEngine.EventSystems;using DG.Tweening;public class SlideCanCoverScrollView : MonoBehaviour,IBeginDragHandler,IEndDragHandler { private float contentLength;//容器长度 private float beginMousePostionX; private float endMousePositionX; private ScrollRect scrollRect; private float lastProportion;//上一个位置比例 public int cellLength;//每个单元格长度 public int spacing;//间隙 public int leftOffset;//左偏移量 private float upperLimit;//上限值 private float lowerLimit;//下限值 private float firstItemLength;//移动第一个单元格的距离 private float oneItemLength;//滑动一个单元格需要的距离 private float oneItemProportion;//滑动一个单元格所占比例 public int totalItemNum;//共有几个单元格 private int currentIndex;//当前单元格索引 public Text pageText; private void Awake() { scrollRect = GetComponent&lt;ScrollRect&gt;(); contentLength = scrollRect.content.rect.xMax - 2 * leftOffset - cellLength; firstItemLength = cellLength / 2 + leftOffset; oneItemLength = cellLength + spacing; oneItemProportion = oneItemLength / contentLength; upperLimit=1- firstItemLength / contentLength; lowerLimit = firstItemLength / contentLength; currentIndex = 1; scrollRect.horizontalNormalizedPosition = 0; if (pageText != null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } } public void Init() { lastProportion = 0; currentIndex = 1; if (scrollRect != null) { scrollRect.horizontalNormalizedPosition = 0; pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } } public void OnEndDrag(PointerEventData eventData) { float offSetX = 0; endMousePositionX = Input.mousePosition.x; offSetX = (beginMousePostionX - endMousePositionX)*2; //Debug.Log(&quot;offSetX:&quot; + offSetX); //Debug.Log(&quot;firstItemLength:&quot; + firstItemLength); if (Mathf.Abs(offSetX)&gt;firstItemLength)//执行滑动动作的前提是要大于第一个需要滑动的距离 { if (offSetX&gt;0)//右滑 { if (currentIndex&gt;=totalItemNum) { return; } int moveCount = (int)((offSetX - firstItemLength) / oneItemLength) + 1;//当次可以移动的格子数目 currentIndex += moveCount; if (currentIndex&gt;=totalItemNum) { currentIndex = totalItemNum; } //当次需要移动的比例:上一次已经存在的单元格位置 //的比例加上这一次需要去移动的比例 lastProportion += oneItemProportion * moveCount; if (lastProportion&gt;=upperLimit) { lastProportion = 1; } } else //左滑 { if (currentIndex &lt;=1) { return; } int moveCount = (int)((offSetX + firstItemLength) / oneItemLength) - 1;//当次可以移动的格子数目 currentIndex += moveCount; if (currentIndex &lt;=1) { currentIndex = 1; } //当次需要移动的比例:上一次已经存在的单元格位置 //的比例加上这一次需要去移动的比例 lastProportion += oneItemProportion * moveCount; if (lastProportion &lt;= lowerLimit) { lastProportion = 0; } } if (pageText!=null) { pageText.text = currentIndex.ToString() + &quot;/&quot; + totalItemNum; } } DOTween.To(() =&gt; scrollRect.horizontalNormalizedPosition, lerpValue =&gt; scrollRect.horizontalNormalizedPosition = lerpValue, lastProportion, 0.5f).SetEase(Ease.OutQuint); GameManager.Instance.audioSourceManager.PlayPagingAudioClip(); } public void OnBeginDrag(PointerEventData eventData) { beginMousePostionX = Input.mousePosition.x; }} 6.7 UI实例化游戏中需要不断地将不同的UIPanel实例化到Canvas下进行显示。但是由于使用工厂模式，在实例化时会遇到UIPanel先实例化到Hierarchy中再设置其父对象。此时UIPanel的锚点就不是以Canvas的大小为准。 解决这个问题可以通过将锚点由原来的“包裹父对象”更改为“居中显示”，并在实例化时在设置其父对象为Canvas后将对应Panel的Pos改为0，Scale改为1即可解决。 UIPanel通过添加到UI管理字典，实例化当前场景所有面板，并存入字典。 12345678910111213141516171819202122232425262728293031//实例化当前场景所有面板，并存入字典public void InitDict(){ foreach (var item in mUIManager.currentScenePanelDict) { item.Value.transform.SetParent(canvasTransform); item.Value.transform.localPosition = Vector3.zero; item.Value.transform.localScale = Vector3.one; IBasePanel basePanel = item.Value.GetComponent&lt;IBasePanel&gt;(); if (basePanel == null) { Debug.Log(&quot;获取面板上IBasePanel脚本失败&quot;); } basePanel.InitPanel(); //Debug.Log(item.Key); currentScenePanelDict.Add(item.Key, basePanel); }}//清空UIPanel字典public void ClearDict(){ currentScenePanelDict.Clear(); mUIManager.ClearDict();}//添加UIPanel到UIManager字典public void AddPanelToDict(string uiPanelName){ mUIManager.currentScenePanelDict.Add(uiPanelName, GetGameObjectResource(FactoryType.UIPanelFactory, uiPanelName));} 6.8 克隆体名称问题与字符串截取游戏中实例化对象时，Instance方法会使用Perfabs的克隆体。因此实例化的对象会有(Clone)的后缀，在将对象放回对象池时会产生报空操作。解决这个问题的方法只需要对对象的名称进行截取，使用Substring()函数即可解决。 Substring的使用方法有两种： 一是Substring(int startIndex) ，子字符串从指定的字符位置（第startIndex个字符）开始，一直到此字符串末尾。 二是Substring(int startIndex, int length)，子字符串从指定的字符位置第startIndex个字符）开始，且具有指定的长度（子字符串的长度length）。 6.9 控制渲染顺序游戏中直接通过工厂实例化的对象的渲染顺序会出现错误的遮挡关系，可以通过Transform.SetSiblingIndex(i)来控制渲染顺序。I越大则对象越后渲染。 6.10 主面板的左右移动动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;public class MainPanel : BasePanel { private Tween[] mainPanelTween;//0.右，1.左 private Tween ExitTween;//离开主页运行的动画 protected override void Awake() { base.Awake(); //获取成员变量 transform.SetSiblingIndex(8); mainPanelTween = new Tween[2]; mainPanelTween[0] = transform.DOLocalMoveX(1920, 0.5f); mainPanelTween[0].SetAutoKill(false); mainPanelTween[0].Pause(); mainPanelTween[1] = transform.DOLocalMoveX(-1920, 0.5f); mainPanelTween[1].SetAutoKill(false); mainPanelTween[1].Pause(); } public override void EnterPanel() { transform.SetSiblingIndex(8); if (ExitTween != null) { ExitTween.PlayBackwards(); } } public override void ExitPanel() { ExitTween.PlayForward(); } public void MoveToRight() { mUIFacade.PlayButtonAudioClip(); ExitTween = mainPanelTween[0]; mUIFacade.currentScenePanelDict[StringManager.SetPanel].EnterPanel(); } public void MoveToLeft() { mUIFacade.PlayButtonAudioClip(); ExitTween = mainPanelTween[1]; mUIFacade.currentScenePanelDict[StringManager.HelpPanel].EnterPanel(); } ////场景状态切换的方法 public void ToNormalModelScene() { mUIFacade.PlayButtonAudioClip(); mUIFacade.currentScenePanelDict[StringManager.GameLoadPanel].EnterPanel(); mUIFacade.ChangeSceneState(new NormalGameOptionSceneState(mUIFacade)); } } 6.11 帮助面板的页面切换123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105using System.Collections;using System.Collections.Generic;using UnityEngine;using DG.Tweening;using UnityEngine.SceneManagement;public class HelpPanel : BasePanel { private GameObject helpPageGo; private GameObject covidPageGo; private GameObject defendPageGo; private SlideScrollView slideScrollView; private Tween helpPanelTween; protected override void Awake() { base.Awake(); helpPageGo = transform.Find(&quot;HelpPage&quot;).gameObject; covidPageGo = transform.Find(&quot;CovidPage&quot;).gameObject; defendPageGo = transform.Find(&quot;DefendPage&quot;).gameObject; slideScrollView = transform.Find(&quot;HelpPage&quot;).Find(&quot;Scroll View&quot;).GetComponent&lt;SlideScrollView&gt;(); helpPanelTween = transform.DOLocalMoveX(0, 0.5f); helpPanelTween.SetAutoKill(false); helpPanelTween.Pause(); } //显示页面的方法 public void ShowHelpPage() { if (!helpPageGo.activeSelf) { mUIFacade.PlayButtonAudioClip(); helpPageGo.SetActive(true); } covidPageGo.SetActive(false); defendPageGo.SetActive(false); } public void ShowCovidPage() { mUIFacade.PlayButtonAudioClip(); helpPageGo.SetActive(false); covidPageGo.SetActive(true); defendPageGo.SetActive(false); } public void ShowDefendPage() { mUIFacade.PlayButtonAudioClip(); helpPageGo.SetActive(false); covidPageGo.SetActive(false); defendPageGo.SetActive(true); } //处理面板的方法 public override void InitPanel() { base.InitPanel(); transform.SetSiblingIndex(5); slideScrollView.Init(); ShowHelpPage(); //其他处理 if (transform.localPosition == Vector3.zero) { gameObject.SetActive(false); helpPanelTween.PlayBackwards(); } transform.localPosition = new Vector3(1920, 0, 0); } public override void EnterPanel() { base.EnterPanel(); gameObject.SetActive(true); slideScrollView.Init(); MoveToCenter(); } public override void ExitPanel() { base.ExitPanel(); mUIFacade.PlayButtonAudioClip(); //选择场景 if (mUIFacade.currentSceneState.GetType() == typeof(NormalGameOptionSceneState)) { mUIFacade.ChangeSceneState(new MainSceneState(mUIFacade)); SceneManager.LoadScene(1); } else//如果是在主场景 { helpPanelTween.PlayBackwards(); mUIFacade.currentScenePanelDict[StringManager.MainPanel].EnterPanel(); } } public void MoveToCenter() { helpPanelTween.PlayForward(); }} 7. 制图工具的实现为了能过在工程中更方便快捷的开发游戏关卡地图，自定义了一个制图工具并使用宏（Tool）来将工具代码和游戏（Game）代码进行区分。将游戏场景划为6行12列，并将绘制好的地图保存为json文件。 单击地图中的格子将该位置设为不可建塔区域，按住P键单击地图中的格子将该位置设为病毒入侵路径（路径按照点击顺序，只需要在起始点和转角区域点击即可），按住I键单击地图中的格子将该位置设为道具位置，多次点击可以切换道具（道具1占据1格，道具2占据2格，道具3占据4格）。 Level为当前编辑的地图关卡，可手动设置。Round Info List为病毒波次以及每波怪物的设置。编辑完当前关卡的地图后可点击“保存当前关卡数据”将关卡数据保存为json文件，保存后的关卡数据可以再次读取编辑。 8. 游戏主逻辑8.1 产怪逻辑 Level对象控制round责任链的执行。 具体产怪的逻辑是通过round去执行的，round里存有本回合需要产生的怪物数量与ID，之后会把这些内容传入GameController去调用Invoke方法延时。 循环产生病毒。(把产怪方法封装在CameContoller里，而不是直接在round里去完成这个方法的原因:①需要延时循坏调用方法InvokeRepeating，它是Mono里的方法。②很多游戏逻辑类与信息存贮在了GameController里，所以我们必须这样去设计)。 但在生成病毒的时候，会出现玩家暂停产生病毒去建塔的情况，所以需要通过调用GameController的停止方法去停止延时调用。并且需要随时去打开。因此将暂停开关的监听放在Update方法里。 每次调用产怪方法的时候都需要去判断一下当前产怪是否完成当次回合的产怪总数，完成则停止。否则让产怪索引去累加。 即时监听玩家的杀怪数量。如果杀怪数量一旦等于当次回合怪物的总数，便调用level里的有关方法、把当前任务交给责任链的下一环，即进入下一个回合。每次调用Level有关方法的时候会判断责任链是否到达最后一环，如果到达，则显示最后一波有关逻辑，如果超过，则游戏胜利。 8.2 炮塔搜索目标的有关逻辑 8.3 建塔列表的优化游戏中建塔列表如下图。如果不对其进行优化列表在左边缘、右边缘和上边缘都不能完整显示。同理，销售与升级按钮也有这样的问题。因此需要对建塔列表与塔操作UI进行纠正。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//纠正建塔列表的位置private Vector3 CorrectTowerListGoPosition(){ Vector3 correctPosition = Vector3.zero; if (gridIndex.xIndex &lt;= 3 &amp;&amp; gridIndex.xIndex &gt;= 0) { correctPosition += new Vector3(gameController.mapMaker.gridWidth, 0, 0); } else if (gridIndex.xIndex &lt;= 11 &amp;&amp; gridIndex.xIndex &gt;= 8) { correctPosition -= new Vector3(gameController.mapMaker.gridWidth, 0, 0); } if (gridIndex.yIndex &lt;= 2 &amp;&amp; gridIndex.yIndex &gt;= 0) { correctPosition += new Vector3(0, gameController.mapMaker.gridHeight, 0); } else if (gridIndex.yIndex &lt;= 5 &amp;&amp; gridIndex.yIndex &gt;= 3) { correctPosition -= new Vector3(0, gameController.mapMaker.gridHeight, 0); } correctPosition += transform.position; return correctPosition;}//纠正操作塔UI画布的方法(纠正按钮位置的方法)private void CorrectHandleTowerCanvasGoPosition(){ upLevelButtonTrans.localPosition = Vector3.zero; sellTowerButtonTrans.localPosition = Vector3.zero; if (gridIndex.yIndex &lt;= 0) { if (gridIndex.xIndex == 0) { sellTowerButtonTrans.position += new Vector3(GameController.Instance.mapMaker.gridWidth * 3 / 4, 0, 0); } else { sellTowerButtonTrans.position -= new Vector3(GameController.Instance.mapMaker.gridWidth * 3 / 4, 0, 0); } upLevelButtonTrans.localPosition = upLevelButtonInitPos; } else if (gridIndex.yIndex &gt;= 4) { if (gridIndex.xIndex == 0) { upLevelButtonTrans.position += new Vector3(GameController.Instance.mapMaker.gridWidth * 3 / 4, 0, 0); } else { upLevelButtonTrans.position -= new Vector3(GameController.Instance.mapMaker.gridWidth * 3 / 4, 0, 0); } sellTowerButtonTrans.localPosition = sellTowerButtonInitPos; } else { upLevelButtonTrans.localPosition = upLevelButtonInitPos; sellTowerButtonTrans.localPosition = sellTowerButtonInitPos; }} 8.4 防御塔跟随目标朝向游戏中防御塔会跟随攻击目标旋转，这里使用的是Transform.LookAt()，但该函数在使用时会出现一个问题：由于塔与怪物不在同一层级上（深度不同），因此使用LookAt()函数会出现三维坐标上的旋转问题，投射到二维摄像机则会出现对象变形的情况。通过判定条件设置其x与y轴坐标即可修复。 123456789101112131415//旋转 //transform.LookAt(targetTrans); if (targetTrans.gameObject.tag == &quot;Item&quot;) { transform.LookAt(targetTrans.position + new Vector3(0, 0, 3)); } else { transform.LookAt(targetTrans.position); } if (transform.eulerAngles.y == 0) { transform.eulerAngles += new Vector3(0, 90, 0); } 9. 总结游戏目前仍有一些不足点，例如： 关卡少，还未设计其他关卡； 防御塔目前虽然有5种，但其攻击形式只有2种； 未实现游戏数据的存储功能； 未适配移动端的全面屏； 游戏的数值设计还不够科学。","link":"/2020/05/13/unity-coviddefend/"},{"title":"从零开始搭建Hexo个人博客","text":"这几天一直在折腾学习 Hexo 博客框架的部署和搭建，目前基本已经成型了，通过这几天的不断折腾对比，发现 Hexo 还是很有些独特的特色的。 记录一下整个Hexo博客的搭建过程吧，后面逐步把以前的一些记录搬过来。 Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，利用主题生成静态网页。 2019.3.8更新 更换了博客的主题，并部署到阿里云上 2020.4.7更新 解决博客公式显示问题 1. 环境配置环境配置部分参考了codesheep的搭建教程。 1.1 安装Node.js 因为Hexo是基于Node.js的，所以第一步就是安装Node.js。到Node.js的官网下载最新的版本（选择LTS版）。 下载完成安装后可在命令提示符中输入 12node -vnpm -v 来检验是否完成安装。 因为npm的访问速度可能会比较慢，所以推荐安装cnpm（淘宝镜像），在命令提示符输入如下内容 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装完成后可输入cnpm -v来检验是否完成安装。 1.2 安装Hexo 在命令提示符中输入 1cnpm install -g hexo-cli 完成hexo的安装。同样完成后可输入hexo -v来检验。 在需要的盘符目录下输入 1mkdir blog 生成名称为blog的文件夹（存放hexo博客）。 输入 1hexo init 新建一个主题为landscape的博客。 输入 1hexo s 启动服务器，此时便可以访问http://localhost:4000/对博客进行预览。 发布博客等指令可以参考官方中文文档。Markdown编辑工具个人使用的是Typora，支持中文。 1.3 Git的安装前往淘宝 Git for Windows 镜像下载 git 安装包。按提示逐步安装即可，安装完成后右键菜单中出现Git Bash和Git GUI菜单表明安装成功。 1.4 Hexo的基本配置Hexo的配置文件为_config.yml，使用Visual Stuido Code可以直接打开修改。 1.4.1 添加分类/标签生成“分类”页并添加tpye属性，进入博客目录。执行下方命令 12hexo new page categorieshexo new page tags 在source文件夹内会生成对应的文件夹，进入并修改index.md文件。 分别添加如下字段 1type: categories 1type: tags 为了每次hexo new “my new blog title”时就有对应字段，我们可以在scaffolds/post.md里配上这个字段 12tags:categories: 1.4.2 解决链接过长问题因为Hexo是根据站点-日期-标题生成对应文章的链接，所以在使用中文标题时链接会因为转码的原因过长。 通过添加urlname属性来解决这个问题，具体方法与1.3.1类似，添加对应的type类型即可。然后在配置文件_config.yml中修改为 1permalink: :year/:month/:day/:urlname/ 这样生成的链接就是这样了：http://www.zanple.top/2020/03/26/create-hexo-blog/ 1.4.3 添加插件 评论系统使用的Valine 1234567comment: type: valine app_id: # (required) LeanCloud application id app_key: # (required) LeanCloud application key notify: # (optional) receive email notification verify: # (optional) show verification code placeholder:# (optional) comment box placeholder text 分享系统使用的sharejs 12share: type: sharejs 1.4.4 公式渲染因为hexo默认的渲染引擎是 marked，所以在渲染一些公式（例如列矩阵）时会出现显示问题。解决方法有两种：一是更换渲染引擎，选择kramed引擎以支持mathjax公式的输出；二是引入外部js，例如mathjax。 我选用的是第二种方式，在需要插入的地方引用，例 When $a \\ne 0$, there are two solutions to \\(ax^2 + bx + c = 0\\) and they are $$ \\begin{bmatrix} 1 & 2 & 3 \\\\ 4 & 5 & 6 \\\\ 7 & 8 & 9 \\end{bmatrix} \\tag{4} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 可见，列矩阵能够正常显示了。 2. 主题的更换与优化修改主题使用的是Icarus，安装方法可以参考官方博客。 2.1 主题的更换Hexo中更换主题比较简单，只要修改配置文件_config.yml的对应字段即可 1theme: icarus 2.2 主题的优化修改对Icarus主题的优化修改，主要参考了big-news和alphalxy的文章。 2.2.1 取消“目录”栏的自动编号找到第一个if语段中如下的位置： \\icarus\\layout\\widget\\toc.ejs1&lt;span class=&quot;has-mr-6&quot;&gt;${toc.index}&lt;/span&gt; 把它注释掉： \\icarus\\layout\\widget\\toc.ejs1&lt;!--span class=&quot;has-mr-6&quot;&gt;${toc.index}&lt;/span--&gt; 2.2.2 站底备案号及链接打开\\icarus\\layout\\common\\footer.ejs，找到： 12345 &lt;% if (has_config('plugins.busuanzi') ? get_config('plugins.busuanzi') : false) { %&gt; &lt;span id=\"busuanzi_container_site_uv\"&gt; &lt;%- _p('plugin.visitor', '&lt;span id=\"busuanzi_value_site_uv\"&gt;0&lt;/span&gt;') %&gt; &lt;/span&gt;&lt;% } %&gt; 一段，在后面添加： 12&lt;br&gt; &lt;a class=\"has-link-black-ter-2 -link\" href=\"http://beian.miit.gov.cn/\" target=\"_blank\"&gt;省份ICP备xxx号-x&lt;/a&gt; 然后更改样式文件。打开\\icarus\\source\\css\\style.styl，找到这样的两段： 1234567.has-link-black-ter transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important\\icarus\\source\\css\\style.styl.has-link-black-ter color: hsl(0, 0%, 14%) !important 把这两段分别扩充成： 12345678910111213.has-link-black-ter transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important.has-link-black-ter-2 transition: 0.2s ease &amp;:hover color: hsl(217, 71%, 53%) !important\\icarus\\source\\css\\style.styl.has-link-black-ter color: hsl(0, 0%, 14%) !important .has-link-black-ter-2 color: hsl(0, 0%, 30%) !important 就好了。 2.2.3 markdown行间代码样式打开\\icarus\\source\\css\\style.styl，找到并修改为 1234567code padding: 0 background: #FFE9E9 &amp; &gt; code, :not(pre) &gt; code font-size: 0.85em color: #F52424 2.2.4 文章页面两栏布局主题默认是三栏布局，并且显示了很多的 widget ，但在阅读文章时显得有些拥挤。因此在文章页面，修改为两栏布局，并显示特定的 widget。 1234567891011diff:includes/helpers/layout.js const widgets = hexo.extend.helper.get('get_config').bind(this)('widgets');- return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ if (this.page.layout !== 'post') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; widget.position === position);+ }+ if (position === 'left') {+ return widgets.filter(widget =&gt; widget.hasOwnProperty('position') &amp;&amp; (widget.type === 'toc' || widget.type === 'profile'));+ } else {+ return []+ } 可以参考上述代码，即可实现不同页面不同 widget。 但两栏整体宽度跟三栏不同。因此强制指定为三栏布局，并且修改相应的宽度，这样所有的页面侧边栏宽度保持一致。 123456789101112131415161718diff:layout/common/widget.ejs &lt;% function side_column_class() { switch (column_count()) { case 2:- return 'is-4-tablet is-4-desktop is-4-widescreen';+ return 'is-4-tablet is-4-desktop is-3-widescreen'; case 3:diff:layout/layout.ejs-&lt;body class=\"is-&lt;%= column_count() %&gt;-column\"&gt;+&lt;body class=\"is-3-column\"&gt; &lt;%- partial('common/navbar', { page }) %&gt; &lt;% function main_column_class() { switch (column_count()) { case 1: return 'is-12'; case 2:- return 'is-8-tablet is-8-desktop is-8-widescreen';+ return 'is-8-tablet is-8-desktop is-9-widescreen'; 并修改在不同屏幕小大下的宽度 1234567891011121314diff:source/css/style.styl .is-2-column .container max-width: screen-desktop - 2 * gap width: screen-desktop - 2 * gap+ .is-3-column .container+ max-width: screen-widescreen - gap+ width: screen-widescreen - gap @media screen and (min-width: screen-fullhd)+ .is-3-column .container+ max-width: screen-fullhd - 2 * gap+ width: screen-fullhd - 2 * gap .is-2-column .container max-width: screen-widescreen - 2 * gap width: screen-widescreen - 2 * gap 2.2.5 优化文章标题布局标题移动到文章信息上方，增加更新时间，并增加了icon。 123456789101112131415161718diff:layout/common/article.ejs &lt;div class=\"card-content article &lt;%= post.hasOwnProperty('direction') ? post.direction : '' %&gt;\"&gt;+ &lt;h1 class=\"title is-size-3 is-size-4-mobile has-text-weight-normal\"&gt;+ &lt;% if (index) { %&gt;+ &lt;a class=\"has-link-black-ter\" href=\"&lt;%- url_for(post.link ? post.link : post.path) %&gt;\"&gt;&lt;i class=\"fas fa-angle-double-right\"&gt;&lt;/i&gt;&lt;%= post.title %&gt;&lt;/a&gt;+ &lt;% } else { %&gt;+ &lt;i class=\"fas fa-angle-double-right\"&gt;&lt;/i&gt;&lt;%= post.title %&gt;+ &lt;% } %&gt;+ &lt;/h1&gt; &lt;% if (post.layout != 'page') { %&gt; &lt;div class=\"level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto\"&gt; &lt;div class=\"level-left\"&gt;- &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;+ &lt;time class=\"level-item has-text-grey\" datetime=\"&lt;%= date_xml(post.date) %&gt;\"&gt;&lt;i class=\"far fa-calendar-alt\"&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.date) %&gt;&lt;/time&gt;+ &lt;% if (post.updated &amp;&amp; post.updated &gt; post.date) { %&gt;+ &lt;time class=\"level-item has-text-grey is-hidden-mobile\" datetime=\"&lt;%= date_xml(post.updated) %&gt;\"&gt;&lt;i class=\"far fa-calendar-check\"&gt;&amp;nbsp;&lt;/i&gt;&lt;%= date(post.updated) %&gt;&lt;/time&gt;+ &lt;% } %&gt; &lt;% if (post.categories &amp;&amp; post.categories.length) { %&gt; 其中创建时间使用日期。 123456diff:source/js/main.js- if (typeof(moment) === 'function') {- $('.article-meta time').each(function () {- $(this).text(moment($(this).attr('datetime')).fromNow());- });- } 2.2.6 优化文章结尾布局在文章结尾增加一个 hr，并修改 tags 展示。在预览时也显示 tags，并且将 Read More 按钮放置在右边。 12345678910111213141516171819202122232425262728293031323334353637diff:layout/common/article.ejs &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt;+ &lt;hr style=\"height:1px;margin:1rem 0\"/&gt; &lt;div class=\"level is-size-7 is-uppercase\"&gt; &lt;div class=\"level-start\"&gt; &lt;div class=\"level-item\"&gt;- &lt;span class=\"is-size-6 has-text-grey has-mr-7\"&gt;#&lt;/span&gt;+ &lt;i class=\"fas fa-tags has-text-grey\"&gt;&lt;/i&gt;&amp;nbsp; &lt;%- list_tags(post.tags, { class: 'has-link-grey ', show_count: false,- style: 'link'+ style: 'link',+ separator: ',&amp;nbsp;' }) %&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% } %&gt; &lt;% if (index &amp;&amp; post.excerpt) { %&gt;- &lt;div class=\"level is-mobile\"&gt;+ &lt;hr style=\"height:1px;margin:1rem 0\"/&gt;+ &lt;div class=\"level is-mobile is-flex\"&gt;+ &lt;div class=\"level-start\"&gt;+ &lt;% if (post.tags &amp;&amp; post.tags.length) { %&gt;+ &lt;div class=\"level-item is-size-7 is-uppercase\"&gt;+ &lt;i class=\"fas fa-tags has-text-grey\"&gt;&lt;/i&gt;&amp;nbsp;+ &lt;%- list_tags(post.tags, {+ class: 'has-link-grey ',+ show_count: false,+ style: 'link',+ separator: ',&amp;nbsp;'+ }) %&gt;+ &lt;/div&gt;+ &lt;% } %&gt;+ &lt;/div&gt; &lt;div class=\"level-start\"&gt; 2.2.7 优化移动端显示在移动端，隐藏 archive 和 tagcloud。 123456diff:layout/widget/archive.ejs-&lt;div class=\"card widget\"&gt;+&lt;div class=\"card widget is-hidden-mobile\"&gt;diff:layout/widget/tagcloud.ejs-&lt;div class=\"card widget\"&gt;+&lt;div class=\"card widget is-hidden-mobile\"&gt; 2.2.8 目录粘性布局增加 column-left is-sticky 类。 123diff:layout/widget/toc.ejs-&lt;div class=\"card widget\" id=\"toc\"&gt;+&lt;div class=\"card widget column-left is-sticky\" id=\"toc\"&gt; 2.2.9 增加版权说明123456789101112131415diff:layout/common/article.ejs &lt;div class=\"content\"&gt; &lt;%- index &amp;&amp; post.excerpt ? post.excerpt : post.content %&gt; &lt;/div&gt;+ &lt;% if (!index &amp;&amp; post.layout === 'post' &amp;&amp; post.copyright !== false) { %&gt;+ &lt;ul class=\"post-copyright\"&gt;+ &lt;li&gt;&lt;strong&gt;本文标题：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= page.title %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;&lt;a href=\"&lt;%= theme.url %&gt;\"&gt;&lt;%= theme.author %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;本文链接：&lt;/strong&gt;&lt;a href=\"&lt;%= post.permalink %&gt;\"&gt;&lt;%= post.permalink %&gt;&lt;/a&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;发布时间：&lt;/strong&gt;&lt;%= post.date.format(\"YYYY-MM-DD\") %&gt;&lt;/li&gt;+ &lt;li&gt;&lt;strong&gt;版权声明：&lt;/strong&gt;本博客所有文章除特别声明外，均采用 &lt;a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\" rel=\"external nofollow\" target=\"_blank\"&gt;CC BY-NC-SA 4.0&lt;/a&gt; 许可协议。转载请注明出处！+ &lt;/li&gt;+ &lt;/ul&gt;+ &lt;% } %&gt; &lt;% if (!index &amp;&amp; post.tags &amp;&amp; post.tags.length) { %&gt; 并增加样式 123456789diff:source/css/style.styl+.post-copyright+ font-size: 1rem+ letter-spacing: 0.02rem+ word-break: break-all+ margin: 2.5rem 0 0+ padding: 1rem 1rem+ border-left: 3px solid #FF1700+ background-color: #F9F9F9 2.2.10 修复嵌入视频显示大小异常12345678910111213.bilibili{ position: relative; width: 100%; height: 0; /*高度设置这里无效，设置为0，用padding撑开div*/ padding-bottom: 75%; /*68%到80%都可以*/}.bilibili iframe { position: absolute; width: 100%; height: 100%; left: 0; top: 0;} 3. 阿里云部署Hexo博客的阿里云部署主要参照于阿汤笔迹的文章。基于CentOS 7.4. 3.1 阿里云服务器设置3.1.1 远程连接Linux实例远程连接服务器的方法都很多。我们既可以通过阿里云自带的VNC（Virtual Network Console，虚拟网络控制台）远程连接Linux实例，也可以通过远程连接软件（例如PuTTY、Xshell、SecureCRT等）连接Linux实例。 我这里用到是VNC方法。需要说明的是：使用阿里云自带的VNC远程连接Linux实例，登录VNC窗口时还要输入一个6位数的远程连接密码，用于连接ECS管理控制台的管理终端，注意不要与root密码混淆。 注： 远程连接密码用于连接ECS管理控制台的管理终端，而实例登录密码（root密码）用于登录实例。 远程连接密码仅在第一次连接管理终端时显示一次，建议启用后立即修改远程连接密码。 具体连接步骤如下：a. 在实例列表中选中当前实例，点击右侧按钮：远程连-&gt;VNC。b. 输入远程连接密码。 c. 在控制台中输入用户名：root，及其root密码（实例密码）。回车即可进入阿里云ECS服务器的后台，如下图所示。 后面，我们主要就是利用此终端在ECS上部署网站运行环境了。 3.1.2 配置安全组由于我们要通过80端口访问nginx服务，而阿里云默认是禁止80端口访问权限的，所以我们要为实例手动添加安全组，让阿里云给相应的端口和IP放行。该步骤非常重要，若不手动配置，我们将无法通过“公网IP+端口”的方式访问我们的ECS服务器。 具体操作步骤如下：a. 打开阿里云服务管理控制台，点击左侧菜单中的“安全组”按钮，查看安全组列表。b. 点击右上角的“创建安全组”按钮，创建一个新的安全组。c. 立即为新建的安全组添加安全组规则，在入方向解除端口和IP限制，具体参数设置如下图所示。 d. 在实例列表中为实例添加安全组。 这样就完成了安全组的配置。注：安全组出方向默认允许所有访问，即从安全组内ECS访问外部都是放行的。 3.2 Hexo博客的阿里云部署3.2.1 安装nginx因为我们用nginx作Web服务器，所以我们需要先安装nginx服务。具体步骤如下： 使用root用户远程登录阿里云服务器，使用yum命令进行安装。 a. 安装nginx依赖环境，安装期间有提示一律选yes。 1234#yum install gcc-c++#yum install -y pcre pcre-devel#yum install -y zlib zlib-devel#yum install -y openssl openssl-devel b. 下载nginx安装包。 1#wget -c https://nginx.org/download/nginx-1.10.1.tar.gz c. 将安装包解压到/usr/local目录下。 1#tar -xvf nginx-1.10.1.tar.gz -C /usr/local d. 进入/usr/local目录，确认nginx解压到该目录下。 12#cd /usr/local#ls e. 进入nginx-1.10.1目录，会发现该目录下有一个configure文件，执行该配置文件。 123#cd nginx-1.10.1/#ls#./configure f. 编译并安装nginx。 12#make#make install g. 查找nginx安装目录。 1#whereis nginx h.进入安装目录。 12#cd /usr/local/nginx#ls i. 由于nginx默认通过80端口访问，而Linux默认情况下不会开发该端口号，因此需要开放linux的80端口供外部访问。 1#/sbin/iptables -I INPUT -p tcp -–dport 80 -j ACCEPT j. 进入/usr/local/nginx/sbin目录，启动nginx。 12#cd sbin#./nginx 没有任何消息，代表启动成功。此时，便可以通过“公网IP+端口”的方式访问 http://xx.xx.xxx.xxx:80/ 进入nginx欢迎页面了。注：（1）可以使用./nginx -s stop命令停止服务；（2）网站搭建成功后，若出现宕机现象，很有可能是nginx服务器挂了，此时应检查nginx服务器状态，并进行重启操作。 3.2.2 配置nginx服务器路由a. 专门为hexo创建一个部署目录/home/www/hexo。 1#mkdir -p /home/www/hexo b. 进入/usr/local/nginx/conf目录，打开该文件夹下的nginx.conf配置文件。 123#cd /usr/local/nginx/conf#ls#vim nginx.conf 进入后按i键由命令模式切换到编辑模式。 将其中的部署根目录（root）修改为/home/www/hexo； 将域名（server_name）修改为www.zanple.top，如果暂时没有域名就填阿里云实例的公网ip，以后有了再改回来； 查看监听端口（listen）的系统默认值是否为80（不用修改）。 完成以上修改后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。 3.2.3 安装node.jsa. 退回根目录，安装node.js。 123#cd ~#curl -sL https://rpm.nodesource.com/setup_10.x | bash -#yum install -y nodejs b. 查看安装结果，打印版本号即为安装成功。 12#node -v#npm -v 3.2.4 安装Gita. 使用yum命令安装Git，安装期间有提示一律选yes。 1#yum install git b. 安装成功后，查看版本号。 1#git --version 3.2.5 创建git用户为了实现博客的自动部署，我们后面要使用公钥免密登录服务器。为了安全起见，最好不要使用root用户免密登录。因此，我们要创建一个新的git用户，用于远程公钥免密登录服务器。 a. 创建git用户。 1#adduser git b. 修改git用户的权限。 1#chmod 740 /etc/sudoers c. 打开文件。 1#vim /etc/sudoers 进入后按i键由命令模式切换到编辑模式。找到 root ALL=(ALL) ALL，在下面添加一行git ALL=(ALL) ALL。修改完成后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。 d. 保存退出后改回权限。 1#chmod 400 /etc/sudoers e. 设置git用户的密码。 1#sudo passwd git 设置密码：*\\*******，这样我们就可以使用git用户远程登录阿里云服务器了。 3.2.6 给git用户配置ssh免密公钥登录使用git用户免密公钥登录阿里云服务器的原理是：在本地计算机生成一个公钥文件和一个秘钥文件（类似于一个钥匙配一把锁)，然后使用FTP工具将公钥文件上传到阿里云服务器，并公钥安装到authorized_keys列表中去（即：将公钥文件的内容拷贝到authorized_keys文件中去）。这样本地计算机便可以通过ssh方式免密连接我们的阿里云服务器了。 具体操作步骤如下： a. 在服务器端将登陆用户切换到git用户，然后在~目录(根目录)下创建.ssh文件夹，用来存放公钥。 123#su git$cd ~$mkdir .ssh b. 在本地计算机桌面右键打开GitBash，在本地生成公钥/私钥对。 123$cd ~$cd .ssh$ssh-keygen 接下来，碰见系统询问就直接按回车键。此时便会在本地计算机的用户根目录（C:\\Users\\tangcl）下自动生成.ssh（隐藏）文件夹，并在其中创建两个文件，分别为：id_rsa（私钥）和id_rsa.pub（公钥）。 c. 在本地计算机上给私钥设置权限。 12$ chmod 700 ~/.ssh$ chmod 600 ~/.ssh/id_rsa d. 下载并安装FTP工具，我这里用的是阿里云官方提供的FileZilla（Windows版本）。 e. 打开FileZilla，使用git用户通过22端口远程连接到阿里云服务器，将客服端生成的公钥上传到服务器的~/.ssh目录下。 f. 上传完成后切回服务器端，继续以git用户的身份进入服务器~/.ssh目录，新建一个authorized_keys文件，并将id_rsa.pub文件中公钥的内容拷贝到该文件中。（注：该步骤既可以用命令行操作，也可使用FTP工具操作。） 123$cd ~/.ssh$cp id_rsa.pub authorized_keys$cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys g. 在服务器上设置文件权限： 12$chmod 600 ~/.ssh/authorized_keys$chmod 700 ~/.ssh h. 确保设置了正确的SELinux上下文。 1$ restorecon -Rv ~/.ssh 现在，当您使用ssh远程登录服务器时，将不会提示您输入密码（除非您在创建密钥对时输入了密码）。i. 接下来在本地计算机上使用ssh方式连接我们的云服务器。 1$ssh -v git@xxx.xxx.xxx.xxx（阿里云公网IP） 或 1$ssh git@xxx.xxx.xxx.xxx（阿里云公网IP） 使用git用户ssh免密公钥登录成功界面如下图所示。 3.2.7 配置Git仓库a. 在服务器上使用git用户创建一个Git仓库，并且在该仓库中新建一个post-receive钩子文件。 123$cd ~$git init --bare hexo.git$vi ~/hexo.git/hooks/post-receive b. 进入后按i键由命令模式切换到编辑模式。输入：git –work-tree=/home/www/hexo –git-dir=/home/git/hexo.git checkout -f 即：让钩子文件删除/home/www/hexo目录下原有的文件，然后从blog.git仓库 clone 新的博客静态文件到/home/www/hexo目录下。 完成以上修改后，先按Esc由编辑模式切换到命令模式，再输入:wq命令保存并退出编辑器。 c. 授予钩子文件可执行权限。 123$chmod +x ~/hexo.git/hooks/post-receive$cd ~$sudo chmod -R 777 /home/www/hexo d. 重启ECS服务器实例。 至此我们就完成了所有关于服务器端的配置。 3.3 其它配置3.3.1 客服端hexo配置a. 在本地计算机hexo的工程目录下，找到_config.yml，对deploy参数进行修改，如下图所示。 b. 在本地计算机安装插件: hexo-deployer-git 和 hexo-server。在myblogs文件夹下右键打开GitBash，输入以下命令： 12$npm install hexo-deployer-git --save$npm install hexo-server 这俩插件的作用分别是使用Git自动部署，和hexo本地简单的服务器。 c. 在本地计算机配置Git全局变量。输入以下命令： 12$ git config --global user.email &quot;xxxxxxxxxx@qq.com&quot;$ git config --global user.name “tangcl” d. 使用Hexo生成、发布个人博客。 123$ hexo clean$ hexo generate$ hexo deploy 此时，便可以通过浏览器访问http://xxx.xxx.xxx.xxx:80/ 进入hexo我的博客主页了。 3.3.2 域名绑定待ECS服务器备案审核通过，在阿里云后台对域名解析进行设置，将域名的解析值修改为ECS实例的公网IP。进而完成域名与ECS服务器实例的公网IP进行绑定。","link":"/2018/11/18/create-hexo-blog/"},{"title":"几个GLSL小尝试","text":"1. 笑脸跟着Martijn Steinrucken aka BigWings教程做的一个笑脸。~ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200// Originate from Martijn Steinrucken aka BigWings#define S(a, b, t) smoothstep(a, b, t)#define B(a, b, blur, t) S(a-blur, a+blur, t)*S(b+blur, b-blur, t)#define sat(x) clamp(x, 0., 1.)float remap01(float a, float b, float t) { return sat((t-a)/(b-a));}float remap(float a, float b, float c, float d, float t) { return sat((t-a)/(b-a)) * (d-c) + c;}vec2 within(vec2 uv, vec4 rect) { return (uv-rect.xy)/(rect.zw-rect.xy);}vec4 Brow(vec2 uv, float smile) { float offs = mix(.2, 0., smile); //眉毛提起效果 uv.y += offs; float y = uv.y; uv.y += uv.x*mix(.5, .8, smile)-mix(.1, .3, smile); //眉毛上移 眉毛光泽变化 上下移动效果 uv.x -= mix(.0, .1, smile); //眉毛间距 左右移动 uv -= .5; vec4 col = vec4(0.); float blur = .1; float d1 = length(uv); float s1 = S(.45, .45-blur, d1); float d2 = length(uv-vec2(.1, -.2)*.7); float s2 = S(.5, .5-blur, d2); float browMask = sat(s1-s2); float colMask = remap01(.7, .8, y)*.75; colMask *= S(.6, .9, browMask); //眉毛光泽 colMask *= smile; //眉毛高光变化 vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); //眉毛光泽大小调整 //眉毛阴影 uv.y += .15-offs*.5; //阴影下移 -offs消除眉毛阴影上挑 blur += mix(.0, .1, smile); //阴影模糊 眉毛靠近阴影尖锐效果 d1 = length(uv); s1 = S(.45, .45-blur, d1); d2 = length(uv-vec2(.1, -.2)*.7); s2 = S(.5, .5-blur, d2); float shadowMask = sat(s1-s2); col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5); col = mix(col, browCol, S(.2, .4, browMask)); return col;}vec4 Eye(vec2 uv, float side, vec2 m, float smile) { //m保持眼睛跟跟随鼠标移动 uv -= .5; uv.x *= side; //side 取消眼睛的镜面对称 float d = length(uv); vec4 irisCol = vec4(.3, .5, 1., 1.); vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5); // 眼白梯度 col.a = S(.5, .48, d); // 眼罩 col.rgb *= 1. - S(.45, .5, d)*.5*sat(-uv.y-uv.x*side); // 眼影 *side是为了保持眼角眼影的镜面对称 d = length(uv-m*.4); // 虹膜 -m跟随鼠标移动 *.4削弱移动效果 col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); // 虹膜轮廓 irisCol.rgb *= 1. + S(.3, .05, d); // 虹膜光 float irisMask = S(.28, .25, d); col.rgb = mix(col.rgb, irisCol.rgb, irisMask); // d = length(uv-m*.45); // float pupilSize = mix(.4, .16, smile); //瞳孔大小 float pupilMask = S(pupilSize, pupilSize*.85, d); pupilMask *= irisMask; //确保瞳孔大小不会超过虹膜 col.rgb = mix(col.rgb, vec3(0.), pupilMask); // 瞳孔 float t = iTime*3.; //高光的移动 vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.)); offs *= .01*(1.-smile); uv += offs; float highlight = S(.1, .09, length(uv-vec2(-.15, .15))); highlight += S(.07, .05, length(uv+vec2(-.08, .08))); col.rgb = mix(col.rgb, vec3(1.), highlight); // 瞳孔高光 return col;}vec4 Mouth(vec2 uv, float smile) { uv -= .5; vec4 col = vec4(.5, .18, .05, 1.); uv.y *= 1.5; uv.y -= uv.x*uv.x*2.*smile; //嘴巴弧度上拉效果 uv.x *= mix(2.5, 1., smile); //嘴巴变小 float d = length(uv); col.a = S(.5, .48, d); vec2 tUv = uv; tUv.y += (abs(uv.x)*.5+.1)*(1.-smile); //牙齿效果 float td = length(tUv-vec2(0., .6)); vec3 toothCol = vec3(1.)*S(.6, .35, d); //牙齿 col.rgb = mix(col.rgb, toothCol, S(.4, .37, td)); td = length(uv+vec2(0., .5)); col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.5, .2, td)); return col;}vec4 Head(vec2 uv) { vec4 col = vec4(.9, .65, .1, 1.); float d = length(uv); col.a = S(.5, .49, d); float edgeShade = remap01(.35, .5, d); edgeShade *= edgeShade; //边缘根号函数的渐变效果 col.rgb *= 1.-edgeShade*.5; //渐变程度 col.rgb = mix(col.rgb, vec3(.6, .3, .1), S(.47, .48, d)); //外环 float highlight = S(.41, .405, d); highlight *= remap(.41, -.1, .75, 0., uv.y); //高光渐变 highlight *= S(.18, .19, length(uv-vec2(.21, .08))); //眼睛内陷 col.rgb = mix(col.rgb, vec3(1.), highlight); //高光及颜色 d = length(uv-vec2(.25, -.2)); //脸颊位置 float cheek = S(.2,.01, d)*.4; //脸颊颜色大小 cheek *= S(.17, .16, d); //脸颊整体形状 col.rgb = mix(col.rgb, vec3(1., .1, .1), cheek); return col;}vec4 Smiley(vec2 uv, vec2 m, float smile) { vec4 col = vec4(0.); if(length(uv)&lt;.5) { // 头内部像素 float side = sign(uv.x); //取消镜面眼睛 sign函数 uv.x = abs(uv.x); vec4 head = Head(uv); col = mix(col, head, head.a); if(length(uv-vec2(.2, .075))&lt;.175) { vec4 eye = Eye(within(uv, vec4(.03, -.1, .37, .25)), side, m, smile); //side col = mix(col, eye, eye.a); } if(length(uv-vec2(.0, -.15))&lt;.3) { vec4 mouth = Mouth(within(uv, vec4(-.3, -.43, .3, -.13)), smile); col = mix(col, mouth, mouth.a); } if(length(uv-vec2(.185, .325))&lt;.18) { vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .45)), smile); col = mix(col, brow, brow.a); } } return col;}void mainImage( out vec4 fragColor, in vec2 fragCoord ){ float t = iTime; vec2 uv = fragCoord.xy / iResolution.xy; uv -= .5; uv.x *= iResolution.x/iResolution.y; vec2 m = iMouse.xy / iResolution.xy; //鼠标动作 m -= .5; //鼠标初始位置 if(m.x&lt;-.49 &amp;&amp; m.y&lt;-.49) { // 让他没有使用鼠标的时候环顾四周 float s = sin(t*.5); float c = cos(t*.38); m = vec2(s, c)*.4; } if(length(m) &gt; .707) m *= 0.; // 修复全屏回来后的bug float d = dot(uv, uv); //整体形变；固定中心 uv -= m*sat(.23-d); float smile = sin(t*.5)*.5+.5; //嘴巴的变化 从0~1 fragColor = Smiley(uv, m, smile);} 2. 跳动的圆环 123456789101112131415161718192021222324252627282930313233343536373839404142434445#ifdef GL_ESprecision mediump float;#endifuniform float time;uniform vec2 mouse;uniform vec2 resolution;void main( void ) { vec2 position = ( gl_FragCoord.xy / resolution.xy ); vec2 posin = position; position = -vec2(1.25)+ 2.5*position; position.x *= resolution.x/resolution.y; position += 0.1*vec2(cos(time*1.),sin(time*3.)); vec3 color = vec3(0.0); vec2 center = vec2(0.,0.); vec2 dir = normalize(position-center); float dist = length(center - position); if(dist &lt; 0.5){ color = vec3(1,1.,1.); color.g = smoothstep(0.,1.,sin(time)); } color.g = smoothstep(0.1,0.9,posin.x); color.b = smoothstep(0.1,0.9,posin.y); if(dist &gt;0.6){ color = vec3(0.8,0.8,0.8); } gl_FragColor = vec4( color, 1.0 );} 3. GDUT2018 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#ifdef GL_ESprecision mediump float;#endif#extension GL_OES_standard_derivatives : enableuniform float time;uniform vec2 mouse;uniform vec2 resolution;const float PI = 3.141592653589793;const float PI2 = PI * 2.;#define s(x) clamp(x,0.,1.)#define _G sG()#define _L sL()#define _S sS()#define _C sC()#define _H sH()#define _O sO()#define _D sD()#define _U sU()#define _T sT()#define _2 s2()#define _1 s1()#define _8 s8()vec2 pos;float slice(float x,float start,float end){ return step(start,x)*step(x,end)*x;}float tslice(float x,float start,float end){ return 1.-step(step(start,x)*step(x,end)*x,0.);}float sqr(float x){ return -2.*(step(.5,fract(x*.5))-.5);}mat2 rotate2d(float a){ float c=cos(a); float s=sin(a); return mat2(c,-s,s,c);}float fill(float d,float r){return step(0.,r - d);}float lBox(vec2 p){return max(abs(p.x),abs(p.y));}float sBox(vec2 p,float r){return fill(lBox(p),r);}float lRect(vec2 p, vec2 size) { vec2 d = abs(p) - size; return min(max(d.x, d.y), 0.0) + length(max(d,0.0));}float sRect(vec2 p,vec2 size){return fill(lRect(p,size),0.);}void i(){pos.x-=2.;}void cr(float x){pos.x=x+2.;pos.y+=2.;}float sG(vec2 p){ return s(s(sBox(p,.6)-sBox(p,.4)) +sRect(p-vec2(.2,0) ,vec2(.2,.1)) -sRect(p-vec2(.5,.25),vec2(.1,.15)));}float sL(vec2 p){return s(sBox(p,.6)-sBox(p-.2,.6));}float sS(vec2 p){ return s(sBox(p,.6) -sRect(p-vec2( .1, .25),vec2(.5,.15)) -sRect(p-vec2(-.1,-.25),vec2(.5,.15)));}float sC(vec2 p){ return s(sBox(p,.6) -sRect(p-vec2(.1,0.),vec2(.5,.4)));}float sO(vec2 p){return s(sBox(p,.6)-sBox(p,.4));}float sH(vec2 p){ return s(sBox(p,.6) -sRect(p+vec2(0.,-.35),vec2(.4,.25)) -sRect(p+vec2(0.,+.35),vec2(.4,.25)));}float sD(vec2 p){return s(sBox(p,.6)-sBox(p,.4));}float sU(vec2 p){ return s(sBox(p,.6) -sRect(p+vec2(0.,-.35),vec2(.4,.75)));}float sT(vec2 p){ return s(sBox(p,.6) -sRect(p+vec2(-.5,+.15),vec2(.4,.5)) -sRect(p+vec2(0.5,+.15),vec2(.4,.5)));}float s1(vec2 p){return sRect(p-vec2(0,0),vec2(.1,.6));}float s2(vec2 p){return sS(vec2(-p.x,p.y));}float s8(vec2 p){ return s(sBox(p,.6) -sRect(p-vec2( .0, .25),vec2(.4,.15)) -sRect(p-vec2(-.0,-.25),vec2(.4,.15)));}float sG(){i();return sG(pos);}float sD(){i();return sD(pos);}float sU(){i();return sU(pos);}float sT(){i();return sT(pos);}float sL(){i();return sL(pos);}float sS(){i();return sS(pos);}float sC(){i();return sC(pos);}float sO(){i();return sO(pos);}float sH(){i();return sH(pos);}float s2(){i();return s2(pos);}float s1(){i();return s1(pos);}float s8(){i();return s8(pos);}float layerGDUTSCHOOL2018(vec2 p){ p.x+=1.; p.y-=.4; p*=6.; p.x-=1.; pos=p; pos.x+=2.; float l; l+=_G+_D+_U+_T;cr(p.x); l+=_S+_C+_H+_O+_O+_L;cr(p.x); l+=_2+_O+_1+_8;cr(p.x); return s(l);}vec2 transitionZoomIn( vec2 p,float t){ return p*clamp(t,0.,1.);}vec2 transitionZoomOut( vec2 p,float t){ return p*clamp(1.-t,0.,1.);}vec2 effectPixelate( vec2 p,float t){ return floor(p*pow(2.,t*5.))/pow(2.,t*5.);}vec2 effectRotateGlicth(vec2 p,float t){ p*=rotate2d(t*5.); p.y+=sqr(p.x*10.)*sin(t)*.01; p*=rotate2d(-t*5.); return p;}vec2 effectProlongPolar(vec2 p,float t){ float a = mod((atan(p.y,p.x) + PI2 + clamp(t*PI*.5,0.,PI2)),PI2); float r = length(p); r=min(r,t/5.); return vec2(r*cos(a),r*sin(a));} vec2 effectProlongX(vec2 p,float t){ p.x=sign(p.x)*min(abs(p.x),t/5.); return p;} float maskRadar(vec2 p,float t){ float a = mod((atan(p.y,p.x) + PI2 - t),PI2); return 1.-a/PI2;} vec3 layerFakeChromaticAberration(vec2 p,float t){ float l=layerGDUTSCHOOL2018(p); float purple=layerGDUTSCHOOL2018(p+vec2(.005+.005*sin(p.y*30.+t*10.),0.)); float green =layerGDUTSCHOOL2018(p-vec2(.005+.005*cos(p.y*30.+t*10.),0.)); return vec3(.8,.5,1.)*purple+vec3(.5,1.,.5)*green+vec3(l); }vec3 scene1(vec2 p,float t){ p=transitionZoomIn(p,t); return layerFakeChromaticAberration(p,t);} vec3 scene2(vec2 p,float t){ vec2 o = transitionZoomOut(p,t); return layerFakeChromaticAberration(o,t)*(1.-t)+layerFakeChromaticAberration(p,t);} vec3 scene3(vec2 p,float t){ p=effectRotateGlicth(p,t); return layerFakeChromaticAberration(p,t);} vec3 scene4(vec2 p,float t){ p=effectPixelate(p,fract(t)); return layerFakeChromaticAberration(p,t);} vec3 scene5(vec2 p,float t){ p=effectRotateGlicth(p,t); p=effectProlongX(p,t); p=effectProlongPolar(p,t); return layerFakeChromaticAberration(p,t);} vec3 scene6(vec2 p,float t){ return layerFakeChromaticAberration(p,t)*maskRadar(p,t);} void main(void){ vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y); vec3 color = vec3(0.,0.,0.); float t = mod(time,16.); float tc = 0.; float ti; ti=1.;color+= tslice(t,tc,tc+ti) * scene1(p,t-tc);tc+=ti; ti=1.;color+= tslice(t,tc,tc+ti) * scene2(p,t-tc);tc+=ti; ti=1.;color+= tslice(t,tc,tc+ti) * scene3(p,t-tc);tc+=ti; ti=1.;color+= tslice(t,tc,tc+ti) * scene4(p,t-tc);tc+=ti; ti=6.;color+= tslice(t,tc,tc+ti) * scene5(p,t-tc);tc+=ti; ti=6.;color+= tslice(t,tc,tc+ti) * scene6(p,t-tc);tc+=ti; gl_FragColor = vec4(color, 1.0);} 4. 圆环 1234567891011121314151617181920#ifdef GL_ESprecision mediump float;#endifuniform float time;uniform vec2 mouse;uniform vec2 resolution;void main(){ float t; t = time * 1.0; vec2 r = resolution, o = gl_FragCoord.xy - r/2.; o = vec2(length(o) / r.y - .3, atan(o.y,o.x)); vec4 s = 0.07*cos(1.5*vec4(0,1,2,3) + t + o.y + cos(o.y) * cos(t)), e = s.yzwx, f = max(o.x-s,e-o.x); gl_FragColor = dot(clamp(f*r.y,0.,1.), 80.*(s-e)) * (s-.1) + f;}","link":"/2018/05/19/GLSL-ex/"},{"title":"利用Android Studio开发2048小游戏","text":"利用Android Studio开发一个2048小游戏。 1. 界面设计1234567891011121314151617181920212223242526272829303132333435&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" &gt; &lt;com.zanple.game2048.view.Game2048Layout android:id=\"@+id/id_game2048\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\" android:layout_centerInParent=\"true\" android:background=\"#ffffff\" android:padding=\"10dp\" &gt; &lt;/com.zanple.game2048.view.Game2048Layout&gt; &lt;LinearLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_above=\"@id/id_game2048\" android:layout_centerHorizontal=\"true\" android:layout_marginBottom=\"20dp\" android:background=\"#EEE4DA\" android:orientation=\"horizontal\" &gt; &lt;TextView android:id=\"@+id/id_score\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:padding=\"4dp\" android:text=\"Score: 0\" android:textColor=\"#EA7821\" android:textSize=\"30sp\" android:textStyle=\"bold\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 2. 2048的游戏面板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499package com.zanple.game2048.view;import java.util.ArrayList;import java.util.List;import java.util.Random;import android.content.Context;import android.util.AttributeSet;import android.util.Log;import android.util.TypedValue;import android.view.GestureDetector;import android.view.MotionEvent;import android.widget.RelativeLayout;/** * 2048的游戏面板，加入布局文件即可开始游戏 * * */public class Game2048Layout extends RelativeLayout{ /** * 设置Item的数量n*n；默认为4 */ private int mColumn = 5; /** * 存放所有的Item */ private Game2048Item[] mGame2048Items; /** * Item横向与纵向的边距 */ private int mMargin = 10; /** * 面板的padding */ private int mPadding; /** * 检测用户滑动的手势 */ private GestureDetector mGestureDetector; // 用于确认是否需要生成一个新的值 private boolean isMergeHappen = true; private boolean isMoveHappen = true; /** * 记录分数 */ private int mScore; public interface OnGame2048Listener { void onScoreChange(int score); void onGameOver(); } private OnGame2048Listener mGame2048Listener; public void setOnGame2048Listener(OnGame2048Listener mGame2048Listener) { this.mGame2048Listener = mGame2048Listener; } /** * 运动方向的枚举 * * */ private enum ACTION { LEFT, RIGHT, UP, DOWM } public Game2048Layout(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); mMargin = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, mMargin, getResources().getDisplayMetrics()); // 设置Layout的内边距，四边一致，设置为四内边距中的最小值 mPadding = min(getPaddingLeft(), getPaddingTop(), getPaddingRight(), getPaddingBottom()); mGestureDetector = new GestureDetector(context , new MyGestureDetector()); } /** * 根据用户运动，整体进行移动合并值等 */ private void action(ACTION action) { // 行|列 for (int i = 0; i &lt; mColumn; i++) { List&lt;Game2048Item&gt; row = new ArrayList&lt;Game2048Item&gt;(); // 行|列 //记录不为0的数字 for (int j = 0; j &lt; mColumn; j++) { // 得到下标 int index = getIndexByAction(action, i, j); Game2048Item item = mGame2048Items[index]; // 记录不为0的数字 if (item.getNumber() != 0) { row.add(item); } } //判断是否发生移动 for (int j = 0; j &lt; mColumn &amp;&amp; j &lt; row.size(); j++) { int index = getIndexByAction(action, i, j); Game2048Item item = mGame2048Items[index]; if (item.getNumber() != row.get(j).getNumber()) { isMoveHappen = true; } } // 合并相同的 mergeItem(row); // 设置合并后的值 for (int j = 0; j &lt; mColumn; j++) { int index = getIndexByAction(action, i, j); if (row.size() &gt; j) { mGame2048Items[index].setNumber(row.get(j).getNumber()); } else { mGame2048Items[index].setNumber(0); } } } //生成数字 generateNum(); } /** * 根据Action和i,j得到下标 * * @param action * @param i * @param j * @return */ private int getIndexByAction(ACTION action, int i, int j) { int index = -1; switch (action) { case LEFT: index = i * mColumn + j; break; case RIGHT: index = i * mColumn + mColumn - j - 1; break; case UP: index = i + j * mColumn; break; case DOWM: index = i + (mColumn - 1 - j) * mColumn; break; } return index; } /** * 合并相同的Item * * @param row */ private void mergeItem(List&lt;Game2048Item&gt; row) { if (row.size() &lt; 2) return; for (int j = 0; j &lt; row.size() - 1; j++) { Game2048Item item1 = row.get(j); Game2048Item item2 = row.get(j + 1); if (item1.getNumber() == item2.getNumber()) { isMergeHappen = true; int val = item1.getNumber() + item2.getNumber(); item1.setNumber(val); // 加分 mScore += val; if (mGame2048Listener != null) { mGame2048Listener.onScoreChange(mScore); } // 向前移动 for (int k = j + 1; k &lt; row.size() - 1; k++) { row.get(k).setNumber(row.get(k + 1).getNumber()); } row.get(row.size() - 1).setNumber(0); return; } } } /** * 得到多值中的最小值 * * @param params * @return */ private int min(int... params) { int min = params[0]; for (int param : params) { if (min &gt; param) { min = param; } } return min; } @Override public boolean onTouchEvent(MotionEvent event) { mGestureDetector.onTouchEvent(event); return true; } public Game2048Layout(Context context) { this(context, null); } public Game2048Layout(Context context, AttributeSet attrs) { this(context, attrs, 0); } private boolean once; /** * 测量Layout的宽和高，以及设置Item的宽和高，这里忽略wrap_content 以宽、高之中的最小值绘制正方形 */ @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); // 获得正方形的边长 int length = Math.min(getMeasuredHeight(), getMeasuredWidth()); // 获得Item的宽度 int childWidth = (length - mPadding * 2 - mMargin * (mColumn - 1)) / mColumn; if (!once) { if (mGame2048Items == null) { mGame2048Items = new Game2048Item[mColumn * mColumn]; } // 放置Item for (int i = 0; i &lt; mGame2048Items.length; i++) { Game2048Item item = new Game2048Item(getContext()); mGame2048Items[i] = item; item.setId(i + 1); LayoutParams lp = new LayoutParams(childWidth, childWidth); // 设置横向边距,不是最后一列 if ((i + 1) % mColumn != 0) { lp.rightMargin = mMargin; } // 如果不是第一列 if (i % mColumn != 0) { lp.addRule(RelativeLayout.RIGHT_OF,// mGame2048Items[i - 1].getId()); } // 如果不是第一行，//设置纵向边距，非最后一行 if ((i + 1) &gt; mColumn) { lp.topMargin = mMargin; lp.addRule(RelativeLayout.BELOW,// mGame2048Items[i - mColumn].getId()); } addView(item, lp); } generateNum(); } once = true; setMeasuredDimension(length, length); } /** * 是否填满数字 * * @return */ private boolean isFull() { // 检测是否所有位置都有数字 for (int i = 0; i &lt; mGame2048Items.length; i++) { if (mGame2048Items[i].getNumber() == 0) { return false; } } return true; } /** * 检测当前所有的位置都有数字，且相邻的没有相同的数字 * * @return */ private boolean checkOver() { // 检测是否所有位置都有数字 if (!isFull()) { return false; } for (int i = 0; i &lt; mColumn; i++) { for (int j = 0; j &lt; mColumn; j++) { int index = i * mColumn + j; // 当前的Item Game2048Item item = mGame2048Items[index]; // 右边 if ((index + 1) % mColumn != 0) { Log.e(\"TAG\", \"RIGHT\"); // 右边的Item Game2048Item itemRight = mGame2048Items[index + 1]; if (item.getNumber() == itemRight.getNumber()) return false; } // 下边 if ((index + mColumn) &lt; mColumn * mColumn) { Log.e(\"TAG\", \"DOWN\"); Game2048Item itemBottom = mGame2048Items[index + mColumn]; if (item.getNumber() == itemBottom.getNumber()) return false; } // 左边 if (index % mColumn != 0) { Log.e(\"TAG\", \"LEFT\"); Game2048Item itemLeft = mGame2048Items[index - 1]; if (itemLeft.getNumber() == item.getNumber()) return false; } // 上边 if (index + 1 &gt; mColumn) { Log.e(\"TAG\", \"UP\"); Game2048Item itemTop = mGame2048Items[index - mColumn]; if (item.getNumber() == itemTop.getNumber()) return false; } } } return true; } /** * 产生一个数字 */ public void generateNum() { if (checkOver()) { Log.e(\"TAG\", \"GAME OVER\"); if (mGame2048Listener != null) { mGame2048Listener.onGameOver(); } return; } if (!isFull()) { if (isMoveHappen || isMergeHappen) { Random random = new Random(); int next = random.nextInt(16); Game2048Item item = mGame2048Items[next]; while (item.getNumber() != 0) { next = random.nextInt(16); item = mGame2048Items[next]; } item.setNumber(Math.random() &gt; 0.75 ? 4 : 2); isMergeHappen = isMoveHappen = false; } } } /** * 重新开始游戏 */ public void restart() { for (Game2048Item item : mGame2048Items) { item.setNumber(0); } mScore = 0; if (mGame2048Listener != null) { mGame2048Listener.onScoreChange(mScore); } isMoveHappen = isMergeHappen = true; generateNum(); } class MyGestureDetector extends GestureDetector.SimpleOnGestureListener { final int FLING_MIN_DISTANCE = 50; @Override public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) { float x = e2.getX() - e1.getX(); float y = e2.getY() - e1.getY(); if (x &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; Math.abs(velocityY)) { action(ACTION.RIGHT); // Toast.makeText(getContext(), \"toRight\", // Toast.LENGTH_SHORT).show(); } else if (x &lt; -FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &gt; Math.abs(velocityY)) { action(ACTION.LEFT); // Toast.makeText(getContext(), \"toLeft\", // Toast.LENGTH_SHORT).show(); } else if (y &gt; FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &lt; Math.abs(velocityY)) { action(ACTION.DOWM); // Toast.makeText(getContext(), \"toDown\", // Toast.LENGTH_SHORT).show(); } else if (y &lt; -FLING_MIN_DISTANCE &amp;&amp; Math.abs(velocityX) &lt; Math.abs(velocityY)) { action(ACTION.UP); // Toast.makeText(getContext(), \"toUp\", // Toast.LENGTH_SHORT).show(); } return true; } }} 3. 2048的每个Item123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137package com.zanple.game2048.view;import android.content.Context;import android.graphics.Canvas;import android.graphics.Color;import android.graphics.Paint;import android.graphics.Paint.Style;import android.graphics.Rect;import android.util.AttributeSet;import android.util.Log;import android.view.View;/** * 2048的每个Item * * */public class Game2048Item extends View{ /** * 该View上的数字 */ private int mNumber; private String mNumberVal; private Paint mPaint; /** * 绘制文字的区域 */ private Rect mBound; public Game2048Item(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); mPaint = new Paint(); } public Game2048Item(Context context) { this(context, null); } public Game2048Item(Context context, AttributeSet attrs) { this(context, attrs, 0); } public void setNumber(int number) { mNumber = number; mNumberVal = mNumber + \"\"; mPaint.setTextSize(30.0f); mBound = new Rect(); mPaint.getTextBounds(mNumberVal, 0, mNumberVal.length(), mBound); invalidate(); } public int getNumber() { return mNumber; } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); String mBgColor = \"\"; switch (mNumber) { case 0: mBgColor = \"#CCC0B3\"; break; case 2: mBgColor = \"#EEE4DA\"; break; case 4: mBgColor = \"#EDE0C8\"; break; case 8: mBgColor = \"#F2B179\";// #F2B179 break; case 16: mBgColor = \"#F49563\"; break; case 32: mBgColor = \"#F5794D\"; break; case 64: mBgColor = \"#F55D37\"; break; case 128: mBgColor = \"#EEE863\"; break; case 256: mBgColor = \"#EDB04D\"; break; case 512: mBgColor = \"#ECB04D\"; break; case 1024: mBgColor = \"#EB9437\"; break; case 2048: mBgColor = \"#EA7821\"; break; default: mBgColor = \"#EA7821\"; break; } mPaint.setColor(Color.parseColor(mBgColor)); mPaint.setStyle(Style.FILL); canvas.drawRect(0, 0, getWidth(), getHeight(), mPaint); if (mNumber != 0) drawText(canvas); } /** * 绘制文字 * * @param canvas */ private void drawText(Canvas canvas) { mPaint.setColor(Color.BLACK); float x = (getWidth() - mBound.width()) / 2; float y = getHeight() / 2 + mBound.height() / 2; canvas.drawText(mNumberVal, x, y, mPaint); }} 4. 主程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.zanple.game2048.view;import android.app.Activity;import android.app.AlertDialog;import android.content.DialogInterface;import android.content.DialogInterface.OnClickListener;import android.os.Bundle;import android.widget.TextView;import com.zanple.game2048.R;import com.zanple.game2048.view.Game2048Layout;import com.zanple.game2048.view.Game2048Layout.OnGame2048Listener;public class MainActivity extends Activity implements Game2048Layout.OnGame2048Listener{ private Game2048Layout mGame2048Layout; private TextView mScore; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mScore = (TextView) findViewById(R.id.id_score); mGame2048Layout = (Game2048Layout) findViewById(R.id.id_game2048); mGame2048Layout.setOnGame2048Listener(this); } @Override public void onScoreChange(int score) { mScore.setText(\"SCORE: \" + score); } @Override public void onGameOver() { new AlertDialog.Builder(this).setTitle(\"GAME OVER\") .setMessage(\"YOU HAVE GOT \" + mScore.getText()) .setPositiveButton(\"RESTART\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { mGame2048Layout.restart(); } }).setNegativeButton(\"EXIT\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { finish(); } }).show(); }}","link":"/2018/07/12/android-2048-game/"},{"title":"利用Android Studio开发简易计算器","text":"利用Android Studio开发一个简易的计算器，界面使用表格布局。 1. 界面布局 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:orientation=\"horizontal\" android:layout_weight=\"2\" &gt; &lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:id=\"@+id/et_input\" android:textSize=\"40sp\" /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"match_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:orientation=\"horizontal\" android:weightSum=\"4\" &gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"C\" android:textSize=\"40sp\" android:id=\"@+id/btn_clear\" android:layout_weight=\"1\" android:background=\"#ffffff\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"/\" android:textSize=\"40sp\" android:id=\"@+id/btn_divide\" android:layout_weight=\"1\" android:background=\"#ffffff\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"X\" android:textSize=\"40sp\" android:id=\"@+id/btn_multiply\" android:layout_weight=\"1\" android:background=\"#ffffff\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"T\" android:textSize=\"40sp\" android:id=\"@+id/btn_del\" android:layout_weight=\"1\" android:background=\"#ffffff\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"0dp\" android:layout_weight=\"1\" android:gravity=\"center\" android:weightSum=\"4\" &gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"7\" android:textSize=\"30sp\" android:id=\"@+id/btn_7\" android:layout_weight=\"1\" android:background=\"#ffffcc\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"8\" android:textSize=\"30sp\" android:id=\"@+id/btn_8\" android:layout_weight=\"1\" android:background=\"#ffffcc\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"9\" android:textSize=\"30sp\" android:id=\"@+id/btn_9\" android:layout_weight=\"1\" android:background=\"#ffffcc\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"-\" android:textSize=\"50sp\" android:id=\"@+id/btn_minus\" android:layout_weight=\"1\" android:background=\"#ffffff\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"0dp\" android:orientation=\"horizontal\" android:layout_weight=\"1\" android:weightSum=\"4\" &gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"4\" android:textSize=\"30sp\" android:id=\"@+id/btn_4\" android:layout_weight=\"1\" android:background=\"#ffffcc\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"5\" android:textSize=\"30sp\" android:id=\"@+id/btn_5\" android:layout_weight=\"1\" android:background=\"#ffffcc\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"6\" android:textSize=\"30sp\" android:id=\"@+id/btn_6\" android:layout_weight=\"1\" android:background=\"#ffffcc\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"+\" android:textSize=\"40sp\" android:id=\"@+id/btn_plus\" android:layout_weight=\"1\" android:background=\"#ffffff\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"0dp\" android:orientation=\"horizontal\" android:layout_weight=\"1\" android:weightSum=\"4\" &gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"1\" android:textSize=\"30sp\" android:id=\"@+id/btn_1\" android:layout_weight=\"1\" android:background=\"#FFFFCC\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"2\" android:textSize=\"30sp\" android:id=\"@+id/btn_2\" android:layout_weight=\"1\" android:background=\"#FFFFCC\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"3\" android:textSize=\"30sp\" android:id=\"@+id/btn_3\" android:layout_weight=\"1\" android:background=\"#FFFFCC\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\".\" android:textSize=\"40sp\" android:id=\"@+id/btn_point\" android:layout_weight=\"1\" android:background=\"#FFFFFF\"/&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"0dp\" android:orientation=\"horizontal\" android:layout_weight=\"1\" android:weightSum=\"4\" &gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"（\" android:textSize=\"30sp\" android:id=\"@+id/btn_left\" android:layout_weight=\"1\" android:background=\"#FFFFCC\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"0\" android:textSize=\"30sp\" android:id=\"@+id/btn_0\" android:background=\"#FFFFCC\" android:layout_weight=\"1\" /&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\")\" android:textSize=\"30sp\" android:id=\"@+id/btn_right\" android:layout_weight=\"1\" android:background=\"#FFFFCC\"/&gt; &lt;Button android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:text=\"=\" android:textSize=\"30sp\" android:id=\"@+id/btn_equal\" android:background=\"#99CCFF\" android:layout_weight=\"1\" /&gt; &lt;/LinearLayout&gt;&lt;/LinearLayout&gt; 2. 程序设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250package com.zanpl.co2_4;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;import java.util.Arrays;public class MainActivity extends AppCompatActivity implements View.OnClickListener { Button btn_0; Button btn_1; Button btn_2; Button btn_3; Button btn_4; Button btn_5; Button btn_6; Button btn_7; Button btn_8; Button btn_9; Button btn_point; //小数点 Button btn_clear; //清除 Button btn_del; //删除 Button btn_plus; Button btn_minus; Button btn_multiply; Button btn_divide; Button btn_equal; Button btn_left; Button btn_right; private TextView et_input; private StringBuilder pending = new StringBuilder(); private void initView() { btn_0 = (Button) findViewById(R.id.btn_0); btn_1 = (Button) findViewById(R.id.btn_1); btn_2 = (Button) findViewById(R.id.btn_2); btn_3 = (Button) findViewById(R.id.btn_3); btn_4 = (Button) findViewById(R.id.btn_4); btn_5 = (Button) findViewById(R.id.btn_5); btn_6 = (Button) findViewById(R.id.btn_6); btn_7 = (Button) findViewById(R.id.btn_7); btn_8 = (Button) findViewById(R.id.btn_8); btn_9 = (Button) findViewById(R.id.btn_9); btn_point = (Button) findViewById(R.id.btn_point); btn_clear = (Button) findViewById(R.id.btn_clear); btn_del = (Button) findViewById(R.id.btn_del); btn_plus = (Button) findViewById(R.id.btn_plus); btn_minus = (Button) findViewById(R.id.btn_minus); btn_multiply = (Button) findViewById(R.id.btn_multiply); btn_divide = (Button) findViewById(R.id.btn_divide); btn_equal = (Button) findViewById(R.id.btn_equal); et_input = (TextView) findViewById(R.id.et_input); btn_left = (Button) findViewById(R.id.btn_left); btn_right = (Button) findViewById(R.id.btn_right); btn_0.setOnClickListener(this); btn_1.setOnClickListener(this); btn_2.setOnClickListener(this); btn_3.setOnClickListener(this); btn_4.setOnClickListener(this); btn_5.setOnClickListener(this); btn_6.setOnClickListener(this); btn_7.setOnClickListener(this); btn_8.setOnClickListener(this); btn_9.setOnClickListener(this); btn_point.setOnClickListener(this); btn_plus.setOnClickListener(this); btn_equal.setOnClickListener(this); btn_minus.setOnClickListener(this); btn_multiply.setOnClickListener(this); btn_del.setOnClickListener(this); btn_divide.setOnClickListener(this); btn_clear.setOnClickListener(this); btn_divide.setOnClickListener(this); btn_left.setOnClickListener(this); btn_right.setOnClickListener(this); } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); } public void onClick(View v) { int last = 0; if(pending.length()!=0) { last = pending.codePointAt(pending.length()-1); } switch (v.getId()) { case R.id.btn_0: pending = pending.append(\"0\"); et_input.setText(pending); break; case R.id.btn_1: pending = pending.append(\"1\"); et_input.setText(pending); break; case R.id.btn_2: pending = pending.append(\"2\"); et_input.setText(pending); break; case R.id.btn_3: pending = pending.append(\"3\"); et_input.setText(pending); break; case R.id.btn_4: pending = pending.append(\"4\"); et_input.setText(pending); break; case R.id.btn_5: pending = pending.append(\"5\"); et_input.setText(pending); break; case R.id.btn_6: pending = pending.append(\"6\"); et_input.setText(pending); break; case R.id.btn_7: pending = pending.append(\"7\"); et_input.setText(pending); break; case R.id.btn_8: pending = pending.append(\"8\"); et_input.setText(pending); break; case R.id.btn_9: pending = pending.append(\"9\"); et_input.setText(pending); break; case R.id.btn_plus: //if (last &gt;= '0' &amp;&amp; last &lt;= '9' ) { pending = pending.append(\"+\"); // } et_input.setText(pending); break; case R.id.btn_minus: //if (last &gt;= '0' &amp;&amp; last &lt;= '9') { pending = pending.append(\"-\"); // } et_input.setText(pending); break; case R.id.btn_multiply: // if (last &gt;= '0' &amp;&amp; last &lt;= '9' ) { pending = pending.append(\"*\"); // } et_input.setText(pending); break; case R.id.btn_divide: // if (last &gt;= '0' &amp;&amp; last &lt;= '9' ) { pending = pending.append(\"/\"); // } et_input.setText(pending); break; case R.id.btn_point: if (judje1()) { pending = pending.append(\".\"); et_input.setText(pending); } break; case R.id.btn_right:// )右括号 if((last&gt;='0' &amp;&amp;last&lt;='9'||last==')')&amp;&amp;judje2()==1) { pending = pending.append(\")\"); et_input.setText(pending); } break; case R.id.btn_left:// （左括号 if((last!='(')||(last&lt;='0' &amp;&amp;last&gt;='9')){ pending = pending.append(\"(\"); et_input.setText(pending); } break; case R.id.btn_del: //删除 if (pending.length() != 0) { pending = pending.delete(pending.length() - 1, pending.length()); et_input.setText(pending); } break; case R.id.btn_clear: //清空 pending = pending.delete(0, pending.length()); et_input.setText(pending); break; case R.id.btn_equal: // =等于 if ((pending.length() &gt; 1)) { InfixInToDuffix inf = new InfixInToDuffix(); String jieguo; try { String a = inf.toSuffix(pending); jieguo = inf.dealEquation(a); } catch (Exception ex) { jieguo = \"出错\"; } et_input.setText(pending + \"=\" + jieguo); pending = pending.delete(0, pending.length()); if (Character.isDigit(jieguo.charAt(0))) { pending = pending.append(jieguo); } } break; default: break; } } private boolean judje1() { String a = \"+-*/.\"; int[] b = new int[a.length()]; int max; for (int i = 0; i &lt; a.length(); i++) { String c = \"\" + a.charAt(i); b[i] = pending.lastIndexOf(c); } Arrays.sort(b); if (b[a.length() - 1] == -1) { max = 0; } else { max = b[a.length() - 1]; } if (pending.indexOf(\".\", max) == -1) { return true; } else { return false; } } private int judje2(){ int a=0,b=0; for(int i = 0 ; i &lt; pending.length() ;i++){ if(pending.charAt(i)=='(' ) { a++; } if(pending.charAt(i)==')' ) { b++; } } if(a == b) return 0; if(a &gt; b) return 1; return 2; }}","link":"/2018/07/16/android-calculator/"},{"title":"平面设计汇总-logo类（持续更新）","text":"记录一下一些平面设计logo吧~","link":"/2018/12/27/design-logo/"},{"title":"平面设计汇总-其他（持续更新）","text":"记录一下一些其他的平面设计作品吧~","link":"/2018/12/27/design-others/"},{"title":"平面设计汇总-海报类（持续更新）","text":"记录一下一些平面设计的海报吧~","link":"/2018/12/27/design-poster/"},{"title":"数媒自习室-基于ASP的动态网页开发","text":"一个比较完整的课设，独立完成了整个网站的UI设计、前端和部分后端功能的开发。 数字媒体系的学习内容覆盖广，种类多。在平时的学习中需要学习各种教程。所以想到开发一个网站将数字媒体系的常见的教程进行整合，方便数字媒体系的学生进行学习。（部分内容来自doyoudo） 1. 架构1.1 网页架构 数媒自习室分为六个主要模块：首页（展示网站的概括内容）、教程（提供各类教程）、学习路径（提供不同软件分类的完整学习路径）、资源导航（提供常用内容的相关资源）、关于我们、登录/注册（提供网站的登录与注册和后台登录的功能）。 1.2 技术架构 网站整体使用Html5+CSS，通过JavaScript和jQuery实现网站的动态效果及功能，使用ASP开发后端功能，通过ADO访问Access数据库并插入语句、根据数据库动态修改网页内容、使用conn.execute方法操纵数据库。 1.3 资源架构 使用global.css与frame.css对网页的布局进行控制，jquery-3.4.1.min.js提供网站的部分动态功能，通过conn.asp与chkloginly.asp对数据库comment.mdb中的语句进行添加与删除。 2. UI设计及部分界面展示 3. 技术实现网页前端静态内容比较简单，html和css就不放上来了。下面写一下动态内容和数据库的实现吧。 3.1 框架3.1.1 返回顶部悬浮样式变化当鼠标经过时的mouseover事件运行函数，通过jQuery中的attr()方法对&lt;img&gt;图片标签中的源地址进行修改从而实现返回顶部图片的更换。 123456789101112var toggle = true; $(function(){ $(\"#ReturnTop\").mouseover(function() { if (toggle) { $(\".returntop img\").attr(\"src\", \"svg/returntop2.svg\"); toggle = false; } else { $(\".returntop img\").attr(\"src\", \"svg/returntop.svg\"); toggle = true; } }) }); 3.2 主页3.2.1 主页轮播图 用图片做链接，把img元素嵌入到a元素中，使用定时函数实现当图片轮显框没有单击时也能自动循环显示，当单击按钮时，右下角的方形图标颜色改变。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394 window.onload = function(){ function $(param){ if(arguments[1] == true){ return document.querySelectorAll(param); }else{ return document.querySelector(param); } } var $box = $(\".box\"); var $box1 = $(\".box-1 ul li\",true); var $box2 = $(\".box-2 ul\"); var $box3 = $(\".box-3\"); var $length = $box1.length; var str = \"\"; for(var i =0;i&lt;$length;i++){ if(i==0){ str +=\"&lt;li class='on'&gt;\"+(i+1)+\"&lt;/li&gt;\"; }else{ str += \"&lt;li&gt;\"+(i+1)+\"&lt;/li&gt;\"; } } $box2.innerHTML = str; var current = 0; var timer; timer = setInterval(go,1000); function go(){ for(var j =0;j&lt;$length;j++){ $box1[j].style.display = \"none\"; $box2.children[j].className = \"\"; } if($length == current){ current = 0; } $box1[current].style.display = \"block\"; $box2.children[current].className = \"on\"; current++; } for(var k=0;k&lt;$length;k++){ $box1[k].onmouseover = function(){ clearInterval(timer); } $box1[k].onmouseout = function(){ timer = setInterval(go,2000); } } for(var p=0;p&lt;$box3.children.length;p++){ $box3.children[p].onmouseover = function(){ clearInterval(timer); }; $box3.children[p].onmouseout = function(){ timer = setInterval(go,2000); } } for(var u =0;u&lt;$length;u++){ $box2.children[u].index = u; $box2.children[u].onmouseover = function(){ clearInterval(timer); for(var j=0;j&lt;$length;j++){ $box1[j].style.display = \"none\"; $box2.children[j].className = \"\"; } this.className = \"on\"; $box1[this.index].style.display = \"block\"; current = this.index +1; } $box2.children[u].onmouseout = function(){ timer = setInterval(go,2000); } } $box3.children[0].onclick = function(){ back(); } $box3.children[1].onclick = function(){ go(); } function back(){ for(var j =0;j&lt;$length;j++){ $box1[j].style.display = \"none\"; $box2.children[j].className = \"\"; } if(current == 0){ current = $length; } $box1[current-1].style.display = \"block\"; $box2.children[current-1].className = \"on\"; current--; }} 3.3 教程页面3.3.1 lightbox展示图片 12345678910111213141516function _initialize() function _start(objClicked,jQueryMatchedObj)function _set_interface()function _set_image_to_view()function _resize_container_image_box(intImageWidth,intImageHeight)function _show_image()function _show_image_data()function _set_navigation()function _enable_keyboard_navigation()function _disable_keyboard_navigation()function _keyboard_action(objEvent)function _preload_neighbor_images()function _finish()function ___getPageSize()function ___getPageScroll()function ___pause(ms) 3.4 学习路径页面3.4.1 视频嵌入 使用Bilibili提供的&lt;iframe&gt;嵌入教程视频。 1&lt;iframe id=\"videoplay\"; src=\"https://player.bilibili.com/player.html?aid=41848203&amp;cid=73474961&amp;page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"width: 830px; height: 580px; max-width: 100%\"&gt; &lt;/iframe&gt; 3.4.2 实时聊天 用Application(“bbs”)来保存所有用户的发言并显示，当保存的发言达到15跳后使用removeall清楚Application对象。Application对象针对所有用户，可以被多个用户共享。 1234567891011121314151617&lt;% Dim str 'str中存储留言时间、昵称、内容等信息 if request.Form(&quot;LiuYan&quot;)&lt;&gt;&quot;&quot; then str=Time()&amp;&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; str=str&amp;request.Form(&quot;LiuYan&quot;)&amp;&quot;&lt;br&gt;&quot; Application.Lock Application(&quot;bbs&quot;)=str&amp;Application(&quot;bbs&quot;) Application(&quot;visAll&quot;)=Application(&quot;visAll&quot;)+1 Application.Unlock str=Null '将已存储到Application变量中的留言清除 end if response.write Application(&quot;bbs&quot;) if Application(&quot;visAll&quot;)=18 then application.contents.removeall response.Write(&quot;实时聊天内容已满，即将清除聊天窗口内容……&quot;) end if %&gt; 3.4.3 用户评论 通过ADO访问Access数据库并插入语句、根据数据库动态修改网页内容、使用conn.execute方法操纵数据库。 3.4.3.1 Insert添加记录的实现1234567891011121314&lt;!--#include file=&quot;conn.asp&quot;--&gt;&lt;% title=request.Form(&quot;title&quot;)author=request.Form(&quot;author&quot;)email=request.Form(&quot;email&quot;)content=request.Form(&quot;content&quot;)Set rs=Server.CreateObject(&quot;ADODB.Recordset&quot;) rs.open &quot;select * from lyb&quot;,conn,1,3 '创建记录集，并设置记录集可写rs.addnew '添加一条新记录，如果漏掉，将会改写原来的记录rs(&quot;author&quot;)=authorrs(&quot;content&quot;)=contentrs(&quot;date&quot;)=date()rs.update '更新记录集，将记录写入数据表中Response.Redirect(&quot;xxljplayer.asp&quot;) %&gt; 3.4.3.2 用户评论的分页及评论展示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!--#include file=&quot;conn.asp&quot;--&gt; &lt;% pageNo= Request(&quot;pageNo&quot;) if not IsNumeric(pageNo) or pageNo=&quot;&quot; Then '如果pageNo为空或非法则显示第一页 pageNo=1 Else pageNo=cInt(pageNo) 'pageNo一定要转换为数值型，因为要进行数值比较 End if Set rs=Server.CreateObject(&quot;ADODB.Recordset&quot;) rs.open &quot;select * from lyb order by id desc&quot;,conn,1 rs.pagesize=5 '设置每页显示5条记录 pageS=rs.pagesize '用pageS保存rs.pagesize rs.AbsolutePage=pageNo '从第pageNo页开始显示 %&gt; &lt;% do while not rs.eof and pageS&gt;0 %&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;mainimg&quot;&gt;&lt;img src=&quot;../img/Photo.png&quot; width=&quot;76px&quot; height=&quot;76px&quot;&gt;&lt;/div&gt; &lt;div id=&quot;maintext&quot;&gt; &lt;div id=&quot;mainnice&quot;&gt;&lt;img id=&quot;Dianzan&quot; src=&quot;../svg/unzan.svg&quot; width=&quot;16px&quot; height=&quot;16px&quot;&gt;&lt;/div&gt; &lt;p&gt;&lt;b&gt;&lt;% = rs(&quot;author&quot;) %&gt;&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;% = rs(&quot;content&quot;) %&gt;&lt;/p&gt; &lt;p align = &quot;left&quot; style=&quot;font-size:10px; color: #B2B2B2&quot;&gt;&lt;% = rs(&quot;date&quot;) %&gt;&lt;/p&gt; &lt;div id=&quot;mainline&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;% pageS=pageS-1 rs.movenext loop %&gt; &lt;p&gt;&amp;nbsp;&lt;/p&gt; &lt;p align=&quot;center&quot;&gt; &lt;% if pageNo&lt;&gt;1 then '设置超链接页码或翻页链接，实现分页导航 response.write &quot;&lt;a href='?pageNo=1'&gt;首页&lt;/a&gt; &quot; response.write &quot;&lt;a href='?pageNo=&quot;&amp;pageNo-1&amp;&quot;'&gt;上一页&lt;/a&gt; &quot; else response.write &quot;首页 &quot; response.write &quot;上一页 &quot; end if For i=1 to rs.PageCount if i=pageNo then response.write i&amp;&quot; &quot; '分页，如果是当前页,则不存在链接 else response.write &quot;&lt;a href='?pageNo=&quot;&amp;i&amp;&quot;'&gt;&quot;&amp;i&amp;&quot;&lt;/a&gt;&amp;nbsp;&quot; end if Next if pageNo&lt;rs.PageCount then response.write &quot;&lt;a href='?pageNo=&quot;&amp;pageNo+1&amp;&quot;'&gt;下一页&lt;/a&gt;&amp;nbsp;&quot; response.write &quot;&lt;a href='?pageNo=&quot;&amp;PageCount&amp;&quot;'&gt;末页&lt;/a&gt;&amp;nbsp;&quot; else response.write &quot;下一页 &quot; response.write &quot;末页 &quot; end if response.write &quot;共&quot;&amp;rs.RecordCount&amp;&quot;条记录&amp;nbsp;&amp;nbsp;&quot; '共多少条记录 response.write pageNo&amp;&quot;/&quot;&amp;rs.PageCount&amp;&quot;页&quot; '当前页的位置 %&gt; &lt;/p&gt; 3.4.3.3 conn.execute方法操纵数据库12345&lt;% dim connset conn=Server.CreateObject(&quot;ADODB.Connection&quot;) conn.open(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&quot; &amp; Server.MapPath(&quot;comment.mdb&quot;) )'conn.open(&quot;Dbq=&quot; &amp; Server.Mappath(&quot;comment.mdb&quot;) &amp; &quot;;Driver={Microsoft Access Driver (*.mdb)}&quot; ) %&gt; 3.4.4 评论点赞功能实现点击后点赞图标变换的功能。 123456789$(\"#Dianzan\").click(function() { if (toggle2) { $(\"#mainnice img\").attr(\"src\", \"../svg/onzan.svg\"); toggle2 = false; } else { $(\"#mainnice img\").attr(\"src\", \"../svg/unzan.svg\"); toggle2 = true; } }) 3.5 关于我们页面3.5.1 段落的隐藏与显示1234567$(document).ready(function(){ $(\"h2+ol\").hide(); $(\"h2\").hover (function(){ $(\"+ol\",this).slideDown(\"slow\"); }, ); }); 3.6 登录页面3.6.1 实时时间显示利用JavaScript实现实时时钟显示并显示星期几。 12345678910111213141516171819202122232425262728293031323334353637function clock () { d = new Date(); var spt = document.getElementById(\"time\"); spt.innerHTML=d.getFullYear()+\"年\"+(d.getMonth()+1)+\"月\"+d.getDate()+\"日 \"+d.getHours()+\":\"+d.getMinutes()+\":\"+d.getSeconds(); var spweek = document.getElementById(\"xq\"); spweek.innerHTML=week(); } function week () { var xingqi = d.getDay(); switch (xingqi){ case 0: return \"星期天\"; break; case 1: return \"星期一\"; break; case 2: return \"星期二\"; break; case 3: return \"星期三\"; break; case 4: return \"星期四\"; break; case 5: return \"星期五\"; break; case 6: return \"星期六\"; break; default: return false; break; } } 3.6.2聚焦表单利用onFocus自动聚焦表单。 1234567891011121314151617181920212223function myFocus(){ this.focus(); } function mySelect(){ this.select(); } window.onload = function(){ var elements = document.getElementsByTagName(\"input\"); for (var i = 0;i &lt; elements.length;i++) { var type = elements[i].type; if (type == \"text\" || type == \"password\") { elements[i].onmouseover =myFocus; elements[i].onfocus = mySelect; } } setInterval(\"clock()\",1000); var elements = document.getElementsByTagName(\"input\"); for (var i = 0;i &lt; elements.length;i++) { var type = elements[i].type; if (type == \"text\" || type == \"password\") { elements[i].onfocus = myFocus; elements[i].onblur =myBlur; } } } 3.6.3密码校验将用户输入的用户名和密码在admin表中进行查找，如果查找得到的记录集不为空，就表明有匹配的用户名和密码。 12345678910111213141516171819202122232425&lt;%StrSQL=&quot;DBQ=&quot;+server.mappath(&quot;comment.mdb&quot;)+&quot;;DRIVER={Microsoft Access Driver (*.mdb)};&quot;set conn=server.createobject(&quot;ADODB.CONNECTION&quot;)conn.open StrSQLsub CloseConn() conn.close set conn=nothingend subfunction decrypt(dcode) dim textsdim ifor i=1 to len(dcode)texts=texts &amp; chr(asc(mid(dcode,i,2))-i)nextdecrypt=textsend functionfunction encrypt(ecode)Dim textsdim ifor i=1 to len(ecode)texts=texts &amp; chr(asc(mid(ecode,i,2))+i)nextencrypt = textsend function%&gt; 3.7 注册页面3.7.1表单校验在输入完一项即失去交掉时进行验证，提示用户进行修改。 12345678910111213141516171819function myBlur(){ this.style.backgroundColor=\"#ffffff\"; startCheck(this); //这一句是新增的验证表单的代码 } function startCheck(oInput){ if(oInput.name==\"User\"){ //如果是用户名的输入框 if(!oInput.value){ //如果值不为空 oInput.focus(); //聚焦到用户名的输入框 document.getElementById(\"UserResult\").innerHTML = \"用户名不能为空\"; return;} else document.getElementById(\"UserResult\").innerHTML = \"\"; } if(oInput.name==\"passwd2\"){ if(document.getElementsByName(\"passwd1\")[0].value!= document.getElementsByName(\"passwd2\")[0].value) //如果两个密码框值不相等 document.getElementById(\"pwdResult\").innerHTML = \"两次输入的密码不一致\"; else document.getElementById(\"pwdResult\").innerHTML = \"\";} } 3.8 评论管理页面3.8.1验证用户登录验证用户的Session(“admin”)变量是否为空，如果为空就表明没有登录，而是通过直接输入admin.asp的URL进入的，此时必须将其引导至登录页。 1&lt;% if session(&quot;admin&quot;) = &quot;&quot; then response.redirect &quot;denglu.asp&quot; %&gt; 3.8.2数据库语句的删除利用Connection对象的Execute方法执行一条Delete语句来删除记录。 12345678910111213&lt;% id=cint(request.QueryString(&quot;id&quot;))Set rs=Server.CreateObject(&quot;ADODB.Recordset&quot;) rs.open &quot;select * from lyb where id=&quot;&amp;id ,conn,1,3 '找到要删除的记录rs.delete '删除当前记录rs.update '更新记录集Response.Redirect(&quot;admin.asp&quot;)%&gt;&lt;% dim connset conn=Server.CreateObject(&quot;ADODB.Connection&quot;) conn.open(&quot;Provider=Microsoft.Jet.OLEDB.4.0;Data Source=&quot; &amp; Server.MapPath(&quot;comment.mdb&quot;) )'conn.open(&quot;Dbq=&quot; &amp; Server.Mappath(&quot;comment.mdb&quot;) &amp; &quot;;Driver={Microsoft Access Driver (*.mdb)}&quot; ) %&gt; 3.8.3数据库语句的批量删除通过action属性将表单提交给自身。 1234567891011121314151617181920212223&lt;div style=&quot;padding: 15px 15px 30px; background-color: white; border-radius: 0px 0px 3px 3px&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;?del=1&quot;&gt; &lt;!--表单提交给自身--&gt; &lt;table class=&quot;comment&quot; border=&quot;1&quot; width=&quot;100%&quot;&gt; &lt;tr &gt; &lt;th&gt;内容&lt;/th&gt;&lt;th&gt;作者&lt;/th&gt;&lt;th&gt;日期&lt;/th&gt;&lt;th&gt;删除&lt;/th&gt; &lt;/tr&gt; &lt;% do while not rs.eof %&gt; &lt;tr&gt; &lt;td&gt;&lt;%= rs(&quot;content&quot;) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= rs(&quot;author&quot;) %&gt;&lt;/td&gt; &lt;td&gt;&lt;%= rs(&quot;date&quot;) %&gt; &lt;/td&gt; &lt;td align=&quot;center&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;selected&quot; value=&quot;&lt;%=rs(&quot;id&quot;)%&gt;&quot;&gt;&lt;/td&gt; &lt;!--复选框--&gt; &lt;/tr&gt; &lt;% rs.movenext loop %&gt; &lt;tr &gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;td align=&quot;center&quot; style=&quot;width: 80px&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;删除&quot; style=&quot;width: 100px; height: 30px; padding: 1px 5px; border: 0px; background-color: #E71D73; border-radius: 20px; color: white; font-size: 14px;&quot;&gt;&lt;/td&gt; &lt;!--删除按钮--&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; &lt;/div&gt;","link":"/2019/11/26/digtalmedia-web/"},{"title":"游戏资源常见贴图类型","text":"游戏模型制作中用到了很多贴图类型，通过不同类型贴图的组合使用以达到最终需要得到的模型效果。最常见的类型有Diffuse、Emissive、Normal、Opacity、Specular、Roughness。游戏制作中根据项目资产的需要使用不同的贴图类型。 在基于物理纹理的渲染（PBR）中，有两种最常见的工作流程，即金属/粗糙度和高光反射/光泽度。在使用过程中，两种工作流程各有利弊（详见PBR-Guide）。 1. 颜色贴图颜色贴图主要为Diffuse、Albedo、Base Color三种。一般认为这三者是等同的。 1.1 Diffuse光照模型在Lambertian（兰伯特材质球）着色器中会把颜色贴图叫做Diffuse Map（也叫颜色贴图），通常在绘制这张Diffuse Map的时候会把物体的结构阴影信息也绘制进去。在传统工作流中，Diffuse Map是带着光影信息的。 Diffuse Map（漫反射颜色）应该表示物体表面的颜色，在Unity中叫做Albedo。在Specular/Glossiness工作流程中，对于金属材质而言它没有漫反射(或者说比较少)，所以使用黑色来填充。而非金属材质反射光少于金属材质，并且它折射的光只有较少的吸收通常重新折射回表面，因此对于非金属材质，使用的是漫反射颜色来填充。需要特别注意的是，漫反射纹理不应该包含任何光照信息，因为将基于（环境）添加光照到物体的纹理上。 1.2 Albedo主要体现模型的纹理和颜色。Unity的Shader（着色器）中，把颜色贴图叫做Albedo。 1.3 Base ColorBase Color是把颜色贴图剔除光影变化后，我们看到的最基础的颜色。在PBR工作流中颜色贴图叫做Base Color， 其中包含了电介质的反射颜色和金属的反射率值这两种类型的数据。因为Base Color Map中带了金属的反射率值，所以需要配合上Metallic Map一起使用的。 比较容易造成混淆的是金属/粗糙度工作流中的Base Color和高光反射/光泽度工作流中的Diffuse(Albedo)的区别，两种工作流使用了不同的贴图方法来处理颜色。实际上，金属/粗糙度工作流中的Base Color本质上是高光反射/光泽度工作流中的Diffuse和Specular的结合，这也是有时候通过先创建金属/粗糙度材质再将其转化为高光反射/光泽度的原因之一。 在高光反射/光泽度工作流中，Diffuse贴图严格影响着材质的基本颜色而对材质的其他特征（如发射率）没有影响。对于介电材质而言，其材质颜色来自Diffuse贴图；对于金属材质而言，大部分颜色来自Specular高光贴图。 在金属/粗糙度工作流中，BaseColor贴图实则包含了漫反射和高光贴图的信息。而Metallic贴图这决定了有多少BaseColor被解释为漫反射或者高光。 *1.4 Gradient&amp;ColorLUTGradient Map（渐变图）和ColorLUT（颜色查找表）也可以认为是颜色贴图的一种，这类贴图通过在一维或二维的方式将一种颜色映射到另一种颜色。且通常作为全局资源使用（不是特定于某一模型）。 Valve在Team Fortress 2中使用渐变纹理来控制漫反射光照，渲染游戏中具有插画风格的角色。 ColorLUT是预先生成的一张结果纹理，可用于优化复杂光照的渲染，如皮肤、毛发等。 2. 凹凸贴图凹凸贴图主要为Bump、Normal和Displacement三种，三种贴图都是为模型提供更多的细节。其中Displacement有时用于改变模型的顶点位置（作为Parallax视差贴图使用），而Bump和Normal则不会改变模型的顶点位置。 就实现复杂度/质量与性能开销而言，Dispalcement&gt;Normal&gt;Bump(&gt;Reflection)。 2.1 BumpBump Map（凹凸贴图 ）是一个类似于法线贴图的概念，有时也称为Height（高度图）。但是凹凸贴图只包含高度信息而不包含角度信息。凹凸贴图的优点是可以很直观地看出模型表面的凹凸情况（颜色越浅表明该位置的表面越像外凸起，反之亦然），但是计算更复杂，因此更性能开销更大。高度图通常与法线贴图结合使用，用于给出表面凹凸的额外信息。 Substance Painter、Substance Designer导出的Height高度图等同于Bump凹凸贴图，而不是Displacement置换贴图的信息。 2.2 NormalNormal Map（法线贴图）是凹凸映射技术的另一种应用。法线贴图包含角度信息而不包含任何高度信息，其R、G、B三个通道储存的信息表示了斜面的方向和陡峭程度。 这一特征使得我们可以使用法线贴图储存的角度信息来柔化尖锐的边缘（仅使用Bump高度信息无法做到这一点，因为只有高度信息无法知道边缘应该沿着哪个方向弯曲）。柔化边缘不仅可以让物体看起来更真实，还能进一步突出物体的形状（尤其是在游戏对象在屏幕上占比较小的时候）。 由于法线贴图存储的是表面的法线方向，而方向是相对于坐标空间而言的。因此存在三种不同的空间法线贴图：Tangent切线空间、Object对象空间、World世界空间，三种法线贴图都有各自的优缺点且能达到相同的效果，只是计算方式有所不同。 2.2.1 Tangent Space Tangent Space（切线空间），顾名思义，切线空间法线是基于每个面的切线方向。切线空间下的法线贴图是最常见的法线贴图形式，大部分看起来都是浅蓝紫色的。其中，B通道表示法线方向的斜率；R通道表示左右切线方向的斜率；G通道表示切线方向向上或向下的斜率（OpenGl向上，DirectX向下）。 2.2.2 Object Space Object Space（对象空间或模型空间）法线贴图基于整个对象而不是每个面，大部分看起来都是五颜六色的。对象空间法线贴图在渲染上较快，但由于其无法镜像任何UV，在对称模型上会浪费大量纹理空间，且无法进行UV动画。因此在很多情况下切线空间较优于对象空间。 2.2.3 World Space World Space（世界空间）是基于全局坐标的法线贴图，也是三种法线贴图中最不灵活的一种。 这种类型的法线贴图一般仅用于环境这类大型，静态和非对称的物体，或者临时用于诸如Substance Painter、Substance Designer之类软件中作为计算特殊效果（如风化效果）的一种方法。 2.3 DisplacementDisplacement Map（置换贴图，也叫移位贴图）可以改变模型对象的几何形状，因此在提供最真实的效果的同时也会大幅增加渲染性能的开销。 置换贴图能实现很多仅仅通过Bump和Normal无法实现的效果（尤其是模型对象的轮廓表现）。 置换贴图也常作为高度图来生成地形，并结合凹凸贴图实现丰富的地形效果。 2.3.1 Parallax Map置换贴图的另一个用途是作为Parallax Map（视差贴图，也称为Virtual Displacement Map虚拟置换贴图）使用。 ![视差贴图效果](Comparison Parallax.png) 视差贴图是一种更高级的技术，能够提供比凹凸贴图更多的深度。视差贴图通过偏移每个像素的纹理坐标以达到更好的视觉表现，但仍不如性能开销更大的Relief Map（浮雕贴图）。 2.3.2 Relief MapRelief Map（浮雕贴图，也称为Parallax Occlusion Map视差遮挡贴图）能够实现比视差贴图更深的凹凸深度，并能实现自阴影和遮挡效果。 2.3.3 Vector DisplacementVector Displacement Map（矢量置换贴图）是高度贴图的扩展，与传统Displacement（置换贴图）不同的是矢量置换贴图记录了模型上各点的高度和方向信息，并储存为16/32位浮点颜色信息。 传统的置换贴图使用的是低模的UV坐标，贴图记录了高模和低模之间的差异。而矢量置换贴图在使用类似映射方法的同时，而另一个模型最近的顶点之间的距离，还能在空间中移动顶点。因此也能记录复杂的凹面下（如蘑菇、耳朵等）的顶点信息，将雕刻细节从一个模型转移到另一个模型。 3. 反射贴图与颜色贴图中的Diffuse和Base Color一样，反射贴图中根据工作流的不同也有不一样的贴图类型。 3.1 Metal - Roughness 在金属/粗糙度工作流中，使用的反射贴图为Metallic和Roughness。 3.1.1 MetallicMetallic（金属贴图）起到类似于蒙版的作用，区分固有色贴图中的金属和绝缘体数据。在金属性贴图中，0（黑色-0 sRGB）表示绝缘体，而1（白-255 sRGB）表示金属。 金属贴图的运行方式类似于掩码的运作方式，因为该贴图向着色器阐释如何分析基础色中的数据。金属感对象的光泽度由粗糙度控制。 材质越粗糙，其光泽度就会越低， 而缺少粗糙度将使金属显得非常有光泽。 3.1.2 RoughnessRoughness（粗糙度贴图）定义材质得粗糙度信息，0（黑色-0 sRGB）表示光滑，1（白-255 sRGB）表示粗糙。粗粗糙度是指造成光漫射的表面不规则状况，反射方向根据表面粗糙度自由变化。这改变了光的方向，但是光强度保持恒定不变。表面越粗糙，高光越散越暗。表面越光滑，高光反射集中，尽管反射的光的总量是一点的，表面也会更亮，光会更强。 Roughness粗糙度贴图 与Glossiness Map光泽度贴图是相反的。Roughness 反向就变成Glossiness Map 。 3.2 Specular - Glossiness 在高光反射/光泽度工作流中，使用的反射贴图为Specular和Glossiness。 3.2.1 SpecularSpecular（高光贴图）表示高光得范围、强度、颜色，在Specular工作流中，颜色越亮高光越强，黑色表示没有高光。 高光反射规定了金属的反射率值和非金属的F0。使用RGB贴图可以在贴图中创建不同反射率的电介质材质。 高光度也可影响材质的光泽度。 将“高光度（Specular）”值调整到接近1时，将使材质的反射和反射高光显得特别强特别显眼， 而将该值减小到接近0会弱化反射及反射高光，直到它们几乎不存在为止。 高光度（Specular）也深受粗糙度影响。 即使“高光度（Specular）”输入设置为1，通过将“粗糙度（Roughness）”的值设置为1，也可以取消高光度效果。 另外，如果启用了金属感，那么调整高光度不会影响材质。 3.2.2 GlossinessGlossiness（缩写Gloss，光泽度贴图），定义材质得粗糙度信息，跟Roughness相反，0（黑色-0 sRGB）表示粗糙，1（白-255 sRGB）表示光滑。 光泽度无非是指表面反射光线的能力。 表面能够反射的光线越多，光泽度越高。 表面能够反射的光线越少，光泽度越低。 表面反射光线的能力受环境中各种因素的影响，例如落在对象上的那些非常小颗粒的灰尘，以及接触对象时从手上沾染到对象上的油污， 所有这一切都会影响表面反射光线的能力。 *3.3 Anisotropic Map Anisotropic Map（各向异性贴图）是一种特殊的反射贴图。拉丝金属通常具有各向异性的高光，这是由表面的微划痕引起的。有时使用各项异性贴图去制作拉丝金属的效果。 4. 结构贴图4.1 Ambient OcclusionAmbient Occlusion（AO，环境光遮蔽贴图）描述了较大尺度的光线遮蔽信息，通常由高模烘培得到。指表面某点能获得多少环境中的光，用来模拟物体之间所产生的阴影，在不打光的时候增加体积感。 环境光遮蔽贴图基于物体与其他物体越接近的区域，受到反射光线的照明越弱这一现象来模拟现实照明的一部分效果。该贴图只影响漫反射分配，不影响高光反射分配。 4.2 CavityCavity Map（缝隙图）描述了比AO图更小尺度的光线遮蔽信息，通常由高模或者法线贴图烘培得到。 缝隙图只包含模型对象表面的凹面区域而不包括凸面区域，因此缝隙图通常大部分都是白色的，只有凹陷区域是深色的。与AO图不同的是，缝隙图影响不仅会影响漫反射，还会影响高光反射部分。 4.3 Bent NormalBent Normal Map（环境法线贴图）有助于减少照明构建之后发生的漏光现象。 环境法线贴图能够和AO图结合使用以改善漫反射间接照明，通过将环境发现代替法线用于间接照明来使漫反射间接照明更接近于全局光照。 4.4 CurvatureCurvature（曲率贴图）是存储网格的凸度/凹度的纹理，可用于遮盖表面会出现更多磨损的地方或可能发生次表面散射的地方（凸面），可能积累更多污垢（凹面）的地方，以检查表面的连续性等。 曲率贴图允许提取和存储凹凸信息。黑色的值代表了凹区域，白色的值代表了凸区域，灰色值表示中性/平坦区域。。 4.5 ThicknessThickness（厚度贴图）记录了表面厚度信息，可以用于辅助制作表面散射(SSS，简称3S材质)材质，或直接扩散/反照率假装SSS的效果。 其黑色代表薄的地方、白色代表厚的地方。 5. 光照与环境贴图5.1 Light MapLight Map（光照贴图）用来存储预渲染的光照信息，用于静态模型上的间接光照，解决实时动态光源效果不好且消耗性能的问题。 光照贴图通常存储了静态烘培光源的颜色和亮度，由于光照贴图是预渲染的，因此可以使用如光能传递等非实时方法来得到更真实的效果。 5.2 Spherical Environment MapSpherical Environment Map（球面环境贴图）是最简单的反射映射技术之一。球面环境贴图将环境光存储在球面上，然后用环境光去渲染整个的物体。 由于是通过球体来存储环境信息，这就导致了描述的不是均匀的信息，会在靠近极点的地方出现扭曲（墨卡托投影：将地球进行投影到平面，维度高的地方在平面地图上看起来会更大） 5.2 Cube MapCube Map（立方体贴图）是环境映射的一种实现方法。环境映射可以模拟物体周围的环境，而使用了环境映射的物体可以看起来像镀了层金属一样反射出周围的环境。 立方体贴图包含了6张图像，对应着立方体的6个面，每个面表示沿着世界空间下的轴向观察所得的图像。 立方体贴图解决了球面环境贴图图像扭曲的问题，但立方体贴图不能模拟多次反射的结果。 5.3 Radiosity Normal MapRadiosity Normal Map（辐射度法线贴图）是光贴图和法线贴图的特殊混合。可以将照明作为一组三个光照贴图进行烘焙，以存储照明矢量，而不仅仅是亮度/颜色。这使表面法线贴图可以接收定向照明，因此，通过烘焙的照明信息可以更准确地照明凹凸。 Valve在Half-Life 2中广泛使用了此方法，他们在GDC 2004论文*Half-Life®2/ Valve Source™Shading*中将其称为“辐射度法线贴图” 。 6. 其他贴图6.1 ID/MaskID/Mask Map（ID、遮罩贴图）用于选择不同的区域，进行分别绘制。 6.2 EmissiveEmissive Map（自发光贴图）控制表面发射光的颜色和亮度。当场景中使用了自发光材质时，它看起来像一个可见光。物体将呈现发光效果。 自发光材质通常用于某些部位应该从内部照亮的物体上，例如监视器屏幕、高速制动的汽车盘式制动器、控制面板上的发光按钮，或黑暗中仍然可见的怪物眼睛。简单的自发光材质可以通过一个颜色和亮度来定义。 6.3 OpacityOpacity（透明贴图）定义贴图的不透明度，用于裁剪表面的一部分。黑色是透明的部分，白色为不透明的部分，灰色为半透明的部分。 当材质使用不透明度贴图时，它将充当遮罩，该遮罩将隐藏对象的某些部分。例如可以将“不透明度”贴图用于剪切树叶形状，穿孔表面和网格等。 6.5 PositionPosition Map（位置贴图）使用R/G/B三个通道描述X/Y/Z轴上顶点对应的位置。 通常位置贴图来实现模型底部到顶部的渐变效果等，如墙壁底部的污渍、石块底部的青苔。 6.6 Detail MapDetail（细节贴图）是用于平铺的局部贴图纹理，以相对较低的成本，内存和性能来增加表面细节（微观和宏观）。 细节贴图通常为四方连续纹理，并由一组贴图组合而成（法线、反射率、光泽度等）。 6.7 Flow MapFlow Map（流动贴图）存储的是向量场数据，可以用来制作流动的水面效果。 Valve在Portal 2和Left 4 Dead 2中广泛使用了此方法，他们在SIGGRAPH 2010论文*Vlachos/Water Flow in Portal 2*中分享了用流动贴图制作流动水面的技术。 6.8 DuDv MapDuDv贴图是使用一种纹理扭曲另一种纹理的像素的一种简单方法。常用于火上的热雾、涟漪折射的水面等。 DuDv贴图与法线贴图类似，都是将方向信息存储在纹理中，但DuDv贴图仅用到了R通道和G通道。 DuDv的工作方式与视差贴图扭曲曲面的方式类似，只是DuDv不考虑视角（无视差）。从DuDv贴图中获取Du和Dv，对反射贴图中的每个像素，将Du添加到反射贴图的U纹理坐标，并将Dv添加到其V坐标。最后偏移反射贴图像素，从而产生失真。 《Unity Shader入门精要》 《Real-Time Rendering 4th Edition》 GAMES101:现代计算机图形学入门[http://games-cn.org/intro-graphics/] 游戏美术基础：游戏贴图[https://www.jianshu.com/p/c1ed26cbb6b4] Polycount - Texture types[http://wiki.polycount.com/wiki/Texture_types] 《Real-time Shallow Water Simulation and Environment Mapping and Clouds - Rene Truelsen》 What are the different texture maps for?[https://help.poliigon.com/en/articles/1712652-what-are-the-different-texture-maps-for] The PBR Guide part 1[https://academy.substance3d.com/courses/the-pbr-guide-part-1-zh] The PBR Guide part 2[https://academy.substance3d.com/courses/the-pbr-guide-part2-zh] Diffuse/Specular vs BaseColor[https://resources.turbosquid.com/stemcell/stemcell-3d-modeling-workflow/stemcell-textures-materials/diffuse-specular-vs-basecolor/] Normal vs. Displacement Mapping &amp; Why Games Use Normals[https://cgcookie.com/articles/normal-vs-displacement-mapping-why-games-use-normals] Physically-Based Rendering, And You Can Too![https://marmoset.co/posts/physically-based-rendering-and-you-can-too/] Level of Detail[https://resources.turbosquid.com/level-of-detail/] Elliminate Texture Confusion: Bump, Normal and Displacement Maps[https://www.pluralsight.com/blog/film-games/bump-normal-and-displacement-maps] VECTOR DISPLACEMENT MAPS[http://docs.pixologic.com/user-guide/3d-modeling/exporting-your-model/vector-displacement-Maps/] Parallax Map with Offset Limiting: A PerPixel Approximation of Uneven Surfaces BRUSHED METAL V-RAY MATERIAL[https://resources.turbosquid.com/library-tutorials/brushed-metal/] Half Avocado[https://quixel.com/megascans/home?category=3D%20asset&amp;category=edible&amp;category=fruit&amp;assetId=ujcxeblva] Art of Lighting Game Environments in Unity[https://cgcookie.com/articles/art-of-lighting-game-environments] Detail Maps[https://docs.cryengine.com/display/SDKDOC2/Detail+Maps] 180701 UE4 Flowmap Fields Visualizer[https://www.youtube.com/watch?v=frfcRzuw6OM]","link":"/2020/10/01/gaming-texture/"},{"title":"灯塔网","text":"算是一个比较完整的项目，作为交互设计的课设本身，前期做了大量关于用户调研的工作，然后进行原型设计、UI设计，最后实现整个网站的前端和后端。 1. 团队介绍 2. 产品介绍 3. 领域调研 4. 用户研究 5. 交互设计 6. 视觉设计","link":"/2020/01/02/beacon-web/"},{"title":"计算机图形学-Bezier曲线","text":"实现二维 n 次 Bezier 曲线的绘制； 设计菜单、对话框修改 Bezier 曲线的次数，由鼠标在屏幕上指定控制顶点，并在屏幕上显示控制多边形，生成逼近它的 Bezier 曲线。 1. 原理 2. 程序实现2.1 computeCoefficients123456789101112void CCG3View::computeCoefficients(int n, int* c){ int k, i; for (k = 0; k &lt;= n; k++) { c[k] = 1; for (i = n; i &gt;= k + 1; i--) c[k] *= i; for (i = n - k; i &gt;= 2; i--) c[k] /= i; }} 2.2 computePoint12345678910111213void CCG3View::computePoint(float t, CPoint *pt, int ncontrols, CPoint *cps, int *c){//pt为所求点，ncontrols为控制点点数目，cps所指数组存放控制点点坐标 int i, n = ncontrols - 1; float blend, t1 = 1 - t; //基函数的值 pt-&gt;x = 0.0; pt-&gt;y = 0.0; for (i = 0; i &lt;= n; i++) { blend = c[i] * powf(t, i)*powf(t1, n - i); /*求 C i n t i (1-t) n-i */ pt-&gt;x += cps[i].x*blend; /*求 x(t)*/ pt-&gt;y += cps[i].y*blend; /*求 y(t)*/ }} 2.3 Bezier12345678910void CCG3View::Bezier(CPoint *cps, int ncontrols, int m, CPoint *curve){//m 个采样点，结果保存在 curve 所指的数组里面 int i; int *c = (int *)malloc(ncontrols * sizeof(int)); computeCoefficients(ncontrols - 1, c); for (i = 0; i &lt;= m; i++) computePoint(i / (float)m, &amp;curve[i], ncontrols, cps, c); free(c);} 2.4 drawPolygon1234567891011121314151617void CCG3View::drawPolygon(CDC* pDC, CPoint *cps, int ncontrols){//ncontrols为控制点点数目，cps所指数组存放控制点点坐标 int i, x, y; x = y = 0; for (i = 0; i &lt;= ncontrols-1; i++) { x = cps[i].x; y = cps[i].y; // pDC-&gt;SetPixel(x, y, RGB(255, 0, 0)); if(i&gt;0) pDC-&gt;LineTo(x, y); pDC-&gt;MoveTo(x, y); }// free(cps);} 2.5 drawBezier1234567891011void CCG3View::drawBezier(CDC* pDC, CPoint *curve, int m){//m 个采样点，结果保存在 curve 所指的数组里面 int i, x, y; for (i = 0; i &lt;= m; i++) { x = curve[i].x; y = curve[i].y; pDC-&gt;SetPixel(x, y, RGB(255, 0, 0)); }// free(curve);} 2.6 OnBezier327711234567891011121314151617181920212223void CCG3View::OnBezier32771(){ // TODO: 在此添加命令处理程序代码 CKongzhi dlg; dlg.DoModal(); extern CPoint* cpsIN; extern int ncontrolsIN; extern int mIN; int i; ncontrols = ncontrolsIN; m = mIN; cps = (CPoint*)malloc(ncontrols * sizeof(CPoint)); curve = (CPoint*)malloc(m * sizeof(CPoint)); for (i = 0; i &lt; ncontrols; i++) { cps[i].x = cpsIN[i].x; cps[i].y = cpsIN[i].y; } Bezier(cps, ncontrols, m, curve); Invalidate(true);} 2.7 OnLButtonDown1234567891011121314151617181920void CCG3View::OnLButtonDown(UINT nFlags, CPoint point){ // TODO: 在此添加消息处理程序代码和/或调用默认值 int i; if (isLeft) { cpsBt[ncontrols].x = point.x; cpsBt[ncontrols].y = point.y; ncontrols++; // cps = (CPoint*)malloc(ncontrols * sizeof(CPoint)); for (i = 0; i &lt; ncontrols; i++) { cps[i].x = cpsBt[i].x; cps[i].y = cpsBt[i].y; } } Bezier(cps, ncontrols, m, curve); Invalidate(true); CView::OnLButtonDown(nFlags, point);} 2.8 OnRButtonDown1234567void CCG3View::OnRButtonDown(UINT nFlags, CPoint point){ // TODO: 在此添加消息处理程序代码和/或调用默认值 isLeft = 0; Invalidate(true); CView::OnRButtonDown(nFlags, point);} 3. 测试3.1 输入控制点 3.2 鼠标点击绘制","link":"/2019/05/13/cg-bezier/"},{"title":"蛋黄哥学算术-基于flash的小游戏","text":"概述：蛋黄哥学算术是一个面向儿童的益智型算术小游戏，游戏共有三个难度：入门级、一般级和大师级，可供不同水平阶段的儿童进行算术练习。 类型：面向儿童的益智算术小游戏 1. 游戏介绍1.1 游戏内容本游戏以蛋黄哥（懒蛋蛋）为游戏主角，以小学生为游戏对象加入三种不同难度的算术题：10以内的加减法、100以内的加减法和100以内的乘除法。玩家在点击开始选择难度后进入游戏，开始计时。玩家需要根据屏幕上随机生成的等式在下方的输入框内输入答案并点击确定按钮；每局游戏都有相应的计时器，生命值，在规定时间内生命值为零则视为游戏失败，进入失败界面；若在规定时间内未作答或未耗尽生命值则进入超时界面之后跳转至失败界面；只有在规定的时间内在不耗尽生命值的情况下正确答题方才算成功。 1.2 流程结构 1.3 作品的视觉设计 2.游戏的技术实现2.1 页面之间的主要跳转方式2.1.1 通过跳转至场景的方式实现不同页面的切换 12345button_3.addEventListener(MouseEvent.CLICK, fl_ClickToGoToScene_2);function fl_ClickToGoToScene_2(event:MouseEvent):void{ MovieClip(this.root).gotoAndPlay(1, \"场景 1\");} 2.1.2 通过跳转至不同帧的方式实现不同页面的切换 12345nd3.addEventListener(MouseEvent.CLICK, fl_ClickToGoToAndStopAtFrame_15);function fl_ClickToGoToAndStopAtFrame_15(event:MouseEvent):void{ gotoAndStop(4);} 2.2 通过函数显示对象延时添加至舞台 1234567891011121314var interval:uint=200;var myTimer8:Timer=new Timer(interval);myTimer8.addEventListener(TimerEvent.TIMER, timerHandler);myTimer8.start();var play1:playbtn=new playbtn();function timerHandler(event:TimerEvent):void { var t:Number=myTimer8.currentCount/10; if (t == 1.2) { myTimer8.stop(); play1.x= 640; play1.y= 360; addChild(play1); }} 2.3 视频的播放跳转至帧并播放视频 12345function ClickToGoToAndStopAtFrame_5(event:MouseEvent):void{ gotoAndStop(5); video1.play();} 2.4 场景的背景音乐 2.5 按钮音效 2.6 场景的连续播放通过添加计时器在该帧播放完后跳转到另一帧 1234567891011var interval:uint=200;var myTimer2:Timer=new Timer(interval);myTimer2.addEventListener(TimerEvent.TIMER, timerHandler);myTimer2.start();function timerHandler(event:TimerEvent):void { var t:Number=myTimer2.currentCount/10; if (t == 1.2) { myTimer.stop(); gotoAndStop(2); }} 2.7 生命条通过生命条影片剪辑元件跳到下一帧并减少1个生命值 1234567891011121314function define_f(event:MouseEvent):void { num3in = Number(num3.text); if(num3in == num3temp){ myTimer.stop(); gotoAndStop(3); }else{ lifebar.nextFrame(); num3.text = \"\"; life --; if(life == 0){ myTimer.stop(); gotoAndStop(2); } } 2.8 游戏主题的实现 2.9 功能的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657stop ();//计时器var myTimer:Timer = new Timer(1000,60);myTimer.addEventListener(TimerEvent.TIMER, timefun);myTimer.start();var time:Number=30;var timetemp:Number=time;timer.text=String(time);function timefun(the:TimerEvent):void { time-=1; timer.text=String(time); if(time == 0){ myTimer.stop(); gotoAndStop(4); }}var num1temp :Number;//定义var num2temp :Number;var num3temp :int;var num3in:Number;var life:Number;var numhow:Number;var num3ch:Number;life = 5;//起始生命值do{//算术方法的随机控制，并保证不会出现非整除算式num1temp =int(Math.random()*100)+1;num2temp =int(Math.random()*100)+1;numhow = int(Math.random()*10)+1;if(numhow &gt; 5){ how.text = 'x'; num3temp = num1temp * num2temp; num3ch =0; }else{ how.text = '÷'; num3temp = num1temp / num2temp; num3ch = (num3temp*num2temp)-num1temp; }}while(num3ch != 0);num1.text = String(num1temp);num2.text = String(num2temp);//将生成的随机数显示到屏幕上define.addEventListener(MouseEvent.CLICK,define_f);function define_f(event:MouseEvent):void { //回答正确与否的判断，每次答错都会清空输入框的内容并扣去一个生命值；生命值为零或超时则跳转到失败页面，回答正确则跳转到成功页面 num3in = Number(num3.text); if(num3in == num3temp){ myTimer.stop(); gotoAndStop(3); }else{ lifebar.nextFrame(); num3.text = \"\"; life --; if(life == 0){ myTimer.stop(); gotoAndStop(2); } }} 3.工作分析和总结3.1 遇到的问题及解决 运行时帧的不断切换播放（通过stop();解决） 编译器空对象错误（计时器等在跳转帧时未停止，视频未停止，通过停止后解决） 随机生成的运算符号不显示（随机数生成的结果没有完整的考虑在选择结构中）","link":"/2018/12/18/danghuang-game/"},{"title":"素描","text":"两幅素描考试作品哈哈哈哈~","link":"/2018/12/12/sketch-2018/"},{"title":"计算机图形学-Unity中矩阵变换、坐标空间的回顾","text":"这几天重新回顾了一下图形学在Unity中的应用。主要是针对矩阵变换、坐标空间和法线变换的内容。 1. 矩阵与矩阵变换1.1 矩阵向量的矩阵表示：设已知向量 $$\\vec{R}=a \\vec{\\imath}+b \\cdot \\vec{\\jmath}+c \\cdot \\vec{k}$$ 则可用矩阵表示为 $$\\vec{R}=\\left[\\begin{array}{lll} a & b & c \\end{array}\\right] \\cdot\\left[\\begin{array}{c} \\vec{i} \\\\ \\vec{j} \\\\ \\vec{k} \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 1.2 齐次坐标表示法由n+1维向量表示一个n维向量。如n维向量(P1,P2, … ,Pn)表示为(hP1,hP2,…,hPn,h) ，其中h称为哑坐标。其作用为： 将各种变换用阶数统一的矩阵来表示。提供了用矩阵运算把二维、三维甚至高维空间上的一个点从一个坐标系变换到另一坐标系的有效方法。 便于表示无穷远点：例如：（xxh, yxh, h) ，令h等于0。 齐次坐标变换矩阵形式把直线变换成直线段，平面变换成平面，多边形变换成多边形，多面体变换成多面体。（图形拓扑关系保持不变) 变换具有统一表示形式的优点：便于变换合成，便于硬件实现。 1.3 行矩阵还是列矩阵在Unity中，常规做法是把矢量放在矩阵的右侧，即把矢量转换为列矩阵来进行运算。这意味着，在Unity中的矩阵乘法通常都是右乘，例如： $$\\mathbf{C B A v}=(\\mathbf{C}(\\mathbf{B}(\\mathbf{A v})))$$ 使用列矩阵意味着我们对上式的阅读顺序为从右到左，即先对v使用A进行变换，再使用B进行变换，最后使用C进行变换。 2. 矩阵变换2.1 二维变换矩阵由于我们在Unity中基本上使用的都是三维矩阵的变换，所以在这里就不过多讨论二维矩阵的变换，只给出二维变换矩阵的统一表达式： $$ \\begin{bmatrix} a & b & p \\\\ c & d & q \\\\ m & n & s \\end{bmatrix} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 2.2 三维变换矩阵线性变换指哪些可以保留矢量加和标量乘的变换。对于所有线性变换来说，如果我们要对一个三维的矢量进行变换，那么仅仅使用3X3的矩阵就可以表示所有的线性变换。但是3X3矩阵不能表示平移操作，因此将其扩展为4X4矩阵（齐次坐标）。 2.2.1 基本操作平移矩阵： $$ \\begin{bmatrix} 1 & 0 & 0 & t_{x} \\\\ 0 & 1 & 0 & t_{y} \\\\ 0 & 0 & 1 & t_{z} \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 缩放矩阵： $$ \\begin{bmatrix} k_{x} & 0 & 0 & 0 \\\\ 0 & k_{y} & 0 & 0 \\\\ 0 & 0 & k_{z} & 0 \\\\ 0 & 0 & 0 & 1 \\end{bmatrix} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 旋转矩阵： $$ \\mathbf{R}_{x}(\\theta)=\\left[\\begin{array}{cccc} 1 & 0 & 0 & 0 \\\\ 0 & \\cos \\theta & -\\sin \\theta & 0 \\\\ 0 & \\sin \\theta & \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); $$ \\mathbf{R}_{y}(\\theta)=\\left[\\begin{array}{cccc} \\cos \\theta & 0 & \\sin \\theta & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin \\theta & 0 & \\cos \\theta & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); $$ \\mathbf{R}_{z}(\\theta)=\\left[\\begin{array}{cccc} \\cos \\theta & -\\sin \\theta & 0 & 0 \\\\ \\sin \\theta & \\cos \\theta & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 对矢量的变换则利用该矢量的列矩阵与上述矩阵点乘即可。 $$ \\begin{bmatrix} x \\\\ y \\\\ z \\\\ 1 \\end{bmatrix} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 2.2.2 复合变换复合变换可通过矩阵的串联来实现，可以使用下面的公式来计算： $$\\mathbf{p_{new}}=\\mathbf{M_{tramslation}}\\mathbf{M_{rotation}}\\mathbf{M_{scale}}\\mathbf{p_{old}}$$由于我们使用的是列矩阵，因此阅读顺序是从右到左，即先进行缩放变换，再进行旋转变换，最后进行平移变换。 在绝大多数情况下，我们约定变换的顺序是先缩放，再旋转，最后平移。 还有个要注意的是旋转的变换顺序。如果要同时绕三个轴进行旋转，在Unity中旋转的顺序是zxy，这意味着组合旋转变换矩阵是： $$ M_{r o t a t a _Z} M_{r o t a t a _X} M_{r o t a t a _Y}=\\left[\\begin{array}{cccc} \\cos \\theta _{Z} & -\\sin \\theta _{Z} & 0 & 0 \\\\ \\sin \\theta _{Z} & \\cos \\theta _{Z} & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]\\left[\\begin{array}{cccc} 1 & 0 & 0 & 0 \\\\ 0 & \\cos \\theta _{X} & -\\sin \\theta _{X} & 0 \\\\ 0 & \\sin \\theta _{X} & \\cos \\theta _{X} & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]\\left[\\begin{array}{cccc} \\cos \\theta _{Y} & 0 & \\sin \\theta _{Y} & 0 \\\\ 0 & 1 & 0 & 0 \\\\ -\\sin \\theta _{Y} & 0 & \\cos \\theta _{Y} & 0 \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 由于Unity文档中说明的旋转顺序是在旋转过程中保持坐标轴不变的（不是那种旋转一个轴后由于自身方向的改变再按新的坐标轴的旋转的顺序），所以在这里按zxy顺序旋转和带坐标轴旋转的yxz顺序旋转是一样的。 3. 坐标空间3.1 坐标空间变换 $$ \\mathbf{M}_{c\\rightarrow p}=\\left[\\begin{array}{cccc} | & | & | & | \\\\ \\mathbf x_{c} & \\mathbf y_{c} & \\mathbf z_{c} & \\mathbf O_{c} \\\\ | & | & | & | \\\\ 0 & 0 & 0 & 1 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 其中，$$\\mathbf{M}_{c\\rightarrow p}$$表示的是从子坐标空间变换到父坐标空间变换的变换矩阵，其逆矩阵这位从父坐标空间变换到子坐标空间变换的变换矩阵。 我们知道，矢量是没有位置的，因此坐标空间的原点变换是可以忽略的。也就是说，我们仅仅平移坐标系的原点是不会对矢量造成任何影响的。那么，对矢量的坐标空间变换就可以使用3X3的矩阵来表示，因为我们不需要表示平移变换。那么变换矩阵就是： $$ \\mathbf{M}_{c\\rightarrow p} =\\left[\\begin{array}{cccc} | & | & | \\\\ \\mathbf x_{c} & \\mathbf y_{c} & \\mathbf z_{c} \\\\ | & | & | \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 其逆矩阵则为： $$ \\mathbf{M}_{c\\rightarrow p} =\\left[\\begin{array}{cccc} - & \\mathbf x_{B} & - \\\\ - & \\mathbf y_{B} & - \\\\ - & \\mathbf z_{B} & - \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 在Shader中，我们常常会看到截取变换矩阵的前3行和前3列来对法线方向、光照方向来进行空间变换，这正是原因所在。 例如我们想把一个矢量从坐标空间$ \\mathbf A $变换到坐标空间$ \\mathbf B $，而且我们已经知道坐标空间$ \\mathbf B $的x轴、y轴、z轴在空间$ \\mathbf A $下的表示，即$\\mathbf x_{B} $、$ \\mathbf y_{B} $和$ \\mathbf z_{B} $。那么想要得到从$ \\mathbf A $到$ \\mathbf B $的变换矩阵$ \\mathbf{M}_{c\\rightarrow p} $，我们可以用$ \\mathbf{M}_{c\\rightarrow p} $来变换$\\mathbf x_{B} $，那么得到的结果应该是(1,0,0)，那么我们按行来摆放就有： $$ \\mathbf{M}_{A\\rightarrow B} \\mathbf x_{B} =\\left[\\begin{array}{cccc} - & \\mathbf x_{B} & - \\\\ - & \\mathbf y_{B} & - \\\\ - & \\mathbf z_{B} & - \\end{array}\\right] \\mathbf x_{B} = \\left[\\begin{array}{cccc} \\mathbf x_{B} \\cdot \\mathbf x_{B} \\\\ \\mathbf y_{B} \\cdot \\mathbf y_{B} \\\\ \\mathbf z_{B} \\cdot \\mathbf z_{B} \\end{array}\\right] = \\left[\\begin{array}{cccc} 1 \\\\ 0 \\\\ 0 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 3.2 模型空间下面我们要说说，在渲染流水线中，顶点在各个空间的变换过程。 3.2.1 模型空间模型空间（model space）也叫对象空间（object space）或局部空间（local space）。每个模型都有自己独立的坐标空间，当它移动或旋转时，模型空间也会跟着移动和旋转。 3.2.2 世界空间世界空间（world space）相对于模型空间，世界空间是模型所在的最外层的父空间。Unity中，世界空间同样是左手坐标系，原点是游戏空间的中心，x、y、z轴固定不变。 3.2.3 观察空间观察空间（view space）观察空间也被称为摄像机空间，在观察空间中，摄像机位于原点，它决定了我们渲染游戏所使用的视角，观察空间采用的是右手坐标系，所以+z轴指的是摄像机后方。 为了得到顶点在观察空间的位置，我们可以有两种方法。 一是计算观察空间的三个坐标轴在世界空间的表示，然后算出观察空间到世界空间的变换矩阵，再求逆得住世界空间到观察空间的变换矩阵。 二是平移整个观察空间，让摄像机原点位于世界空间原点，坐标轴与世界空间坐标轴重合。两种方法得到的变换矩阵是一样的。 这里我们用第二种方法，有一点很重要，我们上面说过世界空间的变换顺序公式是先缩放，再旋转，再平移，而这里我们为了把摄像机移回世界坐标原点，我们需要逆向变换，所以是先平移，再旋转，再缩放。$$\\mathbf{M_{view}}=\\mathbf{M_{scale}}\\mathbf{M_{rotation}}\\mathbf{M_{tramslation}}$$因为观察空间是右手坐标系，与世界空间的左手坐标系z轴相反，所以z分量要取反操作： 3.2.4 裁剪空间-透视投影我们先看看透视投影的6个裁剪平面怎么决定的。在Unity中，它们由Camera组件中的参数和Game视图的纵横比共同决定。如图所示： 上图中Camera的Field of View(FOV)决定视锥体竖直方向的张开角度，Clipping Planes中的Near和Far决定视锥体的近裁剪平面和远裁剪平面距离摄像机的远近，这样就可以求出近和远裁剪平面的高度： $$ \\begin{aligned} &\\text {nearClipPlaneHeight}=2 \\cdot \\text {Near} \\cdot \\tan \\frac{F O V}{2}\\\\ &\\text {farClipPlaneHeight}=2 \\cdot \\text {Far} \\cdot \\tan \\frac{F O V}{2} \\end{aligned} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 而横向信息由摄像机的纵横比决定。这个纵横比由Game视图的纵横比和Viewport Rect中的W和H属性共同决定（Unity中可以通过Camera.aspect获得）。假设纵横比为Aspect，则： $$ \\begin{aligned} \\text {Aspect} &=\\frac{\\text {nearClipPlaneWidth}}{\\text {nearClipPlaneHeight}} \\\\ \\text {Aspect} &=\\frac{\\text {farClipPlaneWidth}}{\\text {farClipPlaneHeight}} \\end{aligned} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 这样可以确定透视投影的投影矩阵： $$ \\mathbf{M}_{\\text {frustum}}=\\left[\\begin{array}{cccc} \\frac{\\cot \\frac{F O V}{2}}{A s p e c t} & 0 & 0 & 0 \\\\ 0 & \\cot \\frac{F O V}{2} & 0 & 0 \\\\ 0 & 0 & -\\frac{F a r+N e a r}{F a r-N e a r} & -\\frac{2 \\cdot N e a r \\cdot F a r}{F a r-N e a r} \\\\ 0 & 0 & -1 & 0 \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 这个投影矩阵是建立在Unity坐标系上，观察空间是右手坐标系，使用列矩阵右乘，且变换后z分量在[-w, w]之间。但在DirectX中，z分量在[0, w]之间，上面的透视矩阵就要更改了。 用上一步观察空间得到的坐标和投影矩阵相乘，就可以变换到裁剪空间中： $$ \\mathbf p_{clip}=\\mathbf M_{frustum}\\mathbf P_{view}=\\left[\\begin{array}{cccc} \\frac{\\cot \\frac{F O V}{2}}{A s p e c t} & 0 & 0 & 0 \\\\ 0 & \\cot \\frac{F O V}{2} & 0 & 0 \\\\ 0 & 0 & -\\frac{F a r+N e a r}{F a r-N e a r} & -\\frac{2 \\cdot N e a r \\cdot F a r}{F a r-N e a r} \\\\ 0 & 0 & -1 & 0 \\end{array}\\right]\\left[\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right]=\\left[\\begin{array}{c} x\\frac{\\cot \\frac{F O V}{2}}{A s p e c t} \\\\ y \\cot \\frac{F O V}{2} \\\\ -z \\frac{F a r+N e a r}{F a r-N e a r}-\\frac{2 \\cdot N e a r \\cdot F a r}{F a r-N e a r} \\\\ -z \\end{array}\\right] $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 本质就是对x、y、z做了不同的缩放（z还有个平移）。w也不再是1，而是z取反。最后通过x、y、z是否在[-w, w]中判断是否位于视锥体内。不在其内的会被剔除或裁剪，这样通过投影矩阵后，视锥体变化如下： 3.2.5 裁剪空间-正交投影 视锥体是个长方体，因此不需要FOV了，用Size代替了，Size是高度的一半,Aspect是横纵比。因此，我们得到公式：$$nearClipPlaneHeight =2 \\cdot Size$$$$farClipPlaneHeight = nearclipPlaneHeight$$$$nearclipPlaneWidth = Aspect \\cdot nearClipPlaneHeight$$$$farClipPlaneWidth = nearClipPlaneWidth$$ 这样，可以得到正交投影的裁剪矩阵： $$ \\begin{aligned} \\mathbf p_{cip}=\\mathbf M_{ortho} \\mathbf P_{view} &=\\left[\\begin{array}{ccc} \\frac{1}{\\text {Aspect} \\cdot \\text {Size}} & 0 & 0 & 0 \\\\ 0 & \\frac{1}{\\text {Size}} & 0 & 0 \\\\ 0 & 0 & -\\frac{2}{\\text {Far}-\\text {Near}} & -\\frac{\\text {Far}+\\text {Near}}{\\text {Far}-\\text {Near}} \\\\ 0 & 0 & 0 & 1 \\end{array}\\right]\\left[\\begin{array}{l} x \\\\ y \\\\ z \\\\ 1 \\end{array}\\right]=\\left[\\begin{array}{l} \\frac{x}{\\text {Aspect} \\cdot \\text {Size}}\\\\ \\frac{y}{\\text {Size}} \\\\ -\\frac{2 z}{\\text {Far}-\\text {Near}}-\\frac{\\text {Far}+\\text {Near}}{\\text {Far}-\\text {Near}} \\\\ 1 \\end{array}\\right] \\end{aligned} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 然后观察空间的顶点与矩阵相乘：\\frac{x}{\\text {Aspect} \\cdot \\text {Size}} 可以看出，w分量依然为1。判断是否位于裁剪空间内与透视投影一样，x、y、z是否在[-w, w]之间。通过投影矩阵后，视锥体变化如下： 可以看出，变换后空间从长方体变成正方体了，范围是[-1, 1]。 3.3 屏幕空间经过投影矩阵变换后，我们完成了裁剪工作，开始正式投影了，把视锥体投影到屏幕空间。屏幕空间是个二维空间，投影的过程分为两步： 首先，要进行齐次除法，也被称为透视除法。就是用x、y、z分量除以w分量。在OpenGL中，这一步得到的坐标叫归一化的设备坐标（NDC,Normalized Device Coordinates）。经过这一步，我们把坐标从齐次裁剪空间转换到NDC中，这样会使透视投影的类似金字塔形状的空间变成正方体，并且和正交投影的一样： 透视投影坐标经裁剪矩阵变换后w是-z，所以坐标x、y、z都除以-z就得到了右边的样子。而正交投影变换后w是1，所以除以1没变化，这样两种投影方式就都是一样的正方体了。 现在，我们开始屏幕映射了。Unity左下角坐标是（0, 0），右上角是（pixelWidth, pixelHeight），现在经过齐次除法后x、y的范围是[-1, 1]，所以这个过程就是个缩放的过程。 首先把x、y变到[0, 1]，比如x = (x+1) / 2，然后再乘以pixelWidth就是映射后的x了，当然这里的x，y都是裁剪空间的坐标除以w。 齐次除法和屏幕映射的过程可以使用下面的公式来总结： $$ \\begin{array}{l} \\text {screen}_{x}=\\frac{\\operatorname{clip}_{x} \\cdot \\text {pixelWidth}}{2 \\cdot \\operatorname{clip}_{w}}+\\frac{\\text {pixelWidth}}{2} \\\\ \\text {screen}_{y}=\\frac{\\text {clip}_{y} \\cdot \\text {pixelHeight}}{2 \\cdot \\operatorname{clip}_{w}}+\\frac{\\text {pixelHeight}}{2} \\end{array} $$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); 在上式中，x、y被用作投影了，z分量会被用于深度缓冲，传统方式是z/w直接存进深度缓冲，但这不是必须的，驱动生产商会根据硬件来选择最好的存储格式。 4. 法线变换在游戏中，模型的顶点携带的信息中，法线就是其中一种。我们变换一个模型，不仅需要变换它的顶点，还需要变换顶点法线，以便在后续处理（如片元着色器）中计算光照等。 但在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性。 因此，在法线的变换过程中，我们使用原变换矩阵的逆转置矩阵来变换法线就可以得到正确的结果。 因为逆矩阵的计算比较麻烦，所以我们可以根据变换类型尽可能的避免逆矩阵的计算过程： 变换只包括旋转变换，那么这个变换矩阵就是正交矩阵（正交矩阵的转置矩阵与逆矩阵相同）； 变换只包括旋转和统一缩放，则可以利用统一缩放指数k来得到变换矩阵的逆转置矩阵； 变换包括了非统一变换，则必须求解逆转置矩阵。 5. 总结顶点着色器的最基本的任务就是把顶点坐标从模型空间转换到裁剪空间中。而在片元着色器中，我们通常也可以得到该片元在屏幕空间的像素位置。 通常在变换顶点时，我们都是使用右乘的方式来按列矩阵进行乘法。这是因为Unity提供的内置矩阵（如UNITY_MATRIX_MVP(模型观察投影矩阵)等）都是按照列存储的。 在Unity中，坐标系的旋向性也随着变换发生了转变。下图总结了Unity中各个空间使用的坐标系旋向性。","link":"/2020/04/07/cg-unity-matrix/"},{"title":"计算机图形学-基本图形生成","text":"在DDA画线算法、中点Bresenham 画线算法和Bresenham 画圆算法原理的基础上，用高级语言实现上述算法，并在开发平台中调试、输出结果。 添加菜单、对话框等，实现交互式画线、画圆。 1. 原理1.1 直线扫描转换——数值微分法（DDA） 1.2 中点Bresenham算法 1.3 Bresenham画圆法 2. 程序实现2.1 OnDraw函数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void CCG1View::OnDraw(CDC* pDC){ CCG1Doc* pDoc = GetDocument(); ASSERT_VALID(pDoc); if (!pDoc) return; // TODO: 在此处为本机数据添加绘制代码 //CClientDC pDC(this); //pDC.TextOut(100, 100, L\"同学们认真实验\"); //输出字符 //pDC.SetPixel(100, 110, RGB(255, 0, 0)); //画点 //pDC.MoveTo(300, 150); //pDC.LineTo(700, 300); //画线 int i; double r; switch (m_Switch) { case 0: { DDALine(pDC, 0, 0, 400, 400, RGB(255, 0, 0)); DDALine(pDC, 0, 400, 400, 0, RGB(255, 0, 0)); DDALine(pDC, 200, 0, 200, 400, RGB(255, 0, 0)); DDALine(pDC, 0, 200, 400, 200, RGB(255, 0, 0)); BRHLine(pDC, 200, 200, 100, 0, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 0, 100, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 0, 300, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 100, 400, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 300, 400, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 400, 300, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 400, 100, RGB(0, 0, 255)); BRHLine(pDC, 200, 200, 300, 0, RGB(0, 0, 255)); BRHCircle(pDC, 200, 200, 200, RGB(255, 0, 255)); BRHCircle(pDC, 200, 200, 100, RGB(0, 255, 255)); break; } case 1: { for (i = 0; i &lt; i2; i += 2) { // r = sqrt(pow((m_Point[i + 1][1] - m_Point[i][1]), 2) + pow((m_Point[i][0] - m_Point[i + 1][0]), 2)); // BRHCircle(pDC, m_Point[i][0], m_Point[i][1], r, RGB(0, 255, 0)); BRHLine(pDC, m_Point[i][0], m_Point[i][1], m_Point[i+1][0], m_Point[i+1][1], RGB(0, 0, 255)); } break; } case 2: { for (i = 0; i &lt; i2; i += 2) { r = sqrt(pow((m_Point[i + 1][1] - m_Point[i][1]), 2) + pow((m_Point[i][0] - m_Point[i + 1][0]), 2)); BRHCircle(pDC, m_Point[i][0], m_Point[i][1], r, RGB(0, 255, 0)); // BRHLine(pDC, m_Point[i][0], m_Point[i][1], m_Point[i+1][0], m_Point[i+1][1], RGB(0, 0, 0)); } break; } } } 2.2 DDALine12345678910111213141516void CCG1View::DDALine(CDC* pDC, int x0, int y0, int x1, int y1, COLORREF color){ // TODO: 在此处添加实现代码. double dx, dy, e, x, y; int i; e = max(abs(x1 - x0), abs(y1 - y0)); dx = (x1 - x0) / e; dy = (y1 - y0) / e; x = x0; y = y0; for (i = 1; i &lt;= e; i++) { pDC-&gt;SetPixel(int(x + 0.5), int(y + 0.5), color); x = x + dx; y = y + dy; }} 2.3 BRHLine12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394void CCG1View::BRHLine(CDC* pDC, int x0, int y0, int x1, int y1, COLORREF color){ // TODO: 在此处添加实现代码. int temp; if (x0 &gt; x1 &amp;&amp; y0 &gt; y1) { temp = x0; x0 = x1; x1 = temp; temp = y0; y0 = y1; y1 = temp; } else if (x0 &gt; x1 &amp;&amp; y0 &lt; y1) { temp = x0; x0 = x1; x1 = temp; temp = y0; y0 = y1; y1 = temp; } int x, y, dx, dy, d; x = x0; y = y0; dx = x1 - x0; dy = y1 - y0; if (dx &gt; 0 &amp;&amp; dy &gt; 0) { if (dx &gt; dy) { d = 2 * dy - dx; //增量d的初始值 for (x = x0; x &lt;= x1; x++) { pDC-&gt;SetPixel(x, y, color); if (d &gt;= 0) { y++; d += 2 * (dy - dx); } else { d += 2 * dy; } } } else { d = 2 * dx - dy; //增量d的初始值 for (y = y0; y &lt;= y1; y++) { pDC-&gt;SetPixel(x, y, color); if (d &gt;= 0) { x++; d += 2 * (dx - dy); } else { d += 2 * dx; } } } } else if (dx &gt; 0 &amp;&amp; dy &lt; 0) { dx = abs(dx); dy = abs(dy); if (dx &gt; dy) { d = 2 * dy - dx; //增量d的初始值 for (x = x0; x &lt;= x1; x++) { pDC-&gt;SetPixel(x, y, color); if (d &gt;= 0) { y--; d += 2 * (dy - dx); } else { d += 2 * dy; } } } else { d = 2 * dx - dy; //增量d的初始值 for (y = y0; y &gt;= y1; y--) { pDC-&gt;SetPixel(x, y, color); if (d &gt;= 0) { x++; d += 2 * (dx - dy); } else { d += 2 * dx; } } } }} 2.4 BRHCircle12345678910111213141516171819202122232425262728void CCG1View::BRHCircle(CDC* pDC, int x0, int y0, int r, COLORREF color){ // TODO: 在此处添加实现代码. int x, y, p; x = 0; y = r; p = 3 - 2 * r; for (x = 0; x &lt;= y; x++) { pDC-&gt;SetPixel(x + x0, y + y0, color); pDC-&gt;SetPixel(y + x0, x + y0, color); pDC-&gt;SetPixel(x + x0, -y + y0, color); pDC-&gt;SetPixel(-y + x0, x + y0, color); pDC-&gt;SetPixel(-x + x0, y + y0, color); pDC-&gt;SetPixel(y + x0, -x + y0, color); pDC-&gt;SetPixel(-x + x0, -y + y0, color); pDC-&gt;SetPixel(-y + x0, -x + y0, color); if (p &gt;= 0) { p += 4 * (x - y) + 10; y--; } else { p += 4 * x + 6; } }} 3. 测试3.1 函数测试 3.2 画线测试 3.3 画圆测试","link":"/2019/04/21/cg-base-graphics/"},{"title":"计算机图形学-几何变换","text":"利用二维几何变换的数学模型，实现平移、旋转和缩放等变换； 加入鼠标和菜单功能，实现交互式图形变换； 1. 原理1.1 平移 1.2 缩放 1.3 旋转 2. 程序实现2.1 mygTranslatef123456789void CCG2View::mygTranslatef(float x, float y, Object obj[]){ int i; for (i = 0; i &lt;= 2; i++) { obj[i].x += x; obj[i].y += y; }} 2.2 myglRotatef123456789void CCG2View::mygTranslatef(float x, float y, Object obj[]){ int i; for (i = 0; i &lt;= 2; i++) { obj[i].x += x; obj[i].y += y; }} 2.3 myglScalef123456789void CCG2View::myglScalef(float x, float y, Object obj[]){ int i; for (i = 0; i &lt;= 2; i++) { obj[i].x *= x; obj[i].y *= y; }} 2.4 drawObject12345678910111213141516171819202122232425262728void CCG2View::drawObject(CDC* pDC, Object obj[]){ DDALine(pDC, obj[0].x, obj[0].y, obj[1].x, obj[1].y, RGB(0, 0, 255)); DDALine(pDC, obj[1].x, obj[1].y, obj[2].x, obj[2].y, RGB(0, 0, 255)); DDALine(pDC, obj[2].x, obj[2].y, obj[0].x, obj[0].y, RGB(0, 0, 255)); CString str1, str2, str3; str1 = str2 = str3 = \"\"; str1.Format(_T(\"(%.f,%.f)\"), obj[0].x, obj[0].y); str2.Format(_T(\"(%.f,%.f)\"), obj[1].x, obj[1].y); str3.Format(_T(\"(%.f,%.f)\"), obj[2].x, obj[2].y); pDC-&gt;TextOutW(obj[0].x + 3, obj[0].y + 3, str1); pDC-&gt;TextOutW(obj[1].x + 3, obj[1].y + 3, str2); pDC-&gt;TextOutW(obj[2].x + 3, obj[2].y + 3, str3); int i; for (i = 0; i &lt;= 2; i++) { pDC-&gt;SetPixel(obj[i].x, obj[i].y, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x + 1, obj[i].y, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x, obj[i].y + 1, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x + 1, obj[i].y + 1, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x - 1, obj[i].y - 1, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x, obj[i].y - 1, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x + 1, obj[i].y - 1, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x - 1, obj[i].y, RGB(255, 0, 0)); pDC-&gt;SetPixel(obj[i].x - 1, obj[i].y + 1, RGB(255, 0, 0)); }} 3. 测试3.1 初始化 3.2 平移 3.3 旋转 3.4 缩放","link":"/2019/05/02/cg-geo-tran/"},{"title":"计算机图形学-多边形扫描转换","text":"输入一个用顶点序列表示的多边形，利用 x-扫描线算法实现多边形填充； 利用屏幕取点法确定多边形的顶点序列，绘制闭合多边形并用颜色填充。 1. 原理1.1 基本概念 1.2 实现步骤 1.3 涉及的问题 2. 程序实现2.1 数据结构1234567891011struct EdgeNode { int ymax;//直线上端点的y坐标 double xmin;//直线下端点的x坐标 double fm;//斜率倒数 EdgeNode* next;//连接下一个边};struct HeadNode {//头节点 相当于EdgeTable ET 表中登记项的y值 int ymin;//最小y值， EdgeNode* link;//连接边节点 HeadNode* next;//连接下一个头节点}; 2.2 GetET 创建边表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869CCG4_2View::HeadNode* CCG4_2View::GetET(CArray&lt;CPoint, CPoint&gt;* points){ HeadNode* pHead = NULL;//初始化边表的头节点 int ymin; int nymin, nymax; for (int i = 0; i&lt;points-&gt;GetSize(); i++)//构造边链表 { CPoint point1 = (CPoint)points-&gt;GetAt(i); CPoint point2; if (i == points-&gt;GetSize() - 1)//最后一个点和第一点构成一条边 point2 = (CPoint)points-&gt;GetAt(0); else point2 = (CPoint)points-&gt;GetAt(i + 1); if (point1.y == point2.y)//舍弃平行于x轴 continue; EdgeNode* edge = new EdgeNode(); edge-&gt;next = NULL;//初始化边表 edge-&gt;fm = (double)(point2.x - point1.x) / (point2.y - point1.y); if (point1.y &gt; point2.y) { edge-&gt;ymax = point1.y; ymin = point2.y; edge-&gt;xmin = point2.x; } else { edge-&gt;ymax = point2.y; ymin = point1.y; edge-&gt;xmin = point1.x; } CPoint point3; int j = i + 2; do { if (j&lt;points-&gt;GetSize()) point3 = (CPoint)points-&gt;GetAt(j); else point3 = (CPoint)points-&gt;GetAt(j - points-&gt;GetSize()); j++; } while (point2.y == point3.y); if (point2.y &gt; point3.y) { nymax = point2.y; nymin = point3.y; } else { nymax = point3.y; nymin = point2.y; } if (ymin != nymin &amp;&amp; edge-&gt;ymax != nymax)//不为局部极大或极小 { if (edge-&gt;ymax &gt; nymax) { ymin++; edge-&gt;xmin += edge-&gt;fm; } else edge-&gt;ymax--; } //加入 ET 表 if (pHead == NULL) { pHead = new HeadNode(); pHead-&gt;ymin = ymin; pHead-&gt;link = edge; pHead-&gt;next = NULL; } else AddEdge(pHead, ymin, edge); } //返回ET表头指针 EdgeTable return pHead;} 2.3 AddEdge 添加边到边表123456789101112131415161718192021222324252627282930313233343536373839404142void CCG4_2View::AddEdge(HeadNode* head, int ymin, EdgeNode* edge){ HeadNode* temphead; temphead = NULL; while (head != NULL) { if (head-&gt;ymin == ymin) { EdgeNode* p = head-&gt;link;//连接边表 if (p-&gt;xmin &gt; edge-&gt;xmin) { head-&gt;link = edge; edge-&gt;next = p; return; } while (p-&gt;next != NULL) { if (p-&gt;next-&gt;xmin &gt; edge-&gt;xmin) { edge-&gt;next = p-&gt;next; p-&gt;next = edge; return; } p = p-&gt;next; } p-&gt;next = edge; return; } else if (head-&gt;ymin &gt; ymin) { HeadNode* newhead = new HeadNode(); newhead-&gt;ymin = head-&gt;ymin; newhead-&gt;link = head-&gt;link; newhead-&gt;next = head-&gt;next; head-&gt;ymin = ymin; head-&gt;link = edge; head-&gt;next = newhead; return; } temphead = head; head = head-&gt;next; } HeadNode* newhead = new HeadNode(); newhead-&gt;ymin = ymin; newhead-&gt;link = edge; newhead-&gt;next = NULL; temphead-&gt;next = newhead;} 2.4 Polygonfill 多边形填充12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879void CCG4_2View::Polygonfill(CDC *pDC, CArray&lt;CPoint, CPoint&gt;* points, COLORREF color){ HeadNode* pET = GetET(points); EdgeNode* pAET = NULL;//初始化活动边表 int y = pET-&gt;ymin; int ymax = y; //有需要处理的扫描线 while (y &lt;= ymax) { if (pET != NULL &amp;&amp; pET-&gt;ymin == y) { EdgeNode* p = pET-&gt;link; if (pAET == NULL) pAET = p; else { EdgeNode* q = pAET; while (q-&gt;next != NULL) q = q-&gt;next; q-&gt;next = p; } //清除已经处理过的头节点，并释放空间 HeadNode* deletehead = pET; pET = pET-&gt;next; delete deletehead; while (p != NULL) { if(ymax &lt; p-&gt;ymax) ymax = p-&gt;ymax; p = p-&gt;next; } SortAET(pAET); } EdgeNode* pFill = pAET; while (pFill != NULL) { /***********使用LineTo提高绘制效率***********/ if(m_Switch == 3){ int i1 = (int)pFill-&gt;xmin; int i2 = (int)pFill-&gt;next-&gt;xmin; pDC-&gt;MoveTo(i1, y); pDC-&gt;LineTo(i2, y); }else{ /***********使用SetPixel进行像素点绘制***********/ for (int i = (int)pFill-&gt;xmin; i &lt;= (int)pFill-&gt;next-&gt;xmin; i++) pDC-&gt;SetPixel(i, y, color); } pFill = pFill-&gt;next-&gt;next; } pFill = pAET; EdgeNode* pFore = NULL; while (pFill != NULL) { if (pFill-&gt;ymax == y) { if (pFore != NULL) pFore-&gt;next = pFill-&gt;next; else pAET = pFill-&gt;next; EdgeNode* deleteedge = pFill; pFill = pFill-&gt;next; delete deleteedge; } else { pFore = pFill; pFill = pFill-&gt;next; } } if (pAET != NULL) { pFill = pAET; while (pFill != NULL) { pFill-&gt;xmin += pFill-&gt;fm; pFill = pFill-&gt;next; } SortAET(pAET); } y++; }} 2.5 SortAET 排序123456789101112131415161718192021222324252627void CCG4_2View::SortAET(EdgeNode *pEDGE){ EdgeNode* p1 = pEDGE; EdgeNode* p2 = NULL; while (p1 != NULL) { p2 = p1-&gt;next; while (p2 != NULL) { if (p1-&gt;xmin &gt; p2-&gt;xmin) { int cid; double cdd; cid = p1-&gt;ymax; p1-&gt;ymax = p2-&gt;ymax; p2-&gt;ymax = cid; cdd = p1-&gt;xmin; p1-&gt;xmin = p2-&gt;xmin; p2-&gt;xmin = cdd; cdd = p1-&gt;fm; p1-&gt;fm = p2-&gt;fm; p2-&gt;fm = cdd; } p2 = p2-&gt;next; } p1 = p1-&gt;next; }} 3. 测试3.1 实现多边形顶点序列的绘制 3.2 鼠标绘制 3.3 提升绘制效率 4. 总结对已给的数据结构进行了改动，将顶点数据结构和像素点数据结构改为利用MFC一个数组模板类CArray的动态数组，并使用CPoint记录点，利用GetSize()函数获取序列中点的数目实现对点个数的统计。将活动边表的数据结构合并为边表的数据结构，AET中的xi由其下端点的x坐标加上斜率的倒数求得。 为了避免思考题中出现表头数组浪费空间的情况，将EdgeTable改为边表的头节点，利用头节点连接该ytop值的边。","link":"/2019/06/18/cg-polygon-scan/"}],"tags":[{"name":"建模","slug":"建模","link":"/tags/%E5%BB%BA%E6%A8%A1/"},{"name":"3ds Max","slug":"3ds-Max","link":"/tags/3ds-Max/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"游戏","slug":"游戏","link":"/tags/%E6%B8%B8%E6%88%8F/"},{"name":"works","slug":"works","link":"/tags/works/"},{"name":"C4D","slug":"C4D","link":"/tags/C4D/"},{"name":"ZBrush","slug":"ZBrush","link":"/tags/ZBrush/"},{"name":"动画","slug":"动画","link":"/tags/%E5%8A%A8%E7%94%BB/"},{"name":"性能分析","slug":"性能分析","link":"/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"短片","slug":"短片","link":"/tags/%E7%9F%AD%E7%89%87/"},{"name":"Octane","slug":"Octane","link":"/tags/Octane/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Maya","slug":"Maya","link":"/tags/Maya/"},{"name":"Substance Designer","slug":"Substance-Designer","link":"/tags/Substance-Designer/"},{"name":"程序化","slug":"程序化","link":"/tags/%E7%A8%8B%E5%BA%8F%E5%8C%96/"},{"name":"设计","slug":"设计","link":"/tags/%E8%AE%BE%E8%AE%A1/"},{"name":"UI","slug":"UI","link":"/tags/UI/"},{"name":"Unity","slug":"Unity","link":"/tags/Unity/"},{"name":"Shader","slug":"Shader","link":"/tags/Shader/"},{"name":"Game","slug":"Game","link":"/tags/Game/"},{"name":"VR","slug":"VR","link":"/tags/VR/"},{"name":"大创","slug":"大创","link":"/tags/%E5%A4%A7%E5%88%9B/"},{"name":"地编","slug":"地编","link":"/tags/%E5%9C%B0%E7%BC%96/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"GLSL","slug":"GLSL","link":"/tags/GLSL/"},{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"logo设计","slug":"logo设计","link":"/tags/logo%E8%AE%BE%E8%AE%A1/"},{"name":"海报设计","slug":"海报设计","link":"/tags/%E6%B5%B7%E6%8A%A5%E8%AE%BE%E8%AE%A1/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"ASP","slug":"ASP","link":"/tags/ASP/"},{"name":"jQuery","slug":"jQuery","link":"/tags/jQuery/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"美术","slug":"美术","link":"/tags/%E7%BE%8E%E6%9C%AF/"},{"name":"计算机图形学","slug":"计算机图形学","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"交互设计","slug":"交互设计","link":"/tags/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"},{"name":"JSP","slug":"JSP","link":"/tags/JSP/"},{"name":"原型设计","slug":"原型设计","link":"/tags/%E5%8E%9F%E5%9E%8B%E8%AE%BE%E8%AE%A1/"},{"name":"C","slug":"C","link":"/tags/C/"},{"name":"ActionScript","slug":"ActionScript","link":"/tags/ActionScript/"},{"name":"素描","slug":"素描","link":"/tags/%E7%B4%A0%E6%8F%8F/"}],"categories":[{"name":"3ds Max","slug":"3ds-Max","link":"/categories/3ds-Max/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"C4D","slug":"C4D","link":"/categories/C4D/"},{"name":"性能分析","slug":"性能分析","link":"/categories/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"游戏","slug":"游戏","link":"/categories/%E6%B8%B8%E6%88%8F/"},{"name":"Maya","slug":"Maya","link":"/categories/Maya/"},{"name":"Substance Designer","slug":"Substance-Designer","link":"/categories/Substance-Designer/"},{"name":"设计","slug":"设计","link":"/categories/%E8%AE%BE%E8%AE%A1/"},{"name":"Shader","slug":"Shader","link":"/categories/Shader/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Android","slug":"Android","link":"/categories/Android/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"游戏美术","slug":"游戏美术","link":"/categories/%E6%B8%B8%E6%88%8F%E7%BE%8E%E6%9C%AF/"},{"name":"交互设计","slug":"交互设计","link":"/categories/%E4%BA%A4%E4%BA%92%E8%AE%BE%E8%AE%A1/"},{"name":"计算机图形学","slug":"计算机图形学","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"ActionScript","slug":"ActionScript","link":"/categories/ActionScript/"},{"name":"美术","slug":"美术","link":"/categories/%E7%BE%8E%E6%9C%AF/"}]}